[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A linguagem JavaScript",
    "section": "",
    "text": "Este livro vivo foi pensado como uma introdução à linguagem JavaScript para uso do programa JSPlotly. Seguem os capítulos em construção.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "linguagem.html",
    "href": "linguagem.html",
    "title": "3  A linguagem",
    "section": "",
    "text": "3.1 JavaScript\n1. \"multiparadigma\": suporta programação orientada a objetos (baseada em protótipo), programação imperativa, e programação declarativa;\n2. programação \"imperativa\": descreve o fluxo de controle passo a passo (ou \"como\");\n3. programação \"declarativa\": descreve o que se deseja que o programa execute (ou \"o que\");\n4. \"protótipos\": utiliza protótipos para a herança de objetos;\n5. \"interpretada\": executado diretamente pelo interpretador (browser moderno), sem necessidade de um compilador.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem</span>"
    ]
  },
  {
    "objectID": "linguagem.html#javascript",
    "href": "linguagem.html#javascript",
    "title": "3  A linguagem",
    "section": "",
    "text": "Javacript (JS) é uma linguagem para web. Ela completa a tríade essencial, HTML-CSS-JS. Enquanto HTML preocupa-se com o conteúdo e CSS com o estilo, JavaScript ocupa-se do comportamento, ou seja, a interatividade do usuário frente à uma página web.\n  Um pouco mais formalmente, JavaScript consiste numa linguagem de programação multiparadigma interpretada para protótipos, e baseada em objetos imperativos e declarativos. Tá bom, isso não é muito lá explicativo. Tentando uma tradução livre, então:\n\n  Dentre as características acima, a última, linguagem “interpretada”, difere de outras linguagens de programação de forma singular: o fato de ser uma linguagem que não precisa de um compilador externo possibilita que o código criado seja lido em qualquer navegador, já que esses possuem há bastante tempo um interpretador, ou máquina JS.\n  JavaScript teve seu nascimento das mãos do programador norte-americano Brendan Eich em 1995, na Netscape Communications, embora tenha sido formalizada como linguagem padronizada em 1997 1. Originalmente foi concebida para acrescentar interatividade a páginas web. Inicialmente denominada Mocha e depois LiveScript, foi renomeada para JavaScript mais por uma coincidência histórica e estratégia de marketing do que por semelhanças técnicas, para se associar à popularidade do Java 2.\n  Caso deseje aprofundar-se em JavaScript, sugere-se os links abaixo:\n\nMDN Web Docs\nJavaScript.info\nW3Schools JavaScript Tutorial\nEloquent JavaScript \n\n  Assim como outras linguagens de programação, a linguagem JS possui bibliotecas, módulos independentes de códigos para cumprir certas funções em distintos cenários. Nesse sentido, JS cumpre metade do nome do JSPlotly. A outra metade vem da principal biblioteca que é utilizada por esse para a construção de gráficos, mapas, e alguns outros objetos interativos, Plotly.js. Sendo assim, nada mais oportuno do que aprender um pouco de JS para compreender como o JSPlotly trabalha com seus códigos junto à biblioteca Plotly.js.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem</span>"
    ]
  },
  {
    "objectID": "linguagem.html#estrutura-de-js",
    "href": "linguagem.html#estrutura-de-js",
    "title": "3  A linguagem",
    "section": "3.2 Estrutura de JS",
    "text": "3.2 Estrutura de JS\n  Uma linguagem de programação normalmente possui características estruturais comuns. Isso quer dizer que há comandos para declarar uma variável e seu tipo, a entrada e saída de dados (resultados), a criação e uso de funções, e cálculos aritméticos, por exemplo.\n  Assim, e mesmo que haja um GSPlotly à mão para a construção de códigos (ou outro assistente de IA), é importante aprender um pouco da estrutura e da sintaxe (comandos) de JS. Como visto no capítulo anterior, esse aprendizado inicial lhe permitirá consideráveis vantagens para além do “vôo às cegas” que se conduz apenas no jogo de cópia/cola dos códigos gerados pela IA. Entre essas vantagens 1) uma melhoria contínua na capacidade de modificar o código sem precisar da IA, 2) um aprendizado inestimável nos dias de hoje para uma linguagem de programação “de ponta” para finalidades variadas.\n  Tal como outras linguagens de programação, JavaScript opera com uma logística similar de declarações (palavras-chave, operadores, valores, expressões). Assim:\n\n## Declarações em JavaScript ##\n\n1. Palavras-chave: sintaxe da linguagem JS;\n2. Operadores: caracteres que realizam operações;\n3. Valores: texto, números, verdadeiro/false (variável \"booleana\"), \"não definido\", \"nulo\";\n4. Expressões: trecho de código que produz um único valor.\n  Do ponto de vista estrutural, por conseguinte, JS possui características que também são comuns a outras linguagens de programação, tais como:\n\n1. Saída de dados;\n2. Declaração de variáveis; \n3. Tipos de dados;\n4. Constantes;\n5. Aritmética;\n6. Vetores;\n7. Funções;\n8. Geração de dados aleatórios;\n9. Objetos;\n10. Operadores;\n11. Estruturas de controle;",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem</span>"
    ]
  },
  {
    "objectID": "linguagem.html#aprendendo-um-pouco-de-js-coma-parábola",
    "href": "linguagem.html#aprendendo-um-pouco-de-js-coma-parábola",
    "title": "3  A linguagem",
    "section": "3.3 Aprendendo um pouco de JS com…a parábola !",
    "text": "3.3 Aprendendo um pouco de JS com…a parábola !\n  Já que utilizamos a parábola do código padrão do JSPlolty como modelo desde o início, por que não começar o aprendizado de JS e Plotly.js com essa ? Vejamos o que há no código da Figura 3.1 abaixo.\n\n\n\n\n\n\n\n\nFigura 3.1: Código padrão para a parábola, como exemplo de uma estrutura de linguagem para JS.\n\n\n\n\nLógica de programação\n  Vamos analisar o código da parábola por 3 “jeitos” crescentes.\n\n1a. Visão do código\n  O código modela uma parábola (y = ax²+bx+c) com coeficientes fixados no início. Inicialmente produz uma lista x e outra y, define os limites que vão aparecer no gráfico, coloca alguns nomes e depois desenha o gráfico.\n  Essa é descrição do algoritmo em linguagem natural, uma primeira aproximação entre a ideia que se deseja e sua formalização.\n\n\n2a. Visão do código\n  Pesando na estrutura da linguagem de programação, o código funciona mais ou menos assim:\n\nDefine-se primeiro os parâmetros da parábola como constantes (declaração de variáveis);\nCria-se duas listas vazias onde será introduzidos os dados (vetores - x e y);\nCria-se os valores para x com um laço repetitivo for (estrutura de controle);\nCalcula-se os valores de y com base na equação (cálculos);\nDefine-se os limites de valores de x e y para o gráfico;\nColoca-se rótulos no gráfico, como título e os nomes dos eixos;\nEntrega-se o gráfico com os ítens acima.\n\n  Essa forma de observar como o objeto é criado numa linguagem de programação está inserida num conceito denominado pensamento computacional (PC). Veja que a lógica desse PC envolve dividir o problema em partes e solucionar cada parte individualmente no algoritmo (dividir para conquistar!).\n\n\n3a. Visão do código\n  Uma outra forma de se abordar o código se dá pelo que se denomina lógica de programação ou pseudocódigo (pseudo linguagem). Ao invés de se textualizar o que o código faz, como acima, ou de se oferecer toda a sintaxe de seus comandos, busca-se descrevê-lo combinando-se um pouco de ambos, linguagem natural e estrutura de programação. Para o exemplo da parábola, a pseudolinguagem poderia ser:\n\n\n\nINÍCIO\n\n// 1) Definir parâmetros da função quadrática y = a·x² + b·x + c\na ← -0,2\nb ←  2,5\nc ←  0,5\n\n// 2) Preparar vetores de dados\nx_values ← lista vazia\ny_values ← lista vazia\n\n// 3) Varredura do domínio: gerar pontos de x de 0 até 20, passo 0,5\nPARA x DE 0 ATÉ 20 PASSO 0,5 FAÇA\n    // 3.1) Registrar o x\n    anexar x EM x_values\n\n    // 3.2) Calcular y(x) = a·x² + b·x + c\n    y ← a * (x^2) + b * x + c\n\n    // 3.3) Registrar o y\n    anexar y EM y_values\nFIM-PARA\n\n// 4) Definir faixas de eixos (range) e rótulos\nx_range ← [0, 15]               // mostrar no gráfico apenas x entre 0 e 15\ny_range ← [0, MÁXIMO(y_values)] // mínimo fixo em 0; máximo conforme dados\n\nx_label ← \"Valores de X\"\ny_label ← \"Valores de Y\"\ntitle   ← \"Função Quadrática\"\n\n// 5) Entregar o \"pacote de saída\" para o mecanismo gráfico\nRETORNAR {\n  x_values, y_values,\n  x_range, y_range,\n  x_label, y_label,\n  title\n}\n\nFIM\n\n\n\n  Perceba então a “escadinha” de linguagem que se forma entre a ideia original e o algoritmo final:\n  Natural → Pseudocódigo → Código real",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem</span>"
    ]
  },
  {
    "objectID": "linguagem.html#footnotes",
    "href": "linguagem.html#footnotes",
    "title": "3  A linguagem",
    "section": "",
    "text": "Eich, Brendan, and C. Rand McKinney. “JavaScript language specification.” Techn. Ber. Netscape Communications, Nov (1996): 96-002.↩︎\nA linguagem foi padronizada como ECMAScript (ES1) em 1997 pela Ecma International, para garantir sua interoperabilidade entre navegadores. Atualmente JavaScript conta com atualizações anuais e que possibilitaram funções arrow, classes, módulos e promises para desenvolvimento web, tanto em front-end quanto no back-end com Node.js, para aplicações web, criação de servidores e automação.↩︎",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem</span>"
    ]
  },
  {
    "objectID": "primeiros.html",
    "href": "primeiros.html",
    "title": "4  Um pouco de estrutura JavaScript",
    "section": "",
    "text": "4.1 Separação de comandos, inserção de comentários, e boas práticas\n&lt;script&gt;  // abre para inserção\n\n...comandos JavaScript\n\n&lt;/script // fecha a inserção",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Um pouco de estrutura JavaScript</span>"
    ]
  },
  {
    "objectID": "primeiros.html#separação-de-comandos-inserção-de-comentários-e-boas-práticas",
    "href": "primeiros.html#separação-de-comandos-inserção-de-comentários-e-boas-práticas",
    "title": "4  Um pouco de estrutura JavaScript",
    "section": "",
    "text": "Os comandos em JS são separados por ponto e vírgula, “;”.\n  Já os comentários constituem trechos não interpretados, comumente utilizados em programação. Comentários são tremendamente úteis quando se deseja colocar um título no script de código, por exemplo, para explicar determinada ação, apontar uma futura melhoria, entre muitos. Em JS são alternativamente inseridos por ” // “ antes de cada comando, ou por ” /…./ “, para comentários mais extensos.\n  Códigos em JS podem ser inseridos junto à páginas web (HTML) com seus comandos intercalados pela notação que segue (etiquetas ou tags:\n\n  Uma característica interessante no JS é que tanto faz colocar ou não espaços entre os comandos, pois a linguagem não interpreta esses espaços. Contudo, dentro das boas práticas em programação, é aconselhável separar blocos de comandos por identação de 2 espaços, de modo a facilitar a leitura do código.\n  Outro cuidado que deve ser apreciado diz respeito a fonte maiúscula e minúscula. JS interpreta diferentemente termos em caixa alta ou baixa do teclado, então é bom se prestar atenção pra não incorrer em erro.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Um pouco de estrutura JavaScript</span>"
    ]
  },
  {
    "objectID": "primeiros.html#declaração-de-variáveis",
    "href": "primeiros.html#declaração-de-variáveis",
    "title": "4  Um pouco de estrutura JavaScript",
    "section": "4.2 Declaração de variáveis",
    "text": "4.2 Declaração de variáveis\n  Entre os diversos tipos de variáveis em JS, duas são frequentemente utilizadas: const e let. A variável const é utilizada para se atribuir um valor fixo a uma variável no código, enquanto a variável let é empregada quando se deseja reatribuir um valor a ela, por meio de algum cálculo ou laço iterativo. Exemplificando, quando se deseja variáveis de controle que mudam ao longo do tempo (sliders, passos, intervalos).\nObs:  em versões antigas de JS é também empregado var, hoje em desuso.\n\n4.2.1 “Botando a mão na massa”\nComo esse treinamento envolve instruir o algoritmo com uma entrada para que sua interpretação resulte numa saída, aqui propomos essa última pelo comando print, como segue.\n\nconst a = -0.2;\nprint(a)\n\n  Para esse treinamento utilizaremos o JSPlotly personalizado abaixo. Assim, teste a atribuição da variável const e do comando print por cópia do trecho acima e cola no campo de texto ÁREA PARA DIGITAR COMANDOS do script que segue, seguido de add:\n\n\n\n  \n\n  Existem outros comandos de saída para JS, como console.log() e document.body.appendChild(), mas não utilizáveis pelo aplicativo.\n  Pode-se atribuir também um texto para apresentar a constante, veja:\n\n\n\nconst a = -0.2;\nprint(\"constante:\",a)\n\n  E também realizar cálculos diretos, veja:\n\n\n\nconst a = 5; // variável constante (não se altera ao longo do código)\nconst b = 10; // variável que pode alterar seu valor no código\nprint(a*b)\n\n  Outro exemplo, com inserção de texto antes do resultado:\n\nlet a = 5;\nconst b = 10;\n\nlet resultado = a + b;\nprint(\"Soma de a + b:\", resultado);\n\n\n\n\n\n4.2.2 const X let\n  Pode parecer que const e let são distintas apenas na aparência, já que operam de modo intercambiável. Contudo, para explicitar a diferença entre os dois comandos, apague o ecrã gráfico (clean) e substitua a linha de código da seção anterior pela que segue na ÁREA PARA DIGITAR COMANDOS do script:\n\nlet passo = 0.5;          // usuário pode alterar\nlet x0 = 0;      // domínios dinâmicos\nprint(passo, x0) \n\n// ... mais tarde:\npasso = 0.2; x0 = 30;\nprint(passo, x0)\n\n    Aparentemente, o resultado sugere que na prática nada muda, sendo a diferença mais centrada na clareza e segurança do código. Mas não é bem assim. Experimente agora trocar o campo pra executar o código abaixo:\n\nlet contador = 0;\ncontador += 1;\nprint(\"Contador:\", contador);\n\n  Agora substitua a variável do “contador” para const ao invés de let. O resultado incorrerá no erro abaixo:\n\n\n\n\n\n\n\n\nFigura 4.1: Erro gerado quando se substitui a variável let por const num trecho de reatribuição de valor.\n\n\n\n  Resumindo: para constantes, use const e para variável reatribuível use let.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Um pouco de estrutura JavaScript</span>"
    ]
  },
  {
    "objectID": "primeiros.html#tipos-de-dados",
    "href": "primeiros.html#tipos-de-dados",
    "title": "4  Um pouco de estrutura JavaScript",
    "section": "4.3 Tipos de dados",
    "text": "4.3 Tipos de dados\n  Como é comum para outras linguagens, JavaScript possui alguns tipos comuns para definição de dados. Para uso de Plotly.js, são bem significativos:\n\nNumber # número\nString # texto: representado entre aspas ( \" \" )\nBoolean # true/false (\"branching\")\nObject  # internos (built-in) ou externos (user-defined)\nBuilt-in # objects, arrays, dates, maps, etc\n\n  Seguem alguns exemplos práticos. Experimente trocar cada um na saída print:\n\n// Numbers:\nlet comprimento = 116;\nlet peso = 75;\n\n// Strings:\nlet color = \"Yellow\";\nlet lastName = \"Johnson\";\n\n// Booleans\nlet x = true;\nlet y = false;\n\n// Object:\nconst membro = {firstName:\"John\", lastName:\"Doe\"};\n\n// Array object:\nconst carros = [\"Saab\", \"Volvo\", \"BMW\"];\n\n// Date object:\n    const datas = new Date(\"2022-03-25\");\n\n// Saídas:\nprint(comprimento)",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Um pouco de estrutura JavaScript</span>"
    ]
  },
  {
    "objectID": "primeiros.html#constantes",
    "href": "primeiros.html#constantes",
    "title": "4  Um pouco de estrutura JavaScript",
    "section": "4.4 Constantes",
    "text": "4.4 Constantes\n  Por vezes é necessária a inserção de constantes matemáticas em equações para plotagem ou cálculos. Seguem alguns exemplos. Para a saída no JSPlotly customizado abaixo, basta o bom e velho print que segue ao também bom e velho clean.\n\nMath.PI - valor de (pi), aproximadamente 3.14159\nMath.E - valor da constante de Euler, aproximadamente 2.71828\nMath.LN2 - logaritmo natural de 2, aproximadamente 0.693\nMath.LN10 - logaritmo natural de 10, aproximadamente 2.302\nMath.LOG2E - logaritmo de e na base 2, aproximadamente 1.442\nMath.LOG10E - logaritmo de e na base 10, aproximadamente 0.434\nNumber.MAX_VALUE - maior número positivo\nNumber.MIN_VALUE - menor número positivo...\n\n\n  \n\n  Para constantes naturais, contudo, é necessário defini-las antecipadamente, como em:\n\n// Definindo constantes físico-químicas comuns\nconst Avogadro = 6.02214076e23;  // Número de Avogadro (mol⁻¹)\nconst Boltzmann = 1.380649e-23;  // Constante de Boltzmann (J/K)\nconst Planck = 6.62607015e-34;   // Constante de Planck (J·s)\nconst gas = 8.31446;    // Constante dos gases ideais (J/(mol·K))\nconst luz = 299792458; // Velocidade da luz no vácuo (m/s)",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Um pouco de estrutura JavaScript</span>"
    ]
  },
  {
    "objectID": "estruturaJS.html",
    "href": "estruturaJS.html",
    "title": "5  Mais estrutura",
    "section": "",
    "text": "5.1 Aritmética\nObs:  o operador de módulo % divide o primeiro operando pelo segundo operando e retorna o resto.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mais estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS.html#aritmética",
    "href": "estruturaJS.html#aritmética",
    "title": "5  Mais estrutura",
    "section": "",
    "text": "Diversas operações matemáticas são possíveis, quer pelo JavaScript puro, quer pela instalação de bibliotecas específicas, tais como mathjs ou numjs. Segue abaixo uma lista de operações aritméticas realizadas com a linguagem:\n\n+ : adição de números ou concatenação de texto (strings);\n- : subtração;\n* : multiplicação;\n/ : divisão;\n% : módulo;\n++ : incremento de valor;\n-- : decremento;\n** : exponenciação.\n\n\n  Os exemplos a seguir ilustram o uso desses operadores aritméticos, bem como de algumas constantes matemáticas. Para testá-los, cole no JSPlotly customizado, e que segue também abaixo. Você pode experimentá-los separadamente ou em bloco.\nlet resultado = 0;\n\nresultado = 5 + 3;                 print(\"5 + 3 = \", resultado);          // 8\nresultado = 10 - 4;                print(\"10 - 4 = \", resultado);          // 6\nresultado = 6 * 7;                 print(\"6 * 7 = \", resultado);           // 42\nresultado = 20 / 5;                print(\"20 / 5 = \", resultado);          // 4\nresultado = 17 % 3;                print(\"17 % 3 = \", resultado);          // 2\nresultado = 2 ** 3;                print(\"2 ** 3 = \", resultado);          // 8\nlet contador = 5; contador++;      print(\"contador++ = \", contador);       // 6\nlet decrementar = 8; decrementar--;print(\"decrementar-- = \", decrementar); // 7\nlet soma = 10; soma += 5;          print(\"soma += 5 = \", soma);            // 15\nlet diferenca = 20; diferenca -= 7;print(\"diferença -= 7 = \", diferenca);   // 13\nlet produto = 3; produto *= 4;     print(\"produto *= 4 = \", produto);       // 12\nlet quociente = 24; quociente /= 3;print(\"quociente /= 3 = \", quociente);   // 8\nresultado = Math.sqrt(25);         print(\"sqrt(25) = \", resultado);         // 5\nresultado = Math.abs(-15);         print(\"abs(-15) = \", resultado);         // 15\nresultado = Math.floor(7.8);       print(\"floor(7.8) = \", resultado);       // 7\nresultado = Math.ceil(7.2);        print(\"ceil(7.2) = \", resultado);        // 8\nresultado = Math.round(9.4);       print(\"round(9.4) = \", resultado);       // 9\nresultado = Math.max(42, 27);      print(\"max(42,27) = \", resultado);       // 42\nresultado = Math.min(42, 27);      print(\"min(42,27) = \", resultado);       // 27\nresultado = Math.sin(Math.PI/2);   print(\"sin(π/2) = \", resultado);",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mais estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS.html#arrays",
    "href": "estruturaJS.html#arrays",
    "title": "5  Mais estrutura",
    "section": "5.2 Arrays",
    "text": "5.2 Arrays\n  Um array em JavaScript representa uma estrutura de dados para armazenamento de elementos ordenados. Esses elementos podem envolver qualquer tipo de dado, como números, strings, objetos, etc. Na prática, um array pode ser criado, acessado, filtrado, ou mapeado. Seguem exemplos:\n\nCriação\nconst numeros = [1, 2, 3, 4, 5];\nconst cores = ['vermelho', 'verde', 'azul'];\n\n\nAcesso\nprint(numeros[0]);\nprint(cores[2]);\n\n\nMapeamento (map)\nconst numeros = [1, 2, 3, 4, 5];\nconst quadrados = numeros.map(numero =&gt; numero * numero);\nprint(quadrados);\n\n\n5.2.1 Uma palavrinha sobre métodos\n  Observe que, diferente do que já foi explicitado, agora aparece um comando múltiplo, como “numeros.map”. Existe uma infinidade de comandos com esta sintaxe em JS. Ele representa a função que será aplicada a cada elemento do array numeros pelo método map. Além disso, surge a sintaxe “=&gt;” ou sintaxe de arrow function (função de seta), uma forma concisa de atribuir um mapeamento. Assim, o comando inteiro:\n\n\nconst quadrados = numeros.map(numero =&gt; numero * numero)\n\n...traduz-se como...\n\n\"recebe um numero como parâmetro e retorna o seu quadrado (numero * numero)\"\n\n  Em JavaScript objetos são tratados como no mundo real, ou seja, possuem atributos e comportamentos. Atributos descrevem as características que um objeto possui, e os comportamentos as ações que podem realizar. A notação em JS para referenciar as propriedades de um objeto podem ser, alternativamente:\nobjeto.propriedade\n\n...ou...\n\nobjeto[propriedade]\n  Além disso, existe um número finito de objetos internos de JavaScript, explicitados abaixo. Note que esses objetos built-in começam sempre com letra maiúscula.\n1. String:  texto;\n2. Number: objeto criado para valores;\n3. Boolean: true/false;\n4. Object: objeto definido pelo usuário;\n5. Date: objeto contendo componentes de data e tempo;\n6. Array: objeto que armazena ítens indexados de dados;\n7. RegExp: objeto que descreve o padrão de uma expressão regular.;\n8. Math: objeto que define propriedades e métodos matemáticos;\n9. Error: objeto que informa detalhes sobre um erro.\n  Voltando ao exemplo acima e esmiuçando-o um pouquinho mais, o método map() é chamado no array numeros (um Array.prototype). O protótipo permite transmitir propriedades e métodos para um objeto JS. No caso, o método map() itera sobre cada elemento do array original, aplica uma função a cada um deles e retorna um novo array com os resultados. Assim, numero =&gt; numero  numero* é a função de seta. E nesse caso, numero é o parâmetro de entrada da função, um atalho para o elemento atual do array sendo processado pelo map. Em adição, “=&gt;” representa o separador entre o(s) parâmetro(s) e o corpo da função. Finalmente, “numero * numero” é a expressão que é executada, com o resultado sendo retornado pela função.\n\n\n  Seguem outros exemplos para arrays e mapeamento:\n\n\n const x = [0, 1, 2, 3, 4];\n const y = x.map(valor =&gt; Math.pow(2, valor))\n print(y);\nconst Vmax = 100;\nconst Km = 10;\nconst S_values = Array.from({length: 10}, (_, i) =&gt; i * 5);\n\nconst V_values = S_values.map(S =&gt; (Vmax * S) / (Km + S));\n\nprint(\"Valores de S:\", S_values);\nprint(\"Valores de V:\", V_values);\n\n\n\nFiltragem\nconst numeros = [1, 2, 3, 4, 5];\nconst pares = numeros.filter(numero =&gt; numero % 2 === 0);  // (`filter`)\nprint(pares);\n\nnumeros.forEach(numero =&gt; print(numero * 2));  // `forEach()`\n\n\n\n  \n\n\n\n\n5.2.2 Um pouco mais sobre sobre os métodos ilustrados acima\n  Com o mesmo raciocínio empregado, os métodos empregados acima podem ser traduzidos como:\n\n\n1.  const y = x.map(valor =&gt; Math.pow(2, valor))\n...\nCria um novo array y aplicando Array.prototype.map sobre x: para cada valor, usa Math.pow(base, expoente) para calcular 2^valor;\n\n2. const S_values = Array.from({length: 10}, (_, i) =&gt; i * 5);\n...\nUsa Array.from com o objeto { length: 10 } (propriedade length) e uma função mapeadora (_, i) para gerar 10 valores, cada um igual a índice multiplicado por 5 (× 5) → [0,5,10,...,45];\n\n3. const pares = numeros.filter(numero =&gt; numero % 2 === 0);  \n...\nAplica Array.prototype.filter a numeros e mantém apenas os itens cujo resto da divisão por 2 (%) é zero — ou seja, números pares.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mais estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS.html#javascript-uma-linguagem-orientada-a-objetos",
    "href": "estruturaJS.html#javascript-uma-linguagem-orientada-a-objetos",
    "title": "5  Mais estrutura",
    "section": "5.3 JavaScript, uma linguagem orientada a objetos",
    "text": "5.3 JavaScript, uma linguagem orientada a objetos\n  Ainda que o esforço para traduzir os comandos acima possa auxliar como funciona a linguagem, é por óbvio esperar uma certa confusão de termos. Sendo assim, vamos subindo de nível ….!\n  Como diz o título acima, JS é uma linguagem orientada a objetos. Isso significa que o código é organizado em torno de objetos, que combinam dados (propriedades) e comportamentos (métodos) para modelar entidades do mundo real. Isso permite um código mais modular, reutilizável e fácil de gerenciar, ao organizar a lógica em “partes” menores e mais compreensíveis (pensamento computacional).\n\n5.3.1 Objetos, propriedades, e métodos\n  Um objeto é uma estrutura que agrupa dados e comportamentos. Os dados ficam guardados em propriedades, e os comportamentos são implementados por métodos (funções dentro do objeto). Assim, propriedade são pares nome–valor armazenados dentro de um objeto, podendo variar como números, textos, arrays, e outros objetos. Já os métodos são funções associadas a um objeto, e que descrevem ações que ele pode executar.\n  Objetos em JS “podem ser comparados a objetos da vida real”, e guardam informações relacionadas entre si. Por exemplo, o objeto “ponto” abaixo representa um ponto no plano:\n\nconst ponto = { x: 2, y: 5 };  // objeto com duas propriedades\n\n\n\n  Assim, as propriedades são as características do objeto:\n\nprint(ponto.x);  // mostra 2\nprint(ponto.y);  // mostra 5\n\n  “Propriedades de objetos são basicamente as mesmas que variáveis normais em JavaScript, exceto pelo fato de estarem ligadas a objetos”. Propriedades podem ser acessadas por colchetes, […].\n  Assim, um objeto pode ser encarado como um “pacote” contendo nome, conteúdo e ferramentas próprias. Virtualmente, tudo em JavaScript — arrays, funções, strings, números — é, de alguma forma, um objeto com suas propriedades e métodos. Segue um exemplo:\n\n\nconst carro = {\n  marca: \"Toyota\",        // propriedade (dado)\n  ano: 2022,              // propriedade\n  ligar: function() {     // método (ação)\n    console.log(\"O carro está ligado!\");\n  }\n};\n\ncarro.ligar();            // chama o método\nconsole.log(carro.marca); // acessa a propriedade\n\n\n  A tabela abaixo interpreta o exemplo “automobilístico”:\n\n\n\n\nTabela 5.1: Objetos, propriedades e métodos (JS)\n\n\n\n\n\n\n\n\n\n\n\nConceito\nO que é\nExemplo\n\n\n\n\nObjeto\nColeção de propriedades e métodos\n{marca:“Toyota”, ligar(){}}\n\n\nPropriedade\nDado do objeto\ncarro.marca\n\n\nMétodo\nFunção que o objeto pode executar\ncarro.ligar()\n\n\n\n\n\n\n\n\n\n\n  Reforçando (não custa nada…), um objeto JavaScript envolve uma coleção de propriedades, onde cada propriedade é definida por um par chave-valor, permitindo uma representação ordenada de elementos. Objetos podem conter diferentes tipos de dados como valores, como números, strings, booleanos, arrays, outras funções e até mesmo outros objetos. Objetos criados são facilmente acessados por seus atributos. Seguem exemplos e JSPlotly customizado para testes.\n\n5.3.1.1 Criação\n\nconst pessoa = {\n    nome: 'João',\n    idade: 30,\n    cidade: 'São Paulo'\n};\n\n\n\n5.3.1.2 Acesso\n\nprint(pessoa.nome);\nprint(pessoa['idade']);\n\n\n\n5.3.1.3 Atributos\n\npessoa.profissao = 'Engenheiro';\nprint(pessoa);\n\n  Para um exemplo fechado de objetos:\nlet pessoa = {\n  nome: \"João\",\n  idade: 30,\n  profissao: \"Desenvolvedor\",\n  hobbies: [\"leitura\", \"música\", \"jogos\"],\n  endereco: {\n    rua: \"Rua Principal, 123\",\n    cidade: \"São Paulo\",\n  },\n  saudacao: function () {\n    print(\"Olá, meu nome é \" + this.nome);\n  },\n};\n\nprint(pessoa.nome); // Saída: \"João\"\nprint(pessoa.hobbies[0]); // Saída: \"leitura\"\npessoa.saudacao(); // Saída: \"Olá, meu nome é João\"\n\n\n\n  \n\n\n\n\n5.3.2 E dá-lhe código padrão !!!\n  Nesse sentido, nosso bom e velho código padrão do JSPlotly também apresenta objetos, propriedades e métodos. Veja o aplicativo vivo e compare seus códigos com o chunk que segue:\n\n\n\n  \n\n\n\n// Objeto: Quadratica (propriedades a,b,c e metodos y(x), gerarDados)\nconst Quadratica = {\n  a: -0.2,\n  b: 2.5,\n  c: 0.5,\n  y(x){ return this.a*x*x + this.b*x + this.c; },     // metodo\n  gerarDados(xmax=20, passo=0.5){                      // metodo\n    const x = [], y = [];\n    for(let i=0; i&lt;=xmax; i+=passo){ x.push(i); y.push(this.y(i)); }\n    return { x, y };\n  }\n};\n\n// Usa os metodos do objeto para produzir os dados do grafico\nconst { x, y } = Quadratica.gerarDados(20, 0.5);\n\n// Propriedades do \"modelo de gráfico\" que o JSPlotly espera\nconst x_range = [0, 15];\nconst y_range = [0, Math.max(...y)];\nconst x_label = \"Valores de X\";\nconst y_label = \"Valores de Y\";\nconst title   = \"Funcao Quadratica\";\n\n// Retorno padrão do codigo\nreturn { x_values: x, y_values: y, x_range, y_range, x_label, y_label, title };",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mais estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS2.html",
    "href": "estruturaJS2.html",
    "title": "6  Só mais um poquinho de…estrutura",
    "section": "",
    "text": "6.1 Variáveis…mais um pouco",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Só mais um poquinho de...estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS2.html#variáveismais-um-pouco",
    "href": "estruturaJS2.html#variáveismais-um-pouco",
    "title": "6  Só mais um poquinho de…estrutura",
    "section": "",
    "text": "Dependendo da extensão de um código de programação (e isso não é só pra JS), é interessante definir o escopo de uma variável para atuar somente dentro de uma função (variável local), ao invés de atuar no código como um todo (variável global). De modo geral, um código mais extenso de de programação é estruturado em módulos, cada qual com um conjunto de funções e suas variáveis locais. Isso facilita a interpretação do código e evita erros advindos da interpretação de uma variável que deveria possuir atuação restrita a um bloco (local), mas que encontra-se disponível ao código todo (global).\n  Por outro lado, também é frequente o uso de uma variável global quando se deseja que o código responda a um incremento de índice; algo como “vá somando o índice”i” e rodando todo o código até atingir o valor “x”. Nesse caso, é interessante utilizar-se uma função aninhada (“nested function”) denominada closure (função de fechamento). Essa função é identificada no código pela sintaxe abaixo:\n\nconst nome.funcao = (function () {\n// instruções\n}) ()\n\n  O exemplo a seguir ilustra o emprego da função aninhada de fechamento direto no JSPlotly, e que pode ser testada no aplicativo na sequência.\n\nconst nome = {};\nnome.funcao = (function () {\n  let n = 0;            // estado privado\n  return function () {  // função interna captura \"n\"\n    n++;\n    return n;\n  };\n})();\n\n// Duas chamadas: resultado cresce por causa do estado privado\nconst y = [nome.funcao(), nome.funcao()];  // [1, 2]\n\n// Plotzinho só para ver o efeito\nPlotly.newPlot(\"grafico\", [{ x:[1,2], y, mode:\"markers\", name:\"closure\" }],\n               { title:\"Closure mínimo\" });",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Só mais um poquinho de...estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS2.html#funções",
    "href": "estruturaJS2.html#funções",
    "title": "6  Só mais um poquinho de…estrutura",
    "section": "6.2 Funções",
    "text": "6.2 Funções\n  Funções constituem um bloco de códigos para efetuar alguma ação. Em JavaScript uma função possui a seguinte sintaxe:\nfunction nome(parâmetro1, parâmetro2, parâmetro3) {\n  // código para execução\n}\n  Seguem alguns exemplos de funções. O JSPlotly personalizado segue na sequência para testes.\nfunction soma(a) { // define o nome e os \"parâmetros\" da função\n return a + a // define os argumentos da função (no caso, a*a),\n            // pra retorna dos valores\n}\n\n// Teste\nlet x = soma(7); // aplica parâmetros\nprint(x) // saída da função\n\n\nObs:  O comando return, por vezes omitido, faz-se útil quando se deseja que o “retorno” seja concluído somente ao final do fluxo do script, sem resultados intermediários.\n\nfunction expoente(a, b) { // define o nome e os \"parâmetros\" da função\n  return a ** b;  // define os argumentos da função (no caso, a^b),\n                  // pra retorna dos valores\n}\n\n// Teste da função\nlet x = expoente(4, 3); // aplica parâmetros\nprint(x);         // saída da função\n\n\nfunction indexa(vetor){\n return vetor + 1\n}\n\nvar vetor = [1, 2, 3, 4, 5];\nprint(indexa(vetor))\n\n\nfunction Celsius(Fahrenheit) {\n  return (5/9) * (Fahrenheit-32);\n}\n\nlet conversao = Celsius(115);\nprint(conversao)\n\n\n\n6.2.0.1 Funções de seta (arrow functions)\n  Como visto anteriormente, uma notação alternativa é a função arrow, que abrevia a sintaxe de funções. Segue um exemplo:\nconst multiplica = (a, b) =&gt; a * b;\nprint(multiplica(4, 6));\n  Use o JSPlotly abaixo para testar os chunks (trechos de código) acima.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Só mais um poquinho de...estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS2.html#geração-de-números-aleatórios",
    "href": "estruturaJS2.html#geração-de-números-aleatórios",
    "title": "6  Só mais um poquinho de…estrutura",
    "section": "6.3 Geração de números aleatórios",
    "text": "6.3 Geração de números aleatórios\n  Números aleatórios são fundamentais quando se deseja que um resultado dependa de um valor escolhido ao acaso, ou quando se deseja aplicar uma função matemática com variação randômica, por exemplo. Pode-se gerar números aleatórios a partir de zero, a um máximo, ou entre limites. Na verdade, a função Math.random da linguagem JS gera números pseudoaleatórios por um algoritmo determinístico. Seguem exemplos, seguido da moldura para testes no JSPlotly.\n// Número entre 0 e 1\n\nlet numeroAleatorio = Math.random();\nprint(numeroAleatorio);\n// Número entre 0 e um valor máximo:\n\nfunction getRandomInt(max) {\n  return Math.floor(Math.random() * max);\n}\n\nprint(getRandomInt(10)); // Gera um número entre 0 e 9\n// Entre um valor mínimo e um máximo\n\nfunction getRandomIntInclusive(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nprint(getRandomIntInclusive(1, 10)); // Gera um número entre 1 e 10",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Só mais um poquinho de...estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS2.html#operadores-de-atribuição",
    "href": "estruturaJS2.html#operadores-de-atribuição",
    "title": "6  Só mais um poquinho de…estrutura",
    "section": "6.4 Operadores de atribuição",
    "text": "6.4 Operadores de atribuição\n  Bastante comuns em linguagens de programação, um operador de atribuição (assignment operator) permite a execução do fluxo do algoritmo por atribuição de valores, ou por premissa satisfeita à comparações. São frequentemente utilizados junto a estruturas de controle, discutidas no próximo capítulo. Em JavaScript os operadores mais comuns são dados abaixo.\n1. = : a = b --&gt; ex: a = b;\n2. += : a+- b --&gt; ex: a = (a + b);\n3. -= : a-= b --&gt; ex: a = (a - b);\n4. *= : a*= b --&gt; ex: a = (a * b);\n5. /= : a/= b --&gt; ex: a = (a / b);\n6. %= : a%= b --&gt; ex: a = (a % b);\n7. **= : a **= b --&gt; ex: a = (a ** b)\n  Seguem exemplos e aplicativo personalizado para testes logo depois:\n## Objetos\n=  # ex: x = y\n+= # ex: x += y; x = x +y - outros operadores (-, /, *, **, %)\n  \n  Ilustrando:\n\n// =  (atribui)\nlet x = 5, y = 2;\nx = y;           // x = 2\n\n// +=  (soma e atribui) — idem para -=, *=, /=, **=, %=\nx = 5; y = 2;\nx += y;          // x = 7   (5 + 2)\n\nx = 5; y = 2;\nx -= y;          // x = 3\n\nx = 5; y = 2;\nx *= y;          // x = 10\n\nx = 5; y = 2;\nx /= y;          // x = 2.5\n\nx = 5; y = 2;\nx **= y;         // x = 25  (5^2)\n\nx = 5; y = 2;\nx %= y;          // x = 1   (resto de 5/2)\n\n\n## Bitwise (bit a bit)\n\n&= # ex: x &= ; x = x & y\n&= # ex: x &= y     x = x & y\n^= # ex: x ^= y     x = x ^ y\n\n    Ilustrando:\n\n// vamos usar binário para visualizar: 13 = 0b1101, 11 = 0b1011\nlet x = 13, y = 11;\n\nx &= y;          // 1101 & 1011 = 1001  =&gt; x = 9\n// (recomeçando)\nx = 13; x |= y;  // 1101 | 1011 = 1111  =&gt; x = 15\nx = 13; x ^= y;  // 1101 ^ 1011 = 0110  =&gt; x = 6\n\nx = 13; x &lt;&lt;= 1; // 1101 &lt;&lt; 1  = 11010 =&gt; x = 26\nx = 13; x &gt;&gt;= 1; // 1101 &gt;&gt; 1  = 0110  =&gt; x = 6\nx = 13; x &gt;&gt;&gt;=1; // 1101 &gt;&gt;&gt; 1 = 0110  =&gt; x = 6  (difere de &gt;&gt; só p/ negativos)\n\n\n## Lógicos (curto-circuito com atribuição)\n\n\n&&=  # ex:  x &&= y     x = x && (x = y) - AND\n||=  # ex: x ||= y  x = x || (x = y) - OR\n\n...Ou ainda...\n\nEquivalências corretas:\nx ||= y ≈ if (!x) x = y; (atribui só se x for falso)\nx &&= y ≈ if (x) x = y; (atribui só se x for verdadeiro)\n\n    Ilustrando:\n\n// ||=  (OR lógico com atribuição)\nlet x = 0, y = 5;\nx ||= y;         // 0 é falso → x = 5\n\nx = 3; y = 0;\nx ||= y;         // 3 é verdadeiro → x continua 3\n\nx = \"\"; y = \"ok\";\nx ||= y;         // string vazia é falso → x = \"ok\"\n\n// &&=  (AND lógico com atribuição)\nx = 7; y = 9;\nx &&= y;         // 7 é verdadeiro → x = 9\n\nx = 0; y = 9;\nx &&= y;         // 0 é falso → x continua 0",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Só mais um poquinho de...estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS2.html#operadores-de-comparação",
    "href": "estruturaJS2.html#operadores-de-comparação",
    "title": "6  Só mais um poquinho de…estrutura",
    "section": "6.5 Operadores de comparação",
    "text": "6.5 Operadores de comparação\n  No mesmo caminho, JS, assim como outras linguagens, também conta com operadores de comparação, como segue.\n\n=== : igualdade;\n!== : inequalidade;\n&gt;   : maior que;\n&lt;   : menor que;\n&gt;=  : maior ou igual que;\n&lt;=  : menor ou igual que\n\n\n  Como dantes, alguns exemplos pra colar no JSPlotly adaptado na sequência.\n// Valores de teste\nconst a = 2;\nconst b = 2;\nconst c = \"2\";   // string\n\n// === (igualdade estrita: mesmo valor e **mesmo tipo**)\nprint(a === b); // true   (2 e 2, ambos number)\nprint(a === c); // false  (2 number vs \"2\" string)\n\n// !== (desigualdade estrita)\nprint(a !== b); // false  (são iguais e do mesmo tipo)\nprint(a !== c); // true   (valores \"iguais\" mas tipos diferentes)\n\n// &gt; (maior que) / &lt; (menor que) / &gt;= (maior ou igual) / &lt;= (menor ou igual)\nconst x = 5, y = 8;\n\nprint(x &gt; y);   // false\nprint(x &lt; y);   // true\nprint(x &gt;= 5);  // true\nprint(y &lt;= 8);  // true\n\n// Observação com strings: comparação é lexicográfica (ordem alfabética)\nprint(\"apple\" &lt; \"banana\"); // true\nprint(\"2\" &gt; \"15\");         // true  (\"2\" vem depois de \"1\" como texto)\nprint(Number(\"2\") &gt; Number(\"15\")); // false (2 &gt; 15 é falso como número)",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Só mais um poquinho de...estrutura</span>"
    ]
  },
  {
    "objectID": "estruturaJS2.html#operadores-lógicos",
    "href": "estruturaJS2.html#operadores-lógicos",
    "title": "6  Só mais um poquinho de…estrutura",
    "section": "6.6 Operadores lógicos",
    "text": "6.6 Operadores lógicos\n  Também da “lógica” de qualquer linguagem, esses operadores atuam em lógica booleana, de verdadeiro ou falso.\n1. && : E (\"AND\");\n2. || : OU (\"OR\");\n3. !  : NÃO (\"NOT\")\n  Seguem exemplos or JSPlotly de treino logo em seguida.\n// Valores básicos\nconst T = true, F = false;\n\n// &&  (AND) — só dá true se ambos forem true\nprint(T && T); // true\nprint(T && F); // false\nprint(F && T); // false\nprint(F && F); // false\n\n// ||  (OR) — dá true se pelo menos um for true\nprint(T || T); // true\nprint(T || F); // true\nprint(F || T); // true\nprint(F || F); // false\n\n\n// !  (NOT) — inverte o valor lógico\nprint(!true);  // false\nprint(!false); // true\n\n// \"!!\" força conversão para boolean (verdadeiro/falso)\nprint(!!\"ok\"); // true   (string não vazia é verdadeiro)\nprint(!!\"\");   // false  (string vazia é falso)\nprint(!!0);    // false  (0 é falso)\nprint(!!42);   // true   (número != 0 é verdadeiro)\n\n\nlet chamadas = 0;\nfunction conta(){ chamadas++; return true; }\n\n// AND: se o primeiro for false, o segundo não roda\nchamadas = 0;\nconst r1 = false && conta();\nprint(r1, chamadas); // false 0\n\n// OR: se o primeiro for true, o segundo não roda\nchamadas = 0;\nconst r2 = true || conta();\nprint(r2, chamadas); // true 0",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Só mais um poquinho de...estrutura</span>"
    ]
  },
  {
    "objectID": "estrutControle.html",
    "href": "estrutControle.html",
    "title": "7  Estruturas de controle",
    "section": "",
    "text": "7.1 Estruturas condicionais",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estruturas de controle</span>"
    ]
  },
  {
    "objectID": "estrutControle.html#estruturas-condicionais",
    "href": "estrutControle.html#estruturas-condicionais",
    "title": "7  Estruturas de controle",
    "section": "",
    "text": "Para as estruturas condicionais, seguem alguns exemplos.\n\n7.1.1 IF\n  A sintaxe de declaração dessa função é:\nif (condição) execute isto quando verdadeiro\n\n\n  Seguem exemplos pra testes logo abaixo do 1o.\n\n// if\nlet idade = 18;\nif (idade &gt;= 18) {\nprint(\"Você é maior de idade.\");\n}\n// saída: Você é maior de idade.\n\n\n\n  \n\n\n\n\n\n7.1.2 ELSE\n  A sintaxe de declaração dessa função é:\nif (condição) { execute isso quando verdadeiro\n}\n  else {quando falso, execute essa alternativa\n}\n\n\n// else\n\nlet idade = 15;\nif (idade &gt;= 18) {\n  print(\"Você é maior de idade.\");\n} else {\n  print(\"Você é menor de idade.\");\n}\n\n// saída: Você é menor de idade.\n\n\n\n\n7.1.3 ELSE IF\n  A sintaxe de declaração dessa função permite ramificação múltipla (branching):\nse (condição) {\n  execute isso quando verdadeiro\n}\nelse if (condição) {\n  execute isso quando veradeiro\n}\nelse if (condição) {\n  execute isso quando verdadeiro\n}\nelse {\n  execute isso quando falso\n}\n\n\n\n// else if\nlet nota = 75;\nif (nota &gt;= 90) {\n  print(\"A\");\n} else if (nota &gt;= 80) {\n  print(\"B\");\n} else if (nota &gt;= 70) {\n  print(\"C\");\n} else {\n  print(\"D\");\n}\n\n// saída: C\n\n\n\n\n7.1.4 SWITCH\n  A sintaxe de declaração dessa função também permite branching múltiplo.\nswitch (expressão) {\n   case 1: execute isso quando se adequar; break\n   case 2: execute isso quando se adequar; break\n   case 3: execute isso quando se adequar; break\n   default: execute isso quando não houver adequação\n   }\n\n\n\n// switch\n\nlet dia = \"segunda\";\nswitch (dia) {\n  case \"segunda\":\n    print(\"Dia de trabalho.\");\n    break;\n  case \"sábado\":\n    print(\"Dia de descanso.\");\n    break;\n  default:\n    print(\"Dia comum.\");\n}\n\n// saída: Dia de trabalho.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estruturas de controle</span>"
    ]
  },
  {
    "objectID": "estrutControle.html#estruturas-de-repetição",
    "href": "estrutControle.html#estruturas-de-repetição",
    "title": "7  Estruturas de controle",
    "section": "7.2 Estruturas de repetição",
    "text": "7.2 Estruturas de repetição\n  Seguem alguns exemplos para as estruturas de repetição em JavaScript.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estruturas de controle</span>"
    ]
  },
  {
    "objectID": "estrutControle.html#for",
    "href": "estrutControle.html#for",
    "title": "7  Estruturas de controle",
    "section": "7.3 FOR",
    "text": "7.3 FOR\n  A sintaxe de declaração dessa função é:\nfor (inicializador; condição; modificador) {\n  execute isso\n}\n\n\n// for\n\nfor (let i = 0; i &lt; 5; i++) {\n  print(i);\n}\n\n// saída:\n// 0\n// 1\n// 2\n// 3\n// 4\n\n\n\n  \n\n\n\n\n7.3.0.1 FOR…IN\n// for...in\n\nlet pessoa = { nome: \"João\", idade: 30 };\nfor (let propriedade in pessoa) {\n  print(propriedade + \": \" + pessoa[propriedade]);\n}\n\n// saída:\n// nome: João\n// idade: 30\n\n\n\n\n7.3.0.2 FOR…OF\n// for...of\n\nlet numeros = [1, 2, 3];\nfor (let numero of numeros) {\n  print(numero);\n}\n\n// saída:\n// 1\n// 2\n// 3\n\n\n\n\n7.3.1 WHILE\n  A sintaxe de declaração dessa função é:\nwhile (condição) {\n  execute isso\n  modificador\n}\n\n\n// while\n\nlet contador = 0;\nwhile (contador &lt; 3) {\n  print(contador);\n  contador++;\n}\n\n// saída:\n// 0\n// 1\n// 2\n\n\n\n\n7.3.2 DO…WHILE\n  A sintaxe de declaração dessa função é:\ndo {\n  execute isso\n  modificador\n}\nwhile (condição)\n\n\n// do...while\n\nlet i = 0;\ndo {\n    print(i);\n    i++;\n} while (i &lt; 5);\n\n// saída:\n// 0\n// 1\n// 2\n// 3\n// 4",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estruturas de controle</span>"
    ]
  },
  {
    "objectID": "estrutContrJSPlotly.html",
    "href": "estrutContrJSPlotly.html",
    "title": "8  Aplicando estruturas de controle no JSPlotly",
    "section": "",
    "text": "8.1 Estruturas condicionais no JSPlotly",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Aplicando estruturas de controle no JSPlotly</span>"
    ]
  },
  {
    "objectID": "estrutContrJSPlotly.html#estruturas-condicionais-no-jsplotly",
    "href": "estrutContrJSPlotly.html#estruturas-condicionais-no-jsplotly",
    "title": "8  Aplicando estruturas de controle no JSPlotly",
    "section": "",
    "text": "Para as estruturas condicionais, seguem alguns exemplos.\n\n8.1.1 IF\n\n// IF\n\nconst x = [0, 1, 2];         // experimente tirar um ponto e ver o resultado\nconst y = [0, 2, 4];\n\nlet mode = \"lines+markers\";\nif (x.length &lt; 3) {       // condição\n  mode = \"markers\";       // ação se verdadeiro\n}\n\nPlotly.newPlot(\"grafico\", [{ x, y, mode, name: \"dados\" }], { title: \"if: linhas só com &gt;= 3 pontos\" });\n\n\n\n  Nesse exemplo, desenha linhas apenas se houver pontos suficientes; caso contrário, só marcadores. Teste no JSPlotly vivo que segue, delete(ando) o código padrão e o substituindo pelo acima.\n\n  \n\n\n\n  Observe que, se retirar qualquer ponto, o traço do gráfico se converterá para pontos, apenas (marker).\n\n\n8.1.2 IF…ELSE\n\nconst x = Array.from({length: 21}, (_, i) =&gt; i);\nconst y = x.map(v =&gt; v*v*0.1); // cresce\n\nconst maxY = Math.max(...y);\nlet layout = { title: \"if/else: trava o eixo se y for grande\" };\n\nif (maxY &gt; 15) {\n  layout.yaxis = { range: [0, 15] };   // verdadeiro → trava\n} else {\n  layout.yaxis = { autorange: true };  // falso → auto\n}\n\nPlotly.newPlot(\"grafico\", [{ x, y, mode: \"lines\" }], layout);\n\n\n  Nesse outro exemplo, se a máxima de y ultrapassar o limite, o código fixa o range do eixo; senão, deixa como auto. Experimente mudar o valor de 15 do eixo para valores menores, e verá que o eixo y não ultrapassa 15. Por outro lado, experimente colocar um teto de 150 em maxY, e perceberá que o eixo agora ajusta-se automaticamente.\n\n\n8.1.3 ELSE IF\nconst x = [0, 1, 2, 3];\nconst y = [2, 2.1, 2.2, 2.3]; // quase horizontal → slope ~ 0\n\n// estimativa simples da inclinação final\nconst slope = (y[y.length-1] - y[0]) / (x[x.length-1] - x[0]);\n\nlet color, titulo;\nif (slope &gt; 0.05) {\n  color = \"green\"; titulo = \"Crescente\";\n} else if (slope &lt; -0.05) {\n  color = \"red\";   titulo = \"Decrescente\";\n} else {\n  color = \"orange\"; titulo = \"Quase constante\";\n}\n\nPlotly.newPlot(\"grafico\", [{\n  x, y, mode: \"lines+markers\",\n  line: { color }, marker: { color }\n}], { title: `else if: tendência ${titulo}` });\n  Aqui a cor do traço dependerá da inclinação média dos pontos (const slope), incidindo também no título do gráfico. Para obter inclinações que correpondam às 3 situações do código, basta variar para valores significativos negativos (descendente), positivos (ascendente) ou muito próximos (quase constante).\n\n\n8.1.4 SWITCH\nconst tipo = \"barras\";  // troque entre \"dispersao\", \"barras\", \"box\"\n\nlet data, layout = { title: `switch: tipo = ${tipo}` };\n\nswitch (tipo) {\n  case \"dispersao\":\n    data = [{ x: [0,1,2,3], y: [1,4,9,16], mode: \"markers\", name: \"pontos\" }];\n    break;\n  case \"barras\":\n    data = [{ x: [\"A\",\"B\",\"C\"], y: [5, 3, 7], type: \"bar\", name: \"contagens\" }];\n    break;\n  case \"box\":\n    data = [{ y: [1,2,2,3,10], type: \"box\", name: \"distribuição\" }];\n    break;\n  default:\n    data = [{ x: [0,1], y: [0,1], mode: \"lines\", name: \"fallback\" }];\n}\n\nPlotly.newPlot(\"grafico\", data, layout);\n\n\n  Aqui o gráfico é gerado por opções introduzidas na constante tipo do código, perfazendo barras, dispersão ou box-plot.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Aplicando estruturas de controle no JSPlotly</span>"
    ]
  },
  {
    "objectID": "estrutContrJSPlotly.html#estrutura-de-repetição",
    "href": "estrutContrJSPlotly.html#estrutura-de-repetição",
    "title": "8  Aplicando estruturas de controle no JSPlotly",
    "section": "8.2 Estrutura de repetição",
    "text": "8.2 Estrutura de repetição\n\n8.2.1 FOR\nconst x = [], y = [];\nfor(let i=0; i&lt;=20; i++){\n  x.push(i);\n  y.push(i*i);\n}\nPlotly.newPlot(\"grafico\", [{x, y, mode:\"lines+markers\", name:\"y = x^2\"}],\n               {title:\"for (basico)\"} );\n\n\n  No exemplo é solicitado que o código gere pontos no intervalo de x entre 0 e 20, aplicando-se a função y=x^2 (“qualquer semelhança é mera coincidência”).\n\n  \n\n\n\n\n8.2.1.1 FOR…IN\n\nconst base = [1,2,3,4,5];\nconst x = [...base];\nconst y = new Array(base.length);\n\nfor (const i in base){              // i são indices: \"0\",\"1\",\"2\"...\n  y[i] = base[i] * 10;\n}\nPlotly.newPlot(\"grafico\", [{x, y, type:\"bar\", name:\"base*10\"}],\n               {title:\"for...in (indices)\"} );\n\n  O exemplo itera sobre indices (chaves) do array e multiplica os valores.\n\n\n8.2.1.2 FOR…OF\n\nconst x = Array.from({length: 21}, (_, i) =&gt; i);  // 0..20\nconst y = [];\nfor (const v of x){            // v sao os valores de x\n  y.push(0.5*v + 1);\n}\nPlotly.newPlot(\"grafico\", [{x, y, mode:\"lines\", name:\"y = 0.5x + 1\"}],\n               {title:\"for...of (valores)\"} );\n  Aqui o exemplo percorre valores e calcula “y = 0.5*x + 1”.\n\n\n\n8.2.2 WHILE\n\nconst x = [], y = [];\nlet i = 0, soma = 0;\nwhile (soma &lt; 50){\n  x.push(i);\n  soma += i;     // acumulando\n  y.push(soma);\n  i++;\n}\nPlotly.newPlot(\"grafico\", [{x, y, mode:\"lines+markers\", name:\"acumulo\"}],\n               {title:\"while (acumulo ate limite)\"} );\n  Já nesse exemplo, o código permite uma soma cumulativa ate atingir o limite (ex.: cresce até y &gt;= 50).\n\n\n8.2.3 DO…WHILE\n\nconst passos = 20;\nconst x = [], y = [];\nlet i = 0, pos = 0;\ndo {\n  x.push(i);\n  // passo aleatorio: -1, 0 ou +1\n  pos += Math.sign(Math.random() - 0.5);\n  y.push(pos);\n  i++;\n} while (i &lt;= passos);\n\nPlotly.newPlot(\"grafico\", [{x, y, mode:\"lines+markers\", name:\"random walk\"}],\n               {title:\"do...while (pelo menos uma vez)\"} );\n  Neste último exemplo para laços de repetição, o código garante pelo menos uma iteracão.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Aplicando estruturas de controle no JSPlotly</span>"
    ]
  },
  {
    "objectID": "json_dom.html",
    "href": "json_dom.html",
    "title": "9  JSON & DOM",
    "section": "",
    "text": "9.1 JSON",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>JSON & DOM</span>"
    ]
  },
  {
    "objectID": "json_dom.html#json",
    "href": "json_dom.html#json",
    "title": "9  JSON & DOM",
    "section": "",
    "text": "JSON é um acrônimo para JavaScript Object Notation, um formato de texto popular utilizado no armazenamento e troca de dados. Por essa notação, um subconjunto da linguagem JS, os dados são armazenados por listas separadas por vírgulas e contendo o par chave:valor dentro de um objeto JSON.\n  Essa notação também é parecida com XML (eXtensible Markup Language) utilizada para a web, embora JSON tenha a vantagem de extração direta de dados para uma string de fácil leitura. Para tanto, utiliza-se o método JSON.parse(). Na mesma linha, converte-se um objeto JavaScript para um objeto JSON pelo método JSON.stringfy().\n  As características gerais da notação JSON envolvem:\n\n1. Objetos: conjunto de pares chave-valor delimitados por chaves; ex: {tipo:carro, marca: fiat, cor:verde};\n2. Arrays: lista ordenada de valores delimitada por colchetes; ex:\n3. Tipos de dados: strings, números, booleans (true, false);\n4. Separadores: vírgulas para separar para chave-valor;\n5. Null: sem definição\n\n  Dessa forma, a notação JSON apresenta-se leve, facilmente interpretável tanto por humanos como por máquinas, e compatível com outras linguagens de programação (Java, Python). Além disso, alicerça a construção de APIs (Application Programming Interface), a interface de aplicativos frequentemente utlizada para a comunicação entre o front-end (cliente, interativo) e o back-end (servidor, processamento) de aplicações web.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>JSON & DOM</span>"
    ]
  },
  {
    "objectID": "json_dom.html#dom",
    "href": "json_dom.html#dom",
    "title": "9  JSON & DOM",
    "section": "9.2 DOM",
    "text": "9.2 DOM\n  Também um acrônimo, refere-se a Document Object Model, um formato ramificado em árvore para níveis e subníveis, e que constitui o modo como as páginas web representam todos os seus elementos. Exemplificando, para o ramo window, cabem document, location, history, screen, frames, navigator.\n  E dentro do ramo window, inserem-se forms, achors, images, links. Dessa forma produz-se uma lista com todas as propriedades de exibição para um objeto construido para um browser, muitas vezes às centenas. Ilustrando-se, propriedades para scrolling de páginas, janelas pop-up, timer, plugins de navegação, location e history de cada objeto.",
    "crumbs": [
      "Parte 1 - JavaScript",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>JSON & DOM</span>"
    ]
  }
]