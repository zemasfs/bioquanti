[
  {
    "objectID": "introducao.html",
    "href": "introducao.html",
    "title": "Introdução",
    "section": "",
    "text": "O software de programação estatística R e sua interface gráfica (GUI) Rstudio encerram um ambiente de desenvolvimento integrado (IDE) de emprego virtualmente ilimitado para diversas áreas do conhecimento. Dentre essas, as Ciências da Natureza e, em especial, a Bioquímica, Biologia Molecular, Biofísica, e áreas afins.\n      São muitas as características que possibilitam o uso do R & RStudio para o ensino e aprendizagem em Bioquímica. Parte dessas características residem na Pesquisa Reproduzível (Gandrud 2018), o qual é resumidamente norteada pela:\n\nDisponibilização dos dados originais;\nExistência de um código para processar esses dados e analisá-los;\nDocumentação dos dados e do código, possibilitando sua reprodutibilidade;\nDistribuição e acessibilidade do código.\n\n      Nesse sentido, a produção de textos, tabelas, gráficos, análise de dados e simulações, podem perfeitamente ajustar-se ao ensino-aprendizagem pelo uso de tais princípios e da simultaneidade de texto e códigos, tangenciando um Ensino Reproduzível. Tal abordagem permite ao leitor o estudo dos diversos temas tratados por leitura e interpretação, como também de sua apropriação mais convergente, pela execução, modificação, e criação de códigos pertinentes em cada tema. Na presente obra, essas concepções são aplicadas ao conteúdo quantitativo e às relações matemáticas dos temas abordados em Bioquímica.\n      Essas relações estão presentes nos livros-texto de Bioquímica e abrangem, por exemplo, curvas de titulação de ácidos fracos e aminoácidos, estudo de cargas efetivas em biomoléculas, características físico-químicas de proteínas e ácidos nucleicos previstas por análise de sequência, cinética de enzimas e sua inibição, quantidades termodinâmicas e Bioenergética, interação ligante-biopolímero, estequiometria de reações bioquímicas, rotas bioquímicas e redes metabólicas, dentre outros.\n      De modo geral, os temas acima são abordados neste material com auxílio do R & RStudio. Não obstante, seu conteúdo não possui a pretensão de abordar, para além da superfície, o uso do R, do RStudio, e mesmo dos temas de Bioquímica propostos. Para esses, recomenda-se as fontes tradicionais de tutoriais, livros-texto e internete. E tampouco se arrisca a adentrar no universo da Bioinformática, tradicional ou estrutural, como na Biologia de Sistemas, alinhamento de sequências, predição estrutural, modelagem, dinâmica e atracamento moleculares, ou nas várias faces dos estudos ômicos.\n      Em resumo, objetiva-se apenas abordar os conteúdos quantitativos e relações matemáticas presentes em parte da Bioquímica, tal como descrito acima, utilizando o R & Rstudio. Essa abordagem tangencia a solução de problemas e simulações por sistema linear de equações, álgebra linear, ajuste linear, não linear, polinomial, linear múltiplo, otimização, minimização, equações diferenciais simples, e análise de sequências, dentre outros.\n      Secundariamente, objetiva-se permitir que o leitor possa, a partir da repetição ou modificação de trechos simples de códigos e de scripts, reproduzir cálculos, gráficos e/ou tabelas pertinentes aos conteúdos elencados.\n\n\n\n\nGandrud, Christopher. 2018. Reproducible research with R and RStudio. Chapman; Hall/CRC.",
    "crumbs": [
      "Introdução"
    ]
  },
  {
    "objectID": "biomoleculas.html",
    "href": "biomoleculas.html",
    "title": "1  Biomoléculas e dimensões",
    "section": "",
    "text": "1.1 Conversão de unidades\n# Algumas conversões de unidades de tempo\nseg &lt;- 1\nmin &lt;- 60 * seg\nhr &lt;- 60 * min\ndia &lt;- 24 * hr\nanos &lt;- 365 * dia\n# Qual o valor em segundos para um dia inteiro ?\ndia/seg\n\n[1] 86400\n\n# Qual o valor em minutos para um ano inteiro ?\nanos/min\n\n[1] 525600\n\n# E qual a idade da Terra em segundos (4.5e9 anos) ?\n4.5e+09 * anos/seg\n\n[1] 1.41912e+17\n# Conversões de quantidades molares\nmmol &lt;- 1  # definições de quantidades\numol &lt;- 0.001 * mmol  # micromol\nnmol &lt;- 0.001 * umol  # nanomol\npmol &lt;- 0.001 * nmol  # picomol\n\n# Quantos picomol possui 6,25 mmol ?\n6.25 * mmol/pmol\n\n[1] 6.25e+09",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biomoléculas e dimensões</span>"
    ]
  },
  {
    "objectID": "biomoleculas.html#conversão-de-unidades",
    "href": "biomoleculas.html#conversão-de-unidades",
    "title": "1  Biomoléculas e dimensões",
    "section": "",
    "text": "Quantidades podem ser convertidas com auxílio do R, desde que definidas as unidades envolvidas. Exemplificando, podemos converter e calcular o tempo decorrido de um evento em diferentes unidades, como segue:\n\n      Também é possível converter unidades entre si, como nas quantidades abaixo:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biomoléculas e dimensões</span>"
    ]
  },
  {
    "objectID": "biomoleculas.html#versatilidade-estrutural-em-biopolímeros",
    "href": "biomoleculas.html#versatilidade-estrutural-em-biopolímeros",
    "title": "1  Biomoléculas e dimensões",
    "section": "1.2 Versatilidade estrutural em biopolímeros",
    "text": "1.2 Versatilidade estrutural em biopolímeros\n      Biopolímeros, ou biomacromoléculas, podem ser considerados polímeros com unidades monoméricas compostas por biomoléculas. Assim, proteínas, ácidos nucleicos ou glicanos (polissacarídios) são respectivamente formados por aminoácidos (20 tipos codificáveis em proteínas, a partir de 64 códons do código genético), bases nitrogenadas (4 tipos com citosina do DNA substituida por uracila no RNA) e monossacarídios (inferior a 6 tipos).\n      Do ponto de vista da variabilidade estrutural, tomando-se por base apenas a combinação de monômeros, é possível prever o número de estruturas distintas pela simples relação (Otaki et al. 2005):\n\\[\nno. biopolímeros = {monômeros}^{sequência}\n\\tag{1.1}\\]\n      No ‘R’ a operação é bem simples, como no exemplo abaixo:\n\n# Cálculo de estruturas peptídicas possíveis numa sequência de 8 elementos (ex:\n# angiotensina II)\n\n20^8\n\n[1] 2.56e+10\n\n\n      É claro que essa variabilidade simulada não se concretiza na Natureza, posto que o cálculo pressupõe a repetição de qualquer monômero ao longo da sequência, ou de conjuntos ou alterâncias desses. Ou seja, peptídeos com somente um tipo ou dois de aminoácidos, por exemplo, não são fisiologicamente viáveis. Isso se concretiza quando observamos que existem em torno de 35 mil proteínas expressas pelo genoma humano, e cujo tamanho médio encontra-se em torno de 476 resíduos de aminoácidos. Se aplicarmos a equação \\(\\eqref{eq-variab}\\) acima para essa situação, encontraríamos…\n\n# Cálculo de estruturas proteicas humanas possíveis numa sequência média de 476\n# resíduos de aminoácidos.\n\n20^476\n\n[1] Inf\n\n\n      Ou seja, nem mesmo o R é capaz de calcular, uma vez que o tamanho da sequência é limitada computacionalmente no programa a 237 resíduos (20\\(^{237}\\) = 1.1x10\\(^{307}\\)). Ainda que pareça uma limitação, veja que resulta em valor muito acima do número de Avogadro (6,02x10\\(^{23}\\)), e mesmo acima do limite computacional para alguns programas matemáticos, tais como os encontrados em algoritmos da internete (Google), e programas matemáticos (ex: Gnu Octave). Ainda assim, o Maxima, programa matemático de distribuição livre, informa que 20\\(^{476}\\) representa um valor com 570 dígitos (algo como 10\\(^{569}\\)).\n      Em contrapartida, esses cálculos simples também não levam em conta que biomoléculas podem apresentar diversos tipos de isomeria, como óptica (D/L), posicional, geométrica (cis/trans), configuracional (syn/anti), ou conformacional (bote/cadeira), o que eleva consideravelmente o número de estruturas possíveis na Natureza.\n\n\n\n\nOtaki, Joji M, Shunsuke Ienaka, Tomonori Gotoh, e Haruhiko Yamamoto. 2005. «Availability of short amino acid sequences in proteins». Protein science 14 (3): 617–25.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biomoléculas e dimensões</span>"
    ]
  },
  {
    "objectID": "tampoes.html",
    "href": "tampoes.html",
    "title": "2  Tampões biológicos",
    "section": "",
    "text": "2.1 Sistema acetato\n\\[\\begin{equation}\npH = pKa + log\\frac{[A^-]}{[HA]}\n\\label{hender-hassel}\n\\end{equation}\\]\n\\[\\begin{equation}\nfa+fb=1\n\\label{frac-tit}\n\\end{equation}\\]\n\\[\\begin{equation}\npH = pKa + log\\frac{fb}{1-fb}\n\\label{HH-frac}\n\\end{equation}\\]\nA partir dessa dedução, pode-se facilmente relacionar que:\n\\[\\begin{equation}\nfb = \\frac{10^{(pH-pKa)}} {1+10^{(pH-pKa)}}\n\\label{HH-fb}\n\\end{equation}\\]\nE, da mesma forma, pode-se encontrar fa como\n\\[\\begin{equation}\nfa = 1- fb\n\\label{HH-fb2}\n\\end{equation}\\]\nResultando em\n\\[\\begin{equation}\nfa = \\frac{1}{1+10^{(pH-pKa)}}\n\\label{eq-HH-fa}\n\\end{equation}\\]\n# Argumentos para uma função\nargs(curve)\n\nfunction (expr, from = NULL, to = NULL, n = 101, add = FALSE, \n    type = \"l\", xname = \"x\", xlab = xname, ylab = NULL, log = NULL, \n    xlim = NULL, ...) \nNULL\nOu, de forma mais simples:\n# Curva de titulação para o sistema acetato/ácido acético\npKa = 4.75\ncurve((1/(1 + 10^(x - pKa))), 0, 14)\n\n\n\n\nRelação entre pH (abscissa) e fração ácida (ordenada) para o par conjugado ácido acético/íon acetato.\n# Curva de titulação para o sistema acetato/ácido acético\npKa = 4.75\ncurve(((10^(x - pKa))/(1 + 10^(x - pKa))), 0, 14)\n\n\n\n\nRelação entre pH (abscissa) e fração básica (ordenada) para o par conjugado ácido acético/íon acetato.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tampões biológicos</span>"
    ]
  },
  {
    "objectID": "tampoes.html#sistema-acetato",
    "href": "tampoes.html#sistema-acetato",
    "title": "2  Tampões biológicos",
    "section": "",
    "text": "A titulação de um ácido fraco é baseada na equação de Henderson-Hasselbach como segue (Po e Senozan 2001) :\n\n      Ocorre que podemos tratar os teores de \\(A^-\\) e \\(HA\\) não em termos absolutos, mas como frações, tanto de base (fb), como de ácido (fa), tal que:\n\n      Assim, pode-se definir que após uma certa quantidade de base, o valor inicial de HA, em fração unitária, será de 1-fb; dessa forma, a expressão de Henderson-Hasselbach pode ser escrita como:\n\n\n\n\n\n\n\n      Dessa forma é possível simular pelo R uma curva de titulação de um ácido fraco qualquer baseando-se em seu valor de pKa. Com exemplo em meio de acetobactérias, podemos exemplificar o tampão acetato, com valor de pKa de 4,75. Para isso utiliza-se a função curve a partir de seus argumentos (args), como segue:\n\n\n\n  Também pode-se fazer o inverso, elaborando um gráfico com a fração fb:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tampões biológicos</span>"
    ]
  },
  {
    "objectID": "tampoes.html#sistema-bicarbonato",
    "href": "tampoes.html#sistema-bicarbonato",
    "title": "2  Tampões biológicos",
    "section": "2.2 Sistema bicarbonato",
    "text": "2.2 Sistema bicarbonato\n      Com o procedimento acima pode-se também simular a curva de titulação para o sistema bicarbonato de tamponamento sanguíneo com base nos valores de pKa do par ácido-base conjugado, apenas somando-se as expressões na equação \\(\\eqref{eq-HH-fa}\\), tal que:\n\\[\\begin{equation}\nfa = \\frac{1}{1+10^{(pH-pKa1)}}+ \\frac{1}{1+10^{(pH-pKa2)}}\n\\label{HHbic}\n\\end{equation}\\]\nAssim,\n\npKa1 = 6.37\npKa2 = 10.2\ncurve((1/(1 + 10^(x - pKa1))) + 1/(1 + 10^(x - pKa2)), 0, 14)\n\n\n\n\n\n\n\nFigura 2.1: Relação entre pH (abscissa) e fração ácida (ordenada) para o par conjugado ácido carbônico/íon bicarbonato.\n\n\n\n\n\n      O gráfico da Figura 2.1 pode ser armazenado em formatos, utilizando-se, por exemplo, o comando dev.copy:\n\ndev.copy(pdf, \"titBicarb.pdf\", width = 6, height = 3)  # alternativamente, bmp,\n# jpeg, tiff, svg, png\n\n      E é claro que, partindo-se dos argumentos da função curve acima, e da flexibilidade que o pacote interno Graphics do R possibilita, pode-se elaborar uma curva mais complexa, como segue:\n\npKa1 = 6.37\npKa2 = 10.2\ncurve((1/(1 + 10^(x - pKa1))) + 1/(1 + 10^(x - pKa2)), 0, 14, xlab = \"pH\", ylab = \"fa\",\n    main = \"Titulação de Ácido carbônico, H2CO3/HCO3-\", type = \"o\", n = 50, lwd = 2,\n    lty = \"dotted\", pch = 3, col = \"blue\", cex = 1.2)  # gráfico de titulação\n\ntext(4.7, 1.3, \"pKa = 6,37\")  # inserção de texto no gráfico\ntext(9, 0.3, \"pKa = 10,20\")\nabline(0.5, 0, lty = \"dotted\")  # linha pontilhada em intercepto\n# e inclinação específicos\nabline(1.5, 0, lty = \"dotted\")\n\n\n\n\nVariação de pH com redução da fração ácida em sistema bicarbonato.\n\n\n\n\n      A título de ilustração é possível “recuperar” o valor de pKa fisiológico acima, ou seja, pKa1, utilizando-se o comando locator(). Como trata-se de um ponto apenas no gráfico, basta digitar o código locator(1) e clicar com o botão esquerdo do mouse no ponto da curva correpondente à fração de 0,5 para fa.\n\nlocator(1)  # para mais pontos no gráfico, basta aumentar o valor entre parênteses\n\n      Observe que à medida em que o valor de pH aproxima-se do de pKa, a crescente variação em fa parece afetar cada vez menos a variação em pH. Isto é a “alma” do sistema tampão, que permite aos organismos resistirem a variações de pH tanto quanto essas estiverem próximas do valor de pKa correspondentes (bicarbonato, fosfato, proteínas).\n      Enquanto o sistema bicarbonato possui dois valores de pKa 1 , um dos quais na faixa de tamponamento fisiológico extracelular, o sistema fosfato que atua intracelularmente possui três valores de pKa, embora também atuando em apenas uma faixa fisiológica.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tampões biológicos</span>"
    ]
  },
  {
    "objectID": "tampoes.html#sistema-fosfato",
    "href": "tampoes.html#sistema-fosfato",
    "title": "2  Tampões biológicos",
    "section": "2.3 Sistema fosfato",
    "text": "2.3 Sistema fosfato\n      Da mesma forma que simulado para o sistema bicarbonato, podemos elaborar uma curva de titulação para o sistema fosfato de tamponamento, dessa vez considerando seus três valores de pKa correspondentes a cada dissociação do ácido triprótico. Como dantes, a expressão que define a fração fa deverá ser tomada como uma soma algébrica, como segue:\n\\[\\begin{equation}\nfa = \\frac{1}{1+10^{(pH-pKa1)}}+ \\frac{1}{1+10^{(pH-pK2)}}+\\frac{1}{1+10^{(pH-pKa3)}}\n\\label{eq-HHfosf}\n\\end{equation}\\]\nNo R isso pode ser feito como abaixo: \\(\\eqref{eq-HHfosf}\\)\n\npKa1 = 2.2\npKa2 = 7.2\npKa3 = 12.7\n\ncurve((1/(1 + 10^(x - pKa1))) + (1/(1 + 10^(x - pKa2))) + (1/(1 + 10^(x - pKa3))),\n    xlim = c(1, 14), xlab = \"pH\", ylab = \"fa\", main = \"Titulação de tampão fosfato\",\n    sub = \" As linhas pontilhadas cruzam os valores de pKa\")\nabline(v = c(2.2, 7.2, 12.7), col = c(\"blue\", \"red\", \"green\"), lty = \"dotted\")  # adição de\n# linhas verticais marcando os valores de pKa\ntext(1.6, 2.5, \"pKa1\")\ntext(6.5, 1.5, \"pKa2\")\ntext(11.8, 0.5, \"pKa3\")\n\n\n\n\nCurva de titulação em sistema fosfato de tamponamento.\n\n\n\n\n\n2.3.1 Titulação de sistemas em geral com programação do R\n  Como ilustrado no fornecimento de argumentos da função args, o ‘R’ é uma linguagem de programação orientada a objeto, e cujos comandos são estruturados como funções. Dessa forma, é possível criar uma função no ‘R’ para operacionalizar ou automatizar qualquer trabalho computacional.\n  Uma função pode ser criada basicamente pelas instrução que segue:\n\nfunção.X &lt;- function( arg1, arg2, arg3 )\n{\ncomandos de execução\nreturn( objeto da função )\n}\n\n  Como exemplo, pode-se criar uma função para converter a temperatura de graus Celsius (C) para temperatura absoluta (K), como segue:\n\n# Função para conversão de graus Celsius a Kelvin\nCtoK &lt;- function(tC) {\n    tK &lt;- tC + 273.15\n    return(tK)\n}\n\n  Para executar essa função CtoK, basta:\n\n# Executando CtoK:\nCtoK(37)\n\n[1] 310.15\n\n\n  Tendo isso em mente, também podemos criar uma função que auxilie na elaboração de curvas de titulação, como acima. Essas operações podem ser automatizadas não apenas para o tampão fosfato, mas para qualquer composto sob dissociação em meio aquoso, não importando o número de prótons envolvidos. Para isso, é necessário:\n\nDefinir uma função do R que contenha os parâmetros e a operação desejada.\nIncluir na função uma estrutura de laço ou loop que permita repetir a operação até exaurido o número de prótons do composto.\nDefinir um vetor do R contendo os valores dos pKas do composto.\nDefinir a expressão de curva que viabilize a simulação.\n\nAbaixo é apresentado um modelo de código que permite a simulação para o tampão fosfato.\n\n# Define função e plot de titulação\nfa = function(pH, pKa) {\n    x = 0\n    for (i in 1:length(pKa)) {\n        x = x + 1/(1 + 10^(pH - pKa[i]))\n    }\n    return(x)\n}\npKa = c(2.2, 7.2, 12.7)\ncurve(fa(x, pKa), 1, 14, xlab = \"pH\", ylab = \"fa\", col = 2)\n\n\n\n\nCurva de titulação para o tampão fosfato, tal como obtida por recurso de programação no R.\n\n\n\n\n\n\n\n\nPo, Henry N, e NM Senozan. 2001. «The Henderson-Hasselbalch equation: its history and limitations». Journal of Chemical Education 78 (11): 1499.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tampões biológicos</span>"
    ]
  },
  {
    "objectID": "tampoes.html#footnotes",
    "href": "tampoes.html#footnotes",
    "title": "2  Tampões biológicos",
    "section": "",
    "text": "Obs: o valor de pKa do sistema bicarbonato é de 6,8 quando considerado o \\(CO_2\\) como fonte de ácido carbônico \\(H_2CO_3\\) em sua reação com \\(H_2O\\), como por exemplo, para determinação de parâmetros arteriais em analisador hospitalar (\\(CO_2\\), \\(HCO_3^-\\), \\(O_2\\)).↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tampões biológicos</span>"
    ]
  },
  {
    "objectID": "aminoacid.html",
    "href": "aminoacid.html",
    "title": "3  Aminoácidos & Peptídios",
    "section": "",
    "text": "3.1 Ponto isoelétrico & aminoácidos\nExemplificando, o ácido glutâmico (Glu, E) apresenta um carboxilato ionizável em sua cadeia lateral, além dos grupos amina (-H\\(_2\\)N) e carboxilato do esqueleto carbônico Figura 3.1:\nFigura 3.1: Fórmula estrutural planar para o ácido glutâmico (Wikimedia).\n\\[\nqnet = qb + qa\n\\] {eq-qnet}\n\\[\nqnet = qb+\\frac{1}{1+10^{pH-pKa}}\n\\] {eq-qnet2}\n\\[\nqnet = \\sum_{i=1}^{n} {(qb+\\frac{1}{1+10^{pH-pKi}})}\n\\tag{3.1}\\]\n, com pKi como o enésimo valor de pKa. Dessa forma pode-se determinar programaticamente a curva de titulação do ácido glutâmico em função de sua carga, e não da fração ácida. Nessa linha, qb representa a forma do composto em base, o que para Glu apresentará os valores de -1 para os dois carboxilatos, e de 0 para o grupo amina, sendo necessário compor um vetor adicional para qb.\n# Titulação de Glu\n\nqNet &lt;- function(pH, qB, pKa) {\n    x &lt;- 0\n    for (i in 1:length(qB)) {\n        x &lt;- x + qB[i] + 1/(1 + 10^(pH - pKa[i]))\n    }\n    return(x)\n}\nqB &lt;- c(-1, 0, -1)\npKa &lt;- c(2.2, 9.7, 4.3)\n\ncurve(qNet(x, qB, pKa), 1, 12, xlab = \"pH\", ylab = \"qNet\")\n\nabline(0, 0, lty = \"dotted\")\n\n\n\n\nCurva de titulação para o ácido glutâmico. A curva intercepta a linha pontilhada no ponto isoiônico do Glu.\n# Cálculo de pI\nf &lt;- function(pH) {\n    qNet(pH, qB, pKa)\n}\nstr(uniroot(f, c(2, 5)))\n\nList of 5\n $ root      : num 3.25\n $ f.root    : num -4.8e-06\n $ iter      : int 4\n $ init.it   : int NA\n $ estim.prec: num 6.1e-05\n\\[\npI = \\frac{pKa1+pKa2}{2}\n\\tag{3.2}\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aminoácidos & Peptídios</span>"
    ]
  },
  {
    "objectID": "aminoacid.html#ponto-isoelétrico-aminoácidos",
    "href": "aminoacid.html#ponto-isoelétrico-aminoácidos",
    "title": "3  Aminoácidos & Peptídios",
    "section": "",
    "text": "De modo geral o ponto isoelétrico, ou pI, representa o valor de pH em que uma molécula adquire uma carga líquida nula sob campo elétrico, ou seja, suas cargas positivas anulam-se com as cargas negativas. Normalmente é experimentalmente obtido por medidas cinéticas, tais como potencial Zeta, eletrofocalização ou eletroforese capilar. De modo similar, o ponto isoiônico refere-se à mesma condição, no entanto na ausência de campo elétrico, podendo ser aferido por titulação potenciométrica, viscosidade, ou pela informação estrutural de uma sequência monomérica, tal como ocorre na sequência primária de proteínas.\n  Como todos os 20 aminoácidos que participam da estrutura proteica possuem grupos ionizáveis, tanto em seu esqueleto carbônico como em sua cadeia lateral, é possível prever o ponto isoiônico de um aminoácido em função dos valores de pKa apresentados nesses grupos ionizáveis. O pI também é denominado comumente por ponto isoelétrico, embora essa definição encerre em si uma abrangência teórica mais complexa.\n\n\n    Dessa forma, sua rede de carga líquida, qnet, pode ser determinada a partir da soma da forma ácida (qa) e básica (qb) da molécula, de forma similar como a que foi apresentada a partir da equação \\(\\eqref{eq-HHfosf}\\):\n\n\n    Como trata-se um ácido poliprótico, a ?eq-qnet2 torna-se:\n\n\n\n    Manualmente é possível identificar o valor de pI para o ácido glutâmico por uma função do R, tal como locator() visto anteriormente. Mas também é possível acessar esse valor automaticamente, aplicando um comando que encontre a raíz dessa função, ou seja, o valor de pH que corresponda a um valor nulo para qnet. Para isto, exemplifica-se o uso de uniroot, no qual define-se a função matemática pretendida, bem como os limites inferior e superior para a busca pelo algoritmo, como segue:\n\n    Esse resultado traduz-se como um pI de 3,25 (root), em 4 iterações, com uma estimativa de precisão de 6,1x10\\(^{-5}\\), e erro associado de -4,8x10\\(^{-6}\\).\n    Essa forma de se obter um valor empregando-se o cálculo numérico é por vezes denominada solução numérica. Por outro lado, pode-se obter o valor de pI para o Glu por um procedimento mais simples, normalmente encontrado nos livros-texto sobre o assunto, e que assume a forma abaixo:\n\n    No nosso exemplo, o pI envolverá os pKas dos dois carboxilatos, o que resultará em (2,3+4,2)/2, ou seja, 3,25 ! Nada mal para uma aproximação, não ? Esse procedimento envolvendo a solução de um problema matemático a partir de parâmetros do sistema é denominado método ou solução analítica. Essa solução também pode ser exemplificada pelo parâmetro obtido em função da observação do comportamento gráfico da titulação, como nas figuras acima.\n   Agora, pra que nos serve um procedimento numérico mais complexo, se uma simples equação analítica já nos resolve o problema de se encontrar o valor de pI para o ácido glutâmico ? Bom, extamente pra isso, para solução de problemas mais complexos. Um pouco menos retórico, entretanto, pode-se afirmar que a solução numérica funciona melhor para sistemas onde a solução analítica por vezes não é suficiente ou torna-se mesmo impossível, como na solução de equações com dezenas de parâmetros.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aminoácidos & Peptídios</span>"
    ]
  },
  {
    "objectID": "aminoacid.html#ponto-isoiônico-biopolímeros",
    "href": "aminoacid.html#ponto-isoiônico-biopolímeros",
    "title": "3  Aminoácidos & Peptídios",
    "section": "3.2 Ponto isoiônico & biopolímeros",
    "text": "3.2 Ponto isoiônico & biopolímeros\n  Uma situção nesse tema pode ser ilustrada pela obtenção do valor de pI para uma proteína. Exemplificando, a lisozima humana, enzima de estrutura terciária composta por 130 resíduos de aminoácidos. Nesse caso, a solução analítica esbarra na complexidade em se identificar quais desses resíduos são ionizáveis em solução aquosa, e quais estariam envolvidos numa distribuição que resultasse numa carga líquida nula para a molécula.\n  Para esse sistema mais complexo é necessário ampliar um pouco a função definida para o ácido glutâmico, computando-se no vetor de qb as cargas em base dos 7 aminoácidos com cadeias laterais ionizáveis, e atribuir um novo vetor para o quantitativo de cada resíduo ionizável presente na lisozima. O código abaixo exemplifica essa solução, calcula o pI da enzima, e elabora o gráfico de sua titulação, embora essa ordem não seja relevante, posto que o pI é calculado numericamente, e não graficamente.\n\n# Titulação de Lisozima e Determinação de pI\n\n# Define função para qNet\nqNet &lt;- function(pH, qB, pKa, n) {\n    x &lt;- 0\n    for (i in 1:length(qB)) {\n        x &lt;- x + n[i] * qB[i] + n[i]/(1 + 10^(pH - pKa[i]))\n    }\n    return(x)\n}\n\n# Define pKas de aCOOH, aNH3 e as 7 cadeias laterais de AA\npKa &lt;- c(2.2, 9.6, 3.9, 4.1, 6, 8.5, 10.1, 10.8, 12.5)\n\n# Define qB, as cargas de cada aminoácido na forma básica\nqB &lt;- c(-1, 0, -1, -1, 0, -1, -1, 0, 0)\n\nionizavel &lt;- c(\"aCOOH\", \"aNH3\", \"Asp\", \"Glu\", \"His\", \"Cys\", \"Tyr\", \"Lys\", \"Arg\")\nn &lt;- c(1, 1, 7, 3, 1, 8, 6, 5, 14)  # Lista para quantidades de resíduos\n# ionizáveis na lisozima (cada elemento representa a quantidade de aCOOH, aNH3,\n# e determinado AA na enzima)\n\n# Cálculo de pI\nf &lt;- function(pH) {\n    qNet(pH, qB, pKa, n)\n}\nstr(uniroot(f, c(1, 13)))  # estimativa de pI entre 10 e 12\n\nList of 5\n $ root      : num 9.46\n $ f.root    : num 3.3e-07\n $ iter      : int 7\n $ init.it   : int NA\n $ estim.prec: num 6.1e-05\n\n# Gráfico de titulação\ncurve(qNet(x, qB, pKa, n), 1, 12, xlab = \"pH\", ylab = \"qNet\")\nabline(0, 0, lty = 3)\n\n\n\n\nCurva de titulação para lisozima.\n\n\n\n\n   Observe que o valor encontrado para pI da lisozima foi de 9,46; ou seja, em pH 9,46 a enzima apresenta rede de carga líquida nula, como também pode ser verificado na representação gráfica.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aminoácidos & Peptídios</span>"
    ]
  },
  {
    "objectID": "aminoacid.html#ponto-isoiônico-bibliotecas-do-r",
    "href": "aminoacid.html#ponto-isoiônico-bibliotecas-do-r",
    "title": "3  Aminoácidos & Peptídios",
    "section": "3.3 Ponto isoiônico & bibliotecas do R",
    "text": "3.3 Ponto isoiônico & bibliotecas do R\n  Não obstante a precisão do cálculo de pI pela solução numérica realizada para a lisozima, uma das características mais fascinantes do programa reside no uso de bibliotecas (packages), não sendo diferente para determinção de propriedades de biopolímeros, tais como pI.\n  Entre as bibliotecas existentes para propriedades físico-químicas de proteínas e ácidos nucleicos exemplifica-se o pacote seqinr, Biological Sequences Retrieval and Analysis 1, de análise e visualização exploratória de biopolímeros. Para uso desse pacote, contudo, faz-se necessário a obtenção da sequência primária da proteína, representada em código de uma letra. Pode-se obter a sequência primária da lisozima pelo sítio do National Center for Biotechnology Information, NCBI 2. Um truque rápido envolve:\n\ndigitar o nome da proteína;\nselecionar entre as opções resultantes;\nclicar em FASTA para obter a sequência primária de 1 letra.\ncopiar a sequência da proteína apresentada para o seqinr.\n\n  Presupondo-se que a biblioteca seqinr esteja instalada, e que a sequência tenha sido obtida para a lisozima (busca por CAA32175 ou lysozyme [Homo sapiens]), pode-se encontrar o valor do pI para a mesma pelo código que segue:\n\nlibrary(seqinr)\nlisozima &lt;- s2c(\"KVFERCELARTLKRLGMDGYRGISLANWMCLAKWESGYNTRATNYNAGDR\n                STDYGIFQINSRYWCNDGKTPGAVNACHLSCSALLQDNIADAVACAKRVV\n                RDPQGIRAWVAWRNRCQNRDVRQYVQGCGV\")\n# converte sequência de string em vetor de caracteres\ncomputePI(lisozima)\n\n[1] 9.2778\n\n\n   Veja que o valor de pI pelo pacote, 9,28, foi bem próximo do encontrado pela solução numérica acima. Isto deve-se ao uso de algoritmos distintos para ambos, bem como o cômputo dos valores de pKa distintos para o seqinr. Exemplificando essa variação, o próprio seqinr apresenta valores de pKa diferentes, em função da base de dados buscada. Para verificar isso, digite o comando abaixo e visualize e variável pK resultante.\n\nlibrary(seqinr)\ndata(pK)\n\n    Complementarmente, pode-se também comparar o valor de pI da lisozima com o algoritmo utilizado pelo banco de dados no sítio 3. Para isto, basta colar a sequência de resíduos no campo disponível e clicar o cômputo de pI. Veja que o valor resultante de 9,28 coincide com o do algoritmo utilizado pelo pacote seqinr do R.\n\nlibrary(knitr)\nknitr::kable(pK, \"pipe\", caption = \"Tabela de valores de pKa para aminoácidos\n             a partir de diversas fontes, extraída do pacote seqinr.\")\n\n\nTabela de valores de pKa para aminoácidos a partir de diversas fontes, extraída do pacote seqinr.\n\n\n\nBjellqvist\nEMBOSS\nMurray\nSillero\nSolomon\nStryer\n\n\n\n\nC\n9.00\n8.5\n8.33\n9.0\n8.3\n8.5\n\n\nD\n4.05\n3.9\n3.68\n4.0\n3.9\n4.4\n\n\nE\n4.45\n4.1\n4.25\n4.5\n4.3\n4.4\n\n\nH\n5.98\n6.5\n6.00\n6.4\n6.0\n6.5\n\n\nK\n10.00\n10.8\n11.50\n10.4\n10.5\n10.0\n\n\nR\n12.00\n12.5\n11.50\n12.0\n12.5\n12.0\n\n\nY\n10.00\n10.1\n10.07\n10.0\n10.1\n10.0\n\n\n\n\n\n    Existem outros pacotes do R que analisam sequências de aminoácidos e nucleotídeos, incluindo o cálculo de pI, entre os quais vale mencionar o Peptides 4.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aminoácidos & Peptídios</span>"
    ]
  },
  {
    "objectID": "aminoacid.html#footnotes",
    "href": "aminoacid.html#footnotes",
    "title": "3  Aminoácidos & Peptídios",
    "section": "",
    "text": "Pacote seqinr: https://cran.r-project.org/web/packages/seqinr/index.html↩︎\nNCBI. https://www.ncbi.nlm.nih.gov/protein↩︎\nExpasy. https://web.expasy.org/compute_pi/↩︎\npacote Peptides. https://cran.r-project.org/web/packages/Peptides/index.html↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Aminoácidos & Peptídios</span>"
    ]
  },
  {
    "objectID": "proteinas.html",
    "href": "proteinas.html",
    "title": "4  Proteínas",
    "section": "",
    "text": "4.1 Composição de aminoácidos\nseq &lt;- \"MKWVTFISLLFLFSSAYSRGVFRRDAHKSEVAHRFKDLGEENFKALVLIAFAQYLQQCPFEDHVKLVNEV\nTEFAKTCVADESAENCDKSLHTLFGDKLCTVATLRETYGEMADCCAKQEPERNECFLQHKDDNPNLPRLV\nRPEVDVMCTAFHDNEETFLKKYLYEIARRHPYFYAPELLFFAKRYKAAFTECCQAADKAACLLPKLDELR\nDEGKASSAKQRLKCASLQKFGERAFKAWAVARLSQRFPKAEFAEVSKLVTDLTKVHTECCHGDLLECADD\nRADLAKYICENQDSISSKLKECCEKPLLEKSHCIAEVENDEMPADLPSLAADFVESKDVCKNYAEAKDVF\nLGMFLYEYARRHPDYSVVLLLRLAKTYETTLEKCCAAADPHECYAKVFDEFKPLVEEPQNLIKQNCELFE\nQLGEYKFQNALLVRYTKKVPQVSTPTLVEVSRNLGKVGSKCCKHPEAKRMPCAEDYLSVVLNQLCVLHEK\nTPVSDRVTKCCTESLVNRRPCFSALEVDETYVPKEFNAETFTFHADICTLSEKERQIKKQTALVELVKHK\nPKATKEQLKAVMDDFAAFVEKCCKADDKETCFAEEGKKLVAASQAALGL\"\nseq &lt;- seq[seq != \"\\n\"]\nseq  # operação booleana != significa 'não'\nA seguir, obtém-se o quantitativo de uma letra específica da sequência.\nlibrary(stringr)\naa &lt;- str_count(seq, pattern = \"A\")\naa\n\n[1] 63\nlibrary(stringr)\nala &lt;- str_count(seq, pattern = \"A\")\narg &lt;- str_count(seq, pattern = \"R\")\nasn &lt;- str_count(seq, pattern = \"N\")\nasp &lt;- str_count(seq, pattern = \"D\")\ncys &lt;- str_count(seq, pattern = \"C\")\nglu &lt;- str_count(seq, pattern = \"E\")\ngln &lt;- str_count(seq, pattern = \"Q\")\ngly &lt;- str_count(seq, pattern = \"G\")\nhis &lt;- str_count(seq, pattern = \"H\")\nile &lt;- str_count(seq, pattern = \"I\")\nleu &lt;- str_count(seq, pattern = \"L\")\nlys &lt;- str_count(seq, pattern = \"K\")\nmet &lt;- str_count(seq, pattern = \"M\")\nphe &lt;- str_count(seq, pattern = \"F\")\npro &lt;- str_count(seq, pattern = \"P\")\nser &lt;- str_count(seq, pattern = \"S\")\nthr &lt;- str_count(seq, pattern = \"T\")\ntrp &lt;- str_count(seq, pattern = \"W\")\ntyr &lt;- str_count(seq, pattern = \"Y\")\nval &lt;- str_count(seq, pattern = \"V\")\nE, para visualizar o resultado numa tabela:\naa_3abrev &lt;- c(\"Ala\", \"Arg\", \"Asn\", \"Asp\", \"Cys\", \"Glu\",\n    \"Gln\", \"Gly\", \"His\", \"Ile\", \"Leu\", \"Lys\", \"Met\",\n    \"Phe\", \"Pro\", \"Ser\", \"Thr\", \"Trp\", \"Tyr\", \"Val\")\naa_quant &lt;- c(ala, arg, asn, asp, cys, glu, gln, gly,\n    his, ile, leu, lys, met, phe, pro, ser, thr, trp,\n    tyr, val)  # vetor com o quantitativo de aminoácidos da proteína\naa_seq &lt;- data.frame(aa_3abrev, aa_quant)  # dataframe com os resultados\ncolnames(aa_seq) &lt;- c(\"Tipo\", \"Qtde\")  # renomear as colunas\n\n\n# Composição de aminoácidos em albumina de soro\n# humano\naa_seq  # apresenta a tabela\n\n   Tipo Qtde\n1   Ala   63\n2   Arg   27\n3   Asn   17\n4   Asp   36\n5   Cys   35\n6   Glu   62\n7   Gln   20\n8   Gly   13\n9   His   16\n10  Ile    9\n11  Leu   64\n12  Lys   60\n13  Met    7\n14  Phe   35\n15  Pro   24\n16  Ser   28\n17  Thr   29\n18  Trp    2\n19  Tyr   19\n20  Val   43\nlibrary(knitr)  # para gerar a tabela\n\nknitr::kable(aa_seq, caption = \"Composição de aminoácidos em albumina \n             # de soro humano.\",\n    \"pipe\")  # tabela\n\n\nComposição de aminoácidos em albumina # de soro humano.\n\n\nTipo\nQtde\n\n\n\n\nAla\n63\n\n\nArg\n27\n\n\nAsn\n17\n\n\nAsp\n36\n\n\nCys\n35\n\n\nGlu\n62\n\n\nGln\n20\n\n\nGly\n13\n\n\nHis\n16\n\n\nIle\n9\n\n\nLeu\n64\n\n\nLys\n60\n\n\nMet\n7\n\n\nPhe\n35\n\n\nPro\n24\n\n\nSer\n28\n\n\nThr\n29\n\n\nTrp\n2\n\n\nTyr\n19\n\n\nVal\n43\naa_1abrev &lt;- c(\"A\", \"R\", \"N\", \"D\", \"C\", \"E\", \"Q\", \"G\", \"H\", \"I\", \"L\", \"K\", \"M\", \"F\",\n    \"P\", \"S\", \"T\", \"W\", \"Y\", \"V\")\nfor (i in aa_1abrev) {\n    aa_quant2 &lt;- str_count(seq, pattern = aa_1abrev)\n    return(aa_quant2)  # sintaxe opcional para função com apenas uma saída\n}\n\n\naa_seq &lt;- data.frame(aa_3abrev, aa_quant2)  # dataframe com os resultados\ncolnames(aa_seq) &lt;- c(\"Tipo\", \"Qtde\")  # renomear as colunas\nknitr::kable(aa_seq, caption = \"Composição de aminoácidos em albumina de soro\n             humano (uso de loop).\",\n    \"pipe\")  # tabela\n\n\nComposição de aminoácidos em albumina de soro humano (uso de loop).\n\n\nTipo\nQtde\n\n\n\n\nAla\n63\n\n\nArg\n27\n\n\nAsn\n17\n\n\nAsp\n36\n\n\nCys\n35\n\n\nGlu\n62\n\n\nGln\n20\n\n\nGly\n13\n\n\nHis\n16\n\n\nIle\n9\n\n\nLeu\n64\n\n\nLys\n60\n\n\nMet\n7\n\n\nPhe\n35\n\n\nPro\n24\n\n\nSer\n28\n\n\nThr\n29\n\n\nTrp\n2\n\n\nTyr\n19\n\n\nVal\n43\nstr_count(seq, pattern = aa_1abrev)\n\n [1] 63 27 17 36 35 62 20 13 16  9 64 60  7 35 24 28 29  2 19 43\ny &lt;- c(1, 2, 4, 8, 16, 32)\nmean(y)\n\n[1] 10.5\n\nsum(y)\n\n[1] 63\n# Tamanho médio estimado de uma proteína a partir do no. de resíduos de\n# aminoácidos\nprot.tamanho &lt;- function(x) {\n    MM &lt;- x * 110  # 'x' representa o número de aminoácidos da proteína\n    return(MM)\n}\n\nprot.tamanho(575)  # no. de resíduos de aminoácidos de albumina humana\n\n[1] 63250\naa_ac &lt;- aa_seq[4, 2] + aa_seq[6, 2]  # AA ácicos\naa_bas &lt;- aa_seq[2, 2] + aa_seq[9, 2] + aa_seq[12, 2]  # AA básicos\naa_arom &lt;- aa_seq[14, 2] + aa_seq[18, 2] + aa_seq[19, 2]  # AA aromáticos\naa_alif &lt;- aa_seq[10, 2] + aa_seq[11, 2] + aa_seq[15, 2] + aa_seq[1, 2] + aa_seq[20,\n    2]  # AA alifáticos\naa_pol &lt;- aa_seq[3, 2] + aa_seq[5, 2] + aa_seq[7, 2] + aa_seq[8, 2] + aa_seq[13,\n    2] + aa_seq[16, 2] + aa_seq[17, 2]  ## AA polares neutros\naa_tot &lt;- str_count(seq, pattern = \"\")  # comprimento da sequência\nclass_perc &lt;- round(c(aa_ac, aa_bas, aa_arom, aa_alif, aa_pol)/aa_tot * 100)\nE agora, sim, constroi-se a tabela.\naa_class &lt;- c(\"ácido\", \"básico\", \"aromático\", \"alifático\", \"polar\")\naa_perc &lt;- data.frame(aa_class, class_perc)  # dataframe com os resultados\ncolnames(aa_perc) &lt;- c(\"Classe\", \"%\")  # renomear as colunas\nknitr::kable(aa_perc, caption = \"Distribuição de classes de aminoácidos \n             em albumina humana.\",\n    \"pipe\")  # tabela\n\n\nDistribuição de classes de aminoácidos em albumina humana.\n\n\nClasse\n%\n\n\n\n\nácido\n16\n\n\nbásico\n17\n\n\naromático\n9\n\n\nalifático\n33\n\n\npolar\n24",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Proteínas</span>"
    ]
  },
  {
    "objectID": "proteinas.html#composição-de-aminoácidos",
    "href": "proteinas.html#composição-de-aminoácidos",
    "title": "4  Proteínas",
    "section": "",
    "text": "Proteínas constituem biopolímeros formados por 20 aminoácidos. Dessa forma pode-se avaliar facilmente a composição de qualquer proteína disponível em banco de dados, como o PDB visto no capítulo Capítulo 3. Tomando-se a albumina de soro humano como exemplo, código AAA98797 do National Center for Biotechnology Information, é possível contabilizar os 20 tipos de aminoácidos que compõe sua sequência. Para isto basta considerar a sequência FASTA como uma string, e extrair a quantidade de cada letra, utilizando-se a biblioteca stringr, como segue.\n    Primeiro, obtém-se a sequência FASTA da albumina de soro.\n\n    Pode-se observar que há espaços vazios, que podem ser omitidos por razões estéticas ou não, já que o pacote stringr não os contabilizará, contrariamente a pacotes mais específicos para sequências biológicas, como o seqinr visto anteriormente. Mas se desejar omitir esses espaços, basta executar o código abaixo.\n\n\n\n    Veja que o comando str_count contabiliza apenas a letra “A” na sequência. Dessa forma, é possível obter todos os 20 aminoácidos, repetindo-se esse comando.\n\n\n\n      O ‘R’ possui alguns comandos para a geração estética de tabelas, entre os quais os incluídos no pacote ‘knitr’, como segue:\n\n    Observe que, à despeito do resultado obtido, houve certo trabalho em se obter a composição da albumina, a partir das 20 linhas modificadas para cada aminoácido. Uma alternativa mais prática consiste em considerar um loop que execute a extração da informação desejada para um vetor contendo a abreviação de uma letra para cada aminoácido.\n\n    Dessa forma obtém-se o mesmo resultado, mas com menor consumo de memória e maior velocidade de processamento, características em qualquer lógica de programação. Apesar do loop exemplificar uma automação, a função str_count retém em si um loop interno, já que aplica uma função de contagem de elementos a uma sequência, a partir de um padrão pré-definido (o vetor aa_1abrev, no caso). Dessa forma, pode-se simplificar ainda mais o script, não necessitando do loop externo.\n\n    Diversas funções do R exibem esse loop interno, e que pode ser aplicado em vetores, listas, matrizes e dataframes (planilha de dados). As mais simples envolvem a aplicação de uma função pré-programada do R a um vetor, por ex:\n\n      Outra vetorização frequente decorre da aplicação de uma função de usuário a vetor, reduzindo a necessidade de repetição de comandos, como no exemplo abaixo:\n\n      Outra forma de vetorização envolve a família de funções apply, composta pelos comandos apply, sapply, tapply, lapply, e mapply. Embora possuam processamento mais rápido que funções de loop externo para uso de matrizes muito complexas, cada qual é voltado a um objeto distinto ou situação específica do R (retorno de lista, vetor ou matriz), permite o uso de subset (subconjuntos de dados), utiliza funções do R ou funções previamente definidas pelo usuário, e roda em apenas uma linha de comando. Essas vantagens contrapõe-se ao uso de loop for aplicado para vetores. Contudo, a vetorização opera muito bem quando se deseja aplicar ou mapear uma função a um vetor/matriz/lista. Quando, por outro lado, se deseja aplicar uma função cujo resultado dependa de mais de um vetor/matriz/lista, o loop for torna-se indispensável, como na titulação de ácidos fracos do capítulo Capítulo 3.\n    Seja qual for o método empregado (e aí vale destacar as chamadas boas práticas de programação na construção de scripts 1), é possível construir uma composição mais geral para o conjunto de resíduos da proteína. Assim, podemos obter qualquer relação quantitativa a partir da sequência, já que a estamos tratando como uma string. Exemplificando, uma tabela contendo a classe de cada aminoácido que compõe a sequência.\n\n    Agora, ao invés de se construir uma tabela com a contagem desses grupos, façamos o percentual dos mesmos, para uma visão mais geral da sequência.\n\n\n\n    Percebe-se pela tabela acima que a distribuição de classes de resíduos de aminoácidos na albumina é razoavelmente homogênea, o que contribui para sua função anfotérica de transporte para compostos polares (ex:cálcio) e apolares (ex: colesterol, ácidos graxos).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Proteínas</span>"
    ]
  },
  {
    "objectID": "proteinas.html#tabela-de-purificação-de-proteínas-r-como-planilha-eletrônica",
    "href": "proteinas.html#tabela-de-purificação-de-proteínas-r-como-planilha-eletrônica",
    "title": "4  Proteínas",
    "section": "4.2 Tabela de Purificação de Proteínas & R como planilha eletrônica",
    "text": "4.2 Tabela de Purificação de Proteínas & R como planilha eletrônica\n     Não obstante a facilidade com que podemos elaborar/editar planilhas eletrônicas convencionais (spreadsheet; ex: MS Excel, Libreoffice Calc, Gnumeric, etc), o ‘R’ também permite trabalhar-se com planilhas. Ainda que menos intuitivo como as mencionadas, a scriptagem no R permite a elaboração/edição de planilhas de alta complexidade, dada a natureza da programação estatística que envolve a suite.\n      Para exemplificar a construção de uma planilha simples, tomemos como exemplo uma Tabela de Purificação de Proteínas, usualmente utilizada em Biotecnologia e áreas afins. A forma mais simples de construção de uma planilha envolve 1) a elaboração individual de vetores, e 2) a união dos vetores em uma planilha.\n      Os procedimentos para purificação (ou isolamento, fracionamento) proteica envolvem técnicas como tratamento químico (precipitação por sulfato de amônio, acetona), tratamento ácido, tratamento térmico, diálise, cromatografia (filtração molecular, troca-iônica, afinidade, fase reversa), entre outros. Para aferição do grau de pureza da amostra obtida utilizam-se normalmente a eletroforese simples, focalização isoelétrica, eletroforese 2D, uso de anticorpos monoclonais, e ensaios de atividade específicos, dentre vários.\n      Para a tabela de purificação são exigidos somente os vetores de massa de amostra e de atividade enzimática da amostra, obtidos em cada etapa de purificação. Uma planilha simples poderia ser construida como:\n\n# Elaboração de planilha simples de purificação de enzima (cada elemento do\n# vetor representa uma etapa de purificação)\n\n# 1. Definição dos vetores principais:\nprot.total &lt;- c(6344, 302, 145, 34, 10, 3.8)  # proteína, mg\nativ.tot &lt;- c(200, 122, 106, 70, 53, 24) * 1000  # atividade, U\n\n# 2. Construção da planilha:\npurif.plan &lt;- data.frame(prot.total, ativ.tot)\npurif.plan\n\n  prot.total ativ.tot\n1     6344.0   200000\n2      302.0   122000\n3      145.0   106000\n4       34.0    70000\n5       10.0    53000\n6        3.8    24000\n\n\n      A planilha construida compõe agora um ‘dataset’ do R. Há outras formas de construção simples, também, como o uso da função ‘cbind’ (pra união de colunas) ou ‘rbind’ (união de linhas; rows):\n\npurif.plan2 &lt;- cbind(prot.total, ativ.tot)\npurif.plan2\n\n     prot.total ativ.tot\n[1,]     6344.0   200000\n[2,]      302.0   122000\n[3,]      145.0   106000\n[4,]       34.0    70000\n[5,]       10.0    53000\n[6,]        3.8    24000\n\n\n      Seja qual for o procedimento, pode-se alterar os nomes das colunas, como segue:\n\n# Edição de nome de colunas\ncolnames(purif.plan2) &lt;- c(\"totalProt\", \"enzAtiv\")\npurif.plan2\n\n     totalProt enzAtiv\n[1,]    6344.0  200000\n[2,]     302.0  122000\n[3,]     145.0  106000\n[4,]      34.0   70000\n[5,]      10.0   53000\n[6,]       3.8   24000\n\n\n      Como numa planilha convencional, também é possível se criar novos vetores calculados a partir dos iniciais:\n\npurif.plan3 &lt;- data.frame(prot.total, ativ.tot, ativ.tot/prot.total)\noptions(digits = 1)  # opção para no. de casas decimais\ncolnames(purif.plan3) &lt;- c(\"prot.total\", \"ativ.tot\", \"ativ.specif\")\nrownames(purif.plan3) &lt;- c(\"extr.bruto\", \"NH4SO2\", \"acetona\", \"Sephadex G-100\", \"DEAE-celulose\",\n    \"C8-fase rev\")\npurif.plan3\n\n               prot.total ativ.tot ativ.specif\nextr.bruto           6344    2e+05          32\nNH4SO2                302    1e+05         404\nacetona               145    1e+05         731\nSephadex G-100         34    7e+04        2059\nDEAE-celulose          10    5e+04        5300\nC8-fase rev             4    2e+04        6316\n\n\n      A planilha pode ser editada em seus valores, também, bastando pra isso atribuir um novo nome para que as modificações sejam salvas:\n\n# Edição simples de planilha (alterações de valores e nomes de colunas)\n\npurif.plan4 &lt;- edit(purif.plan3)  # ou data.entry( )\n\n      É claro, também, que se pode importar os dados de uma planilha já construida em outro programa. Exemplificando para uma planilha salva como CSV:\n\n# Importação de dados de outra planilha (CSV):\n\n# 1. Importação com nome da planilha desejada:\npurif.plan5 &lt;- read.table(\"planilha.csv\", header = T, sep = \",\")\n\n# 2. Importação com tela de busca da planilha desejada:\npurif.plan5 &lt;- frame &lt;- read.csv(file.choose())\n\n      Um grande número de operações pode ser conduzido em planilhas no ‘R’, tais como inserção, deleção, modificação, agregação (merge), filtragem, extração de subconjunto, operações matemáticas e cálculos estatísticos (média, desvio-padrão, etc). Pode-se também converter a planilha em uma tabela de visual mais completo, por uso da biblioteca ‘tibble’, parte de um conjunto de pacotes utilizado em ciência de dados denominado Tidyverse :\n\nlibrary(tibble)\npurif.plan6 &lt;- as_tibble(purif.plan3)\npurif.plan6\n\n# A tibble: 6 × 3\n  prot.total ativ.tot ativ.specif\n       &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;\n1     6344     200000        31.5\n2      302     122000       404. \n3      145     106000       731. \n4       34      70000      2059. \n5       10      53000      5300  \n6        3.8    24000      6316. \n\n\n      O Tidyverse compõe um ecossistema de pacotes do ‘R’ que comungam da mesma filosofia, gramática e estrutura de dados. Entre esses pacotes inlcui-se o ‘tibble’ (tabelas), ‘ggplot2’ (gráficos de alta qualidade visual), e ‘dplyr’ (manipulação de dados). No que tange ao ‘dplyr’, é bastante flexível a criação e edição de planilhas, e que são convertidas a tabelas, tal como segue para o exemplo da purificação acima:\n\n# Tabela de purificação de enzima com pacote 'dplyr':\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\npurif.plan7 &lt;- mutate(purif.plan, ativ.esp = ativ.tot/prot.total)\npurif.plan7\n\n  prot.total ativ.tot ativ.esp\n1       6344    2e+05       32\n2        302    1e+05      404\n3        145    1e+05      731\n4         34    7e+04     2059\n5         10    5e+04     5300\n6          4    2e+04     6316\n\n\n      Observe que com o pacote ‘dplyr’ a inserção de uma nova coluna não requereu um novo vetor para nomes de colunas (‘colnames’). Além disso, a planilha final foi elaborada junto à gramática do pacote ‘tibble’ do Tidyverse. Essa facilidade também se extende para os processos de edição e filtragem da planilha, tal a extração de uma coluna modificada:\n\nativ.tot.kU &lt;- transmute(purif.plan7, ativ.tot = ativ.tot/1000)\nativ.tot.kU  # vetor de atividade específica em U x 10^3\n\n  ativ.tot\n1      200\n2      122\n3      106\n4       70\n5       53\n6       24\n\n\n      Dessa forma pode-se construir uma tabela completa de purificação, elencando-se, além da atividade específica, o nível de purificação (de quantas vezes a atividade específica aumentou em relação à da amostra inicial) e o rendimento obtido (de quantas vezes o teor da enzima alvo reduziu em relação à amostra inicial - atividade remanescente):\n\npurif.plan8 &lt;- mutate(purif.plan7,\n  purif = ativ.esp / ativ.esp[1], # nível de purificação\n  rend.perc = 100 * ativ.tot / ativ.tot[1]\n) # rendimento percentual\n\n# Convetendo à tabela...\nlibrary(knitr)\nknitr::kable(purif.plan8, caption = \"Tabela de purificação para uma enzima\", \"pipe\")\n\n\nTabela de purificação para uma enzima\n\n\nprot.total\nativ.tot\nativ.esp\npurif\nrend.perc\n\n\n\n\n6344\n2e+05\n32\n1\n100\n\n\n302\n1e+05\n404\n13\n61\n\n\n145\n1e+05\n731\n23\n53\n\n\n34\n7e+04\n2059\n65\n35\n\n\n10\n5e+04\n5300\n168\n26\n\n\n4\n2e+04\n6316\n200\n12\n\n\n\n\n\n      Adicionalmente, o ‘R’ possui alguns pacotes que agilizam a criação/edição de planilhas de modo interativo e mais próximo ao de uma planilha eletrônica convencional, dentre os quais destaca-se o pacote ‘DT’, uma biblioteca elaborada em JavaScript que produz uma planilha editável em HTML:\n\nlibrary(DT)\npurif.plan9 &lt;- as.data.frame(purif.plan8)\nrownames(purif.plan9) &lt;- c(\"extr.bruto\", \"NH4SO2\", \"acetona\", \"Sephadex G-100\", \"DEAE-celulose\",\n    \"C8-fase rev\")  # converte a tabela de purificação\n# em planilha para se utilizada pelo pacote DT\ndatatable(purif.plan9) %&gt;%\n    formatRound(1:5, 1)  # colunas com 1 casa decimal\n\n      Por tratar-se de saída em HTML interativo, o resultado do trecho de código precisa ser omitido para a correta compilação pelo ‘R’ (eval=FALSE, include=TRUE).\n      A biblioteca ‘DT’ permite, entre outros, reordenamento, filtragem, e mesmo edição dos valores, de modo interativo (basta clicar na célula desejada):\n\nDT::datatable(purif.plan9, editable = \"cell\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Proteínas</span>"
    ]
  },
  {
    "objectID": "proteinas.html#interação-de-oxigênio-com-mioglobina-e-hemoglobina",
    "href": "proteinas.html#interação-de-oxigênio-com-mioglobina-e-hemoglobina",
    "title": "4  Proteínas",
    "section": "4.3 Interação de oxigênio com mioglobina e hemoglobina",
    "text": "4.3 Interação de oxigênio com mioglobina e hemoglobina\n    Tanto a mioglobina (PD 1MBO) como a hemoglobina humanas (PDB 6BB5) constituem proteínas de transporte do oxigênio molecular. A hemoglobina, de estrutura quaternária, o faz dos pulmões aos tecidos, enquanto que a mioglobina, terciária, o distribui entre esses. Suas curvas de saturação com oxigênio são bem conhecidas em livros-texto, cujo aprendizado pode agregar valor quando simuladas.\n    Dessa forma, pode-se considerar a ligação do O\\(_{2}\\) à mioglobina como uma fração de saturação y dada em função de sua meia satuação a 50% de pressão de O\\(_{2}\\) (constante de dissociação \\(K_{50}\\) de 2.8 mmHg).\n\\[\ny=\\frac{pO_2}{K_{50}+pO_2}\n\\tag{4.1}\\]\nPor outro lado, o valor de \\(K_{50}\\) para a hemoglobina é de 26 mmHg, mas sua função exprime-se de forma diferente à da mioglobina:\n\\[\ny=\\frac{pO_2^{nH}} {K_{50}^{nH}+pO_2^{nH}}\n\\tag{4.2}\\]\nNessa Equação 4.2, nH representa o coeficiente de cooperatividade de Hill, que resume a energia distribuida entre as quatro constantes microscópicas de dissociação de O\\(_{2}\\) aos quatro centros porfirínicos da hemoglobina (grupos heme). Simulando ambas as curvas:\n\nK50 &lt;- 2.8\ncurve(x/(K50 + x), xlim = c(0, 100), xlab = \"pO2 (mmHg)\", ylab = \"y\", lty = \"dotted\")\n\nK50 &lt;- 26\nnH &lt;- 2.8\ncurve(x^nH/(K50^nH + x^nH), xlim = c(0, 100), xlab = \"pO2 (mmHg)\", ylab = \"y\", col = \"red\",\n    add = TRUE)  # 'add' permite adicionar curvas ao gráfico\nabline(0.5, 0, lty = 2)  # acrescenta linha de base em meia saturação\n\n\n\n\nIsoterma de saturação de oxigênio à mioglobina (linha contínua) e hemoglobina (linha pontilhada), indicando o intercepto em pO2 de 50% (meia saturação).\n\n\n\n\n   Como mencionado no parágrafo anterior, aos quatro centros de ligação com oxigênio molecular reportam-se quatro constantes microscópicas de equilíbrio de dissociação, de K1 a K4. Simplificando o valor de pO\\(_{2}\\) para L, ligante, é possível também representar a ligação de O\\(_{2}\\) à hemoglobina pela equação de Adair (Pauling 1935):\n\\[\ny=\\frac{K1*L+2*K2*K1*L^2+3*K3*K2*K1*L^3+4*K4*K3*K2*K1*L^4} {4*(1+K1*L+2*K2*K1*L^2+3*K3*K2*K1*L^3+4*K4*K3*K2*K1*L^4)}\n\\tag{4.3}\\]\n    Ocorre que existe um efeito estatístico associado à interação em estudo, já que o O\\(_{2}\\) possui 4 sítios iniciais de interação à hemoglobina (Tyuma, Imai, e Shimizu 1973), valores que reduzem até a saturação dos 4 sítios. Dessa forma, é necessário contabilizar as constantes microscópicas Ki em razão desse comprometimento estatístico:\n\\[\nKi_{corr} = \\frac{i}{N-1+i}*Ki\n\\tag{4.4}\\]\n    No R, isso pode ser auxiliado por um loop for:\n\nK &lt;- c(0.011, 0.016, 0.118, 0.4)  # vetor de constantes microscópicas de \n# dissociação de Hb para O2\nL &lt;- seq(1, 201, 2)  # vetor de teores de O2\n\nKcorr &lt;- c()  # inicializa um vetor vazio para saída do vetor corrigido de Ki\nN &lt;- 4  # declara o número de sítios na Hb\nfor (i in 1:N) Kcorr[i] &lt;- i/(N - i + 1) * K[i]\nKcorr  # apresenta o vetor de valores de Ki corrigidos para o efeito estatístico\n\n[1] 0.003 0.011 0.177 1.600\n\n\n    Perceba que os valores para Ki corrigidos estão em proporção que segue a disponibilidade de sítios, de 4 vezes menor para o 1o. sítio (maior ligação), até 4 vezes maior para o 4o. sítio (menor ligação). Agora é possível aplicar-se a Equação 4.3 utilizando-se as constantes calculadas como segue:\n\nnumer &lt;- K[1] * L + 2 * K[2] * K[1] * L^2 + 3 * K[3] * K[2] * K[1] * L^3 + 4 * K[4] *\n    K[3] * K[2] * K[1] * L^4\ndenom &lt;- 1 + numer\ny &lt;- numer/denom\nplot(L, y, xlab = \"pO2\", type = \"l\", col = 2)\n\n\n\n\nIsoterma de saturação de oxigênio à hemoglobina pela equação de Adair.\n\n\n\n\n      Por fim, também é possível obter a curva de ligação utilizando-se uma variação de loop for na qual a Equação 4.3 é produzida por iteração, como segue (Bloomfield 2009):\n\n# Cálculo de y em cada L\nYi &lt;- function(L, Kcorr) {\n    N &lt;- length(Kcorr)\n    conc &lt;- c()\n    conc[1] &lt;- L * Kcorr[1]\n    for (i in 2:N) conc[i] &lt;- conc[i - 1] * L * Kcorr[i]\n    numer2 &lt;- sum((1:N) * conc)/N\n    denom2 &lt;- 1 + sum(conc)\n    return(numer2/denom2)\n}\n\n# Cálculo de y para o vetor de L\nY &lt;- function(L, Kcorr) {\n    YY &lt;- c()\n    for (j in 1:length(L)) YY[j] &lt;- Yi(L[j], Kcorr)\n    return(YY)\n}\n\n# Aplicação da função de y para L e gráfico\nYfinal &lt;- Y(L, Kcorr)\nplot(L, Yfinal, type = \"l\", col = 2, xlab = \"pO2\", ylab = \"y\")\n\n\n\n\nCurva de saturação de oxigênio à hemoglobina obtida por iteração da equação de Adair, tal como corrigida para o efeito estatístico.\n\n\n\n\n      Observe que há mínimas diferenças entre as curvas obtidas pelos distintos procedimentos, em razão dos diferentes algoritmos utilizados.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Proteínas</span>"
    ]
  },
  {
    "objectID": "proteinas.html#alguns-pacotes-do-r-para-estudo-de-proteínas",
    "href": "proteinas.html#alguns-pacotes-do-r-para-estudo-de-proteínas",
    "title": "4  Proteínas",
    "section": "4.4 Alguns pacotes do R para estudo de proteínas",
    "text": "4.4 Alguns pacotes do R para estudo de proteínas\n      Alguns pacote do R são bastante úteis no estudo de proteínas, em especial a biblioteca seqinr vista no capítulo Capítulo 3, e que computa diversos valores e informações para sequências proteicas, tais como pI, index de hidroxipatia, distribuição de resíduos, entre outros. O sítio do projeto 2 contém informação detalhada para seu uso. Utilizando-se o mesmo procedimento para obtenção da sequência FASTA para a lisozima do capítulo Capítulo 3 (código CAA32175 no sítio NCBI), pode-se obter um conjunto extenso de informações da proteína, como exemplificado abaixo:\n\nlibrary(seqinr)\n\n\nAttaching package: 'seqinr'\n\n\nThe following object is masked from 'package:dplyr':\n\n    count\n\nlisozima &lt;- c(\"KVFERCELARTLKRLGMDGYRGISLANWMCLAKWESGYNTRATNYNAGDRSTDYGIFQ\nINSRYWCNDGKTPGAVNACHLSCSALLQDNIADAVACAKRVVRDPQGIRAWVAWRNRCQNRDVRQYVQGCGV\")\nseq_liso &lt;- s2c(lisozima)  # converte sequência de string de aminoácidos para \n# o padrão do seqinr (vetor de caracteres)\nseq_liso2 &lt;- seq_liso[seq_liso != \"\\n\"]  # eliminação de espaços exigida pelo\n# seqinr advindos do procedimento de copiar/colar.\nseq_liso2\n\n  [1] \"K\" \"V\" \"F\" \"E\" \"R\" \"C\" \"E\" \"L\" \"A\" \"R\" \"T\" \"L\" \"K\" \"R\" \"L\" \"G\" \"M\" \"D\"\n [19] \"G\" \"Y\" \"R\" \"G\" \"I\" \"S\" \"L\" \"A\" \"N\" \"W\" \"M\" \"C\" \"L\" \"A\" \"K\" \"W\" \"E\" \"S\"\n [37] \"G\" \"Y\" \"N\" \"T\" \"R\" \"A\" \"T\" \"N\" \"Y\" \"N\" \"A\" \"G\" \"D\" \"R\" \"S\" \"T\" \"D\" \"Y\"\n [55] \"G\" \"I\" \"F\" \"Q\" \"I\" \"N\" \"S\" \"R\" \"Y\" \"W\" \"C\" \"N\" \"D\" \"G\" \"K\" \"T\" \"P\" \"G\"\n [73] \"A\" \"V\" \"N\" \"A\" \"C\" \"H\" \"L\" \"S\" \"C\" \"S\" \"A\" \"L\" \"L\" \"Q\" \"D\" \"N\" \"I\" \"A\"\n [91] \"D\" \"A\" \"V\" \"A\" \"C\" \"A\" \"K\" \"R\" \"V\" \"V\" \"R\" \"D\" \"P\" \"Q\" \"G\" \"I\" \"R\" \"A\"\n[109] \"W\" \"V\" \"A\" \"W\" \"R\" \"N\" \"R\" \"C\" \"Q\" \"N\" \"R\" \"D\" \"V\" \"R\" \"Q\" \"Y\" \"V\" \"Q\"\n[127] \"G\" \"C\" \"G\" \"V\"\n\npmw(seq_liso2)  # peso molecular da proteína\n\n[1] 14701\n\naaa(seq_liso2)  # distribuição de resíduos\n\n  [1] \"Lys\" \"Val\" \"Phe\" \"Glu\" \"Arg\" \"Cys\" \"Glu\" \"Leu\" \"Ala\" \"Arg\" \"Thr\" \"Leu\"\n [13] \"Lys\" \"Arg\" \"Leu\" \"Gly\" \"Met\" \"Asp\" \"Gly\" \"Tyr\" \"Arg\" \"Gly\" \"Ile\" \"Ser\"\n [25] \"Leu\" \"Ala\" \"Asn\" \"Trp\" \"Met\" \"Cys\" \"Leu\" \"Ala\" \"Lys\" \"Trp\" \"Glu\" \"Ser\"\n [37] \"Gly\" \"Tyr\" \"Asn\" \"Thr\" \"Arg\" \"Ala\" \"Thr\" \"Asn\" \"Tyr\" \"Asn\" \"Ala\" \"Gly\"\n [49] \"Asp\" \"Arg\" \"Ser\" \"Thr\" \"Asp\" \"Tyr\" \"Gly\" \"Ile\" \"Phe\" \"Gln\" \"Ile\" \"Asn\"\n [61] \"Ser\" \"Arg\" \"Tyr\" \"Trp\" \"Cys\" \"Asn\" \"Asp\" \"Gly\" \"Lys\" \"Thr\" \"Pro\" \"Gly\"\n [73] \"Ala\" \"Val\" \"Asn\" \"Ala\" \"Cys\" \"His\" \"Leu\" \"Ser\" \"Cys\" \"Ser\" \"Ala\" \"Leu\"\n [85] \"Leu\" \"Gln\" \"Asp\" \"Asn\" \"Ile\" \"Ala\" \"Asp\" \"Ala\" \"Val\" \"Ala\" \"Cys\" \"Ala\"\n [97] \"Lys\" \"Arg\" \"Val\" \"Val\" \"Arg\" \"Asp\" \"Pro\" \"Gln\" \"Gly\" \"Ile\" \"Arg\" \"Ala\"\n[109] \"Trp\" \"Val\" \"Ala\" \"Trp\" \"Arg\" \"Asn\" \"Arg\" \"Cys\" \"Gln\" \"Asn\" \"Arg\" \"Asp\"\n[121] \"Val\" \"Arg\" \"Gln\" \"Tyr\" \"Val\" \"Gln\" \"Gly\" \"Cys\" \"Gly\" \"Val\"\n\nAAstat(seq_liso2, plot = TRUE)  # gráfico de distribuição, composição \n\n\n\n\n\n\n\n\n$Compo\n\n *  A  C  D  E  F  G  H  I  K  L  M  N  P  Q  R  S  T  V  W  Y \n 0 14  8  8  3  2 11  1  5  5  8  2 10  2  6 14  6  5  9  5  6 \n\n$Prop\n$Prop$Tiny\n[1] 0.3\n\n$Prop$Small\n[1] 0.6\n\n$Prop$Aliphatic\n[1] 0.2\n\n$Prop$Aromatic\n[1] 0.1\n\n$Prop$Non.polar\n[1] 0.6\n\n$Prop$Polar\n[1] 0.4\n\n$Prop$Charged\n[1] 0.2\n\n$Prop$Basic\n[1] 0.2\n\n$Prop$Acidic\n[1] 0.08\n\n\n$Pi\n[1] 9\n\n# e proporção de resíduos, valor de pI\n\n      Entre outras funções constantes do seqinr inclui-se a conversão de aminoácidos para abreviações de 1 e 3 letras (ae aaa, respectivamente), listagem de 544 propriedades físico-químicas dos 20 aminoácidos proteicos (aaindex),pK (autoexplicativo, e visto anteriormente), e cômputo isolado de pI (computePI) e de massa molecular (pmw), além de várias outras, tanto para proteômica como para genômica.\n      Outro pacote do R interessante para estudo de proteínas é o Peptides 3, que também computa diversas propriedades físico-químicas para sequências de aminoácidos, além de possibilitar a integração de plotagem com o pacote de dinâmica molecular GROMACS. Como para o seqinr, o Peptides necessita de conversão da sequência em string para o padrão vetorial reconhecido. Entre as funções do pacote destacam-se o cômputo de 66 descritores para cada aminoácido de uma sequência (aaDescriptors), a composição da sequência por classificação dos resíduos (aaComp), o cômputo de índice alifático (aIndex), o índice de hidrofobicidade (hydrophobicity), índice de instabilidade (instalIndex), relação de massa/carga (mz), massa molecular (mw), e pI (pI), entre outros.\n      Entre pacotes mais direcionados ao estudo comparativo e visualização de estruturas, bem como para descritores de bioinformática e quimiogenômica vale mencionar Bio3d, Autoplotprotein, protr, BioMedR, e UniprotR, entre muitos.\n\n\n\n\nBloomfield, Victor. 2009. Computer simulation and data analysis in molecular biology and biophysics: an introduction using R. Springer Science & Business Media.\n\n\nPauling, Linus. 1935. «The oxygen equilibrium of hemoglobin and its structural interpretation». Proceedings of the National Academy of Sciences of the United States of America 21 (4): 186.\n\n\nTyuma, Itiro, Kiyohiro Imai, e Katsuhiko Shimizu. 1973. «Analysis of oxygen equilibrium of hemoglobin and control mechanism of organic phosphates». Biochemistry 12 (8): 1491–98.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Proteínas</span>"
    ]
  },
  {
    "objectID": "proteinas.html#footnotes",
    "href": "proteinas.html#footnotes",
    "title": "4  Proteínas",
    "section": "",
    "text": "Algumas práticas de programação (Best Codes): 1) organizar um projeto em pastas (ex: dados,figuras,scripts) ou criar um pacote do R como opção; 2) criar seções num código pra facilitar localização; 3) nomear os code chunks (pedaços de código); 4) colocar no início do código as bibliotecas utilizadas, fontes, e chamada de dados (evita procurar algo necessário pro script rodar ao longo do código); 5) identar, preferivelmente com 1 ou 2 comandos por linha; 6) parâmetros de função sempre dentro de função; 7) evitar parâmetros globais; 8) não usar ‘attach’; 8) usar parâmetros com nomes intuitivos (e não x e y; ex: nome_função); 9) atribuir nomes à objetos com uma das três convenções nominais (ex: KiCompet, ki_compet, ki.compet).↩︎\nSítio do projeto Seqinr: http://seqinr.r-forge.r-project.org/↩︎\nPacote Peptides: https://cran.r-project.org/web/packages/Peptides/index.html↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Proteínas</span>"
    ]
  },
  {
    "objectID": "enzimas.html",
    "href": "enzimas.html",
    "title": "5  Enzimas",
    "section": "",
    "text": "5.1 Obtenção de parâmetros cinéticos a partir de dados expermentais simulados\n\\[\nE+S \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{k2} \\end{array} ES\n\\begin{array}{c}\n_{k3}\\\\\n\\rightarrow \\\\\n  ^{}\\end{array}E+P\n\\tag{5.1}\\]\nOnde P representa o produto da reação, ES o complexo ativado no estado de transição, e k1, k2 e k3 as constantes de velocidade da reação.\n\\[\nv=\\frac{Vm*S}{Km+S}\n\\tag{5.2}\\]\nOnde Km representa a constante de Michaelis-Menten, e Vm a velocidade limite da reação (por vezes denominada erroneamente como velocidade máxima, embora a hipérbole quadrática descrita pela função não exiba valor máximo por não atingir uma assíntota). Por sua vez Km pode ser definido a partir das constantes de velocidade da Equação 5.1 como:\n\\[\nKm=\\frac{k1+k3}{k2}\n\\tag{5.3}\\]\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500)  # fixa a semente para geração de dados aleatórios reproduzíveis\nerro &lt;- runif(20, 0, 1)  # comando para erro uniforme (no. de pontos, min, max)\ncurve(Vm * x/(Km + x) + erro, type = \"p\", from = 0, to = 1, n = 20, xlab = \"[S}\",\n    ylab = \"v\")  # elaboração da curva com cômputo de erro uniforme\n\n\n\n\n\n\n\nFigura 5.3: Simulação de pontos experimentais (n=20) obtidos a partir da equação de Michaelis-Menten.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Enzimas</span>"
    ]
  },
  {
    "objectID": "enzimas.html#obtenção-de-parâmetros-cinéticos-a-partir-de-dados-expermentais-simulados",
    "href": "enzimas.html#obtenção-de-parâmetros-cinéticos-a-partir-de-dados-expermentais-simulados",
    "title": "5  Enzimas",
    "section": "",
    "text": "Para a determinação dos parâmetros cinéticos Vm e Km obtidos a partir de uma simulação experimental de dados de S e v, é necessário em primeiro lugar obter-se os pontos experimentais, tal como segue:\n\n      Perceba que pela Figura 5.3, já não é mais possível definir-se uma região assintótica que permita a determinação de Vm e, por consequência, de Km. Nesse caso, pode-se obter os parâmetros cinéticos por tranformação da função hiperbólica de Michaelis-Mentem para uma função linear correlata, sucedendo-se o ajuste linear dos dados transformados para a obtenção dos parâmetros de catálise.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Enzimas</span>"
    ]
  },
  {
    "objectID": "enzimas.html#linearizações-e-ajustes",
    "href": "enzimas.html#linearizações-e-ajustes",
    "title": "5  Enzimas",
    "section": "5.2 Linearizações e ajustes",
    "text": "5.2 Linearizações e ajustes\n      Diversas são as linearizações encontradas na literatura para a equação de Michaelis-Mentem. Para exemplificá-las, segue um trecho de código contendo as quatro mais empregadas. Para isso utilizou-se um par de funções do R para, respectivamente, estabelecer a área gráfica e sua subdivisão para plotagem em 4 paineis (par e mfrow ou mfcol):\n\nS &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20)  # cria um vetor para substrato\nKm &lt;- 0.5\nVm &lt;- 10  # estabelece os parâmetros enzimáticos\nv &lt;- Vm * S/(Km + S)  # aplica a equação de MM ao vetor de S\npar(mfrow = c(2, 2))  # estabelece área de plot pra 4 gráficos\nplot(S, v, type = \"o\", main = \"Michaelis-Mentem\")\nplot(1/S, 1/v, type = \"o\", main = \"Lineweaver-Burk\")\nplot(v, v/S, type = \"o\", main = \"Eadie-Hofstee\")\nplot(S, S/v, type = \"o\", main = \"Hanes-Woolf\")\nlayout(1)  # volta à janela gráfica normal\n\n\n\n\n\n\n\nFigura 5.4: Principais linearizações da equação de Michaelis-Menten.\n\n\n\n\n\n      Dentre essas transformações lineares para cinética enzimática, as mais frequentemente encontradas são de Lineweaver-Burk (ou duplo-recíproco), e a de Eadie-Hofstee, sendo a primeira a mais comum na literatura. No entanto, a aplicação do formalismo de Eadie-Hofstee para interação ligante-proteína também é a mais reportada nessa área, embora seja tratada como representação de Scatchard (Scatchard 1949).\n\n5.2.1 Linearização por transformação de Lineweaver-Burk\n      A forma linear para a equação de Linewaver-Burk é obtida a partir da transformação da equação de Michaelis-Menten que segue:\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km}{Vm}*\\frac{1}{S}\n\\tag{5.4}\\]\n      Dessa forma, os dados obtidos pela Figura 5.3 são transformados para seu duplo-recíproco, resultando em:\n\nS &lt;- seq(0.1, 1, length.out = 20)  # gera uma sequência com 20 pontos entre\n# 0 e 1 para valores de substrato\nVm &lt;- 10\nKm &lt;- 0.5  # parâmetros cinéticos\nset.seed(1500)  # estabelecer a mesma semente aleatória do gráfico direto\n# de Michaelis-Menten, para reproducibilidade dos pontos\nerro &lt;- runif(20, 0, 1)  # comando para erro uniforme (no. de pontos, min, max)\nv &lt;- Vm * S/(Km + S) + erro  # equação de Michaelis-Menten\n\ninv.S &lt;- 1/S  # cria variáveis para o duplo-recíproco\ninv.v &lt;- 1/v\nplot(inv.v ~ inv.S, xlab = \"1/S\", ylab = \"1/v\")  # elabora o gráfico de\n# Lineweaver-Burk\n\n\n\n\n\n\n\nFigura 5.5: Representação de Lineweaver-Burk para os dados simulados da curva de Michaelis-Menten.\n\n\n\n\n\n      Observe que a Figura 5.5 apresenta agora um uma distribuição de valores que possibilita seu ajuste linear por mínimos quadrados (regressão linear). No R, isso pode ser facilmente conduzido pelo trecho de código (chunk) que segue:\n\nreg.LB &lt;- lm(inv.v ~ inv.S)  # expressão para ajuste linear\nsummary(reg.LB)  # resultados do ajuste\n\n\nCall:\nlm(formula = inv.v ~ inv.S)\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-0.028198 -0.009858 -0.003496  0.007482  0.028416 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 0.113634   0.005147   22.08 1.74e-14 ***\ninv.S       0.032772   0.001461   22.42 1.33e-14 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.01459 on 18 degrees of freedom\nMultiple R-squared:  0.9654,    Adjusted R-squared:  0.9635 \nF-statistic: 502.8 on 1 and 18 DF,  p-value: 1.325e-14\n\nplot(inv.v ~ inv.S, xlab = \"1/S\", ylab = \"1/v\")  # gráfico de Lineweaver-Burk\nabline(reg.LB, col = \"blue\")  # sobreposição do ajuste ao gráfico\n\n\n\n\n\n\n\nFigura 5.6: Ajuste linear para os dados de Lineweaver-Burk.\n\n\n\n\n\n      A tabela produzida pelo R para a função lm de ajuste linear por mínimos quadrados possui diversas informações que nos permite avaliar a qualidade da regressão. Brevemente, esse tabela nos fornece o valor de cada parâmetro do ajuste conforme a equação que segue:\n\\[\ny = a + b *x\n\\tag{5.5}\\]\n      Nesse caso, a refere-se ao intercepto presente na tabela ((intercept), ou 1/Vm) e b à inclinação (inv.S, ou Km/Vm). Além disso, a tabela também fornece diversos resultados complentares, elencados a seguir:\n\nvalor de erro-padrão dos parâmetros (Std. Error);\nvalor da distribuição t de Student (t value);\no respectivo nível de probabilidade (Pr) com indicação de significância (asteriscos);\nerro padrão residual (Residual standard error);\nvalor dos coeficientes de determinação bruto (Multiple R-squared) e ajustado para os graus de liberdade (Adjusted R-squared);\nvalor da distribuição F de Snedocor (F-statistic) de variância do ajuste;\ngraus de liberdade (DF) e o valor de significância da regressão ao modelo linear obtido pela análise de variância (p-value).\n\n      Não obstante, a qualidade do ajuste linear também pode ser verificada pela produção de gráficos diagnósticos estatísticos, bastando-se aplicar o trecho simples abaixo:\n\nplot(reg.LB)  # comando para geração de gráficos diagnósticos de ajuste linear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      Esses gráficos diagnósticos também podem ser alocados em paineis, como ilustrado para as linearizações de Michaelis-Mentem acima.\n\nreg.LB &lt;- lm(inv.v ~ inv.S)\npar(mfrow = c(2, 2))\nplot(reg.LB)\nlayout(1)\n\n\n\n\n\n\n\nFigura 5.7: Gráficos diagnósticos de ajuste linear.\n\n\n\n\n\n      Os quatro gráficos gerados acima referem-se, respectivamente, 1) à variação de resíduos com os valores ajustados, 2) a um teste de distribuição normal dos resíduos, 3) à variação de resíduos padronizados em função dos valores ajustados, e 4) à observação de valores influenciáveis identificáveis pela distância de Cook para cada observação. Em relação à esse último, pode-se opcionalmente definir sua aparência para identificação daqueles valores por seleção (which, 4 ou 6, por ex), tal como em:\n\nplot(reg.LB, which = 4)\n\n\n\n\n\n\n\n\n      Por esses dois procedimentos, tabela e gráficos diagnósticos, é possível aferir a qualidade de um ajuste linear pelo R. Em paralelo, diversas são as funções associadas à própria função lm para modelos lineares (objetos), o que reforça o caráter de linguagem orientada a objeto do R. Entre essas vale citar, com significado intuitivo, coef, fitted, predict, residuals, confint, e deviance.\n      Para acessar os parâmetros contidos na função lm, assim como outras de mesma natureza no R, basta digitar args:\n\nargs(lm)\n\nfunction (formula, data, subset, weights, na.action, method = \"qr\", \n    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n    contrasts = NULL, offset, ...) \nNULL\n\n\n      Complementarmente, vale mencionar a existência de inúmeros pacotes do R para diversas situações e tratamentos estatísticos de dados para modelos lineares, e que fogem ao escopo deste manuscrito, tais como os que possibilitam análises de outliers (valores extremos), Generalized Linear Models, Mixed Effects Models, Non-parametric Regression, entre outros. Entre os pacotes do R complementares para regressão linear vale mencionar car, MASS, caret, glmnet, sgd, BLR, e Lars.\n\n5.2.1.1 Considerações sobre a linearização por Lineweaver-Burk.\n      De volta ao estudo da cinética de estado estacionário da catálise enzimática, mencionamos acima a possibilidade de linearizações da equação de Michaelis-Mentem por dois tratamentos mais comuns, Lineweaver-Burk e Eadie-Hofstee. De modo geral, qualquer tratamento que resulte na transformação de um modelo original (equação de Michaelis-Menten, no caso) por linearização resultará em desvios estatísticos.\n      Analisando a equação de Lineweaver-Burk, por exemplo, pode-se evidenciar que, como os valores de S e v estão representados por seus recíprocos, uma pequena variação em v resultará numa grande variação em 1/v. Por outro lado, a escolha da faixa de teores de S também é extremamente importante para a extração de parâmetros cinéticos. Isso pode ser ilustrado no exemplo que segue:\n\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500)  # semente fixa para erro aleatório\nerro &lt;- runif(length(S), 0, 0.1)\nS &lt;- seq(1, 10, 0.1)\nv &lt;- Vm * S/(Km + S) + erro\n\nWarning in Vm * S/(Km + S) + erro: longer object length is not a multiple of\nshorter object length\n\nplot(v ~ S, xlab = \"S\", ylab = \"v\")\n\n\n\n\n\n\n\nFigura 5.8: Curva de Michaelis-Mentem simulada com erro experimental aleatório. Vm=10; Km=0.5.\n\n\n\n\n\n      Observe que a Figura 5.8 inicia em velocidade próxima a zero, e termina em velocidade próxima à Vm, com teor de S &gt;&gt; Km (50 vezes, de fato). Essa condição permite uma extração segura dos parâmetros cinéticos, os quais podem ser obtidos a partir do ajuste linear do gráfico duplo-recíproco.\n\n# Chunk para Lineweaver-Burk\nset.seed(1500)  # semente fixa para erro aleatório\nerro &lt;- runif(length(S), 0, 0.2)\nVm &lt;- 10\nKm &lt;- 0.5  # parâmetros cinéticos\ninv.S &lt;- 1/seq(1, 10, 0.1)  # 1/S\ninv.v &lt;- 1/(Vm * S/(Km + S) + erro)  # 1/v\nplot(inv.S, inv.v)\nlm.LB2 &lt;- lm(inv.v ~ inv.S)  # ajuste linear\nsummary(lm.LB2)  # resultados do ajuste\n\n\nCall:\nlm(formula = inv.v ~ inv.S)\n\nResiduals:\n       Min         1Q     Median         3Q        Max \n-0.0015050 -0.0005613 -0.0001463  0.0007522  0.0014122 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 0.0991811  0.0001356   731.3   &lt;2e-16 ***\ninv.S       0.0481555  0.0004193   114.9   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.0007741 on 89 degrees of freedom\nMultiple R-squared:  0.9933,    Adjusted R-squared:  0.9932 \nF-statistic: 1.319e+04 on 1 and 89 DF,  p-value: &lt; 2.2e-16\n\nabline(lm.LB2, col = \"blue\")\n\n\n\n\n\n\n\nFigura 5.9: Lineweaver-Burk dos dados do gráfico anterior.\n\n\n\n\n\n      Perceba como os valores de Vm e Km ajustados aproximaram-se dos valores preditos, já que para o gráfico duplo-recíproco:\n\\[\nVm=\\frac{1}{intercepto} ;\n\\\\\nKm = intercepto * Vm\n\\tag{5.6}\\]\n      Agora, o que aconteceria se os pontos experimentais estivessem em faixas distintas de teores de S ? Exemplificando, se os pontos fossem coletados em três regiões distintas de S: 10-100, 30-100, e 50-100 ?\nIsso pode ser ilustrado variando-se a faixa de valores de S iterativamente, e inspecionando-se o gráfico duplo-recíproco resultante como no trecho de código que segue, e para os mesmos valores da Figura 5.9.\n\n# Chunk para duplos-recíprocos de dados simulados com variação em [S]\n\nset.seed(1500)  # mesma semente aleatória para reproducibilidade de erro\nVm &lt;- 10\nKm &lt;- 0.5  # estabelece os parâmetros de MM\nS &lt;- seq(10, 100, 10)  # cria-se uma sequência inicial para S\nv &lt;- Vm * S/(Km + S)  # aplicação equação de MM à S\nplot(1/S, 1/v, type = \"n\", ylim = c(0.098, 0.106))  # elabora o\n# duplo-recíproco sem pontos inicia a iteração para gráficos de Lineweaver-Burk\nfor (i in 1:3) {\n    S &lt;- seq(10 * i, 100, length.out = 100)  # gera uma sequência S com\n    # 100 pontos, produzindo 5 vetores que iniciam em valores diferentes para S\n    # (10, 30 e 50)\n    erro &lt;- runif(length(S), 0, 0.1)  #  erro para adição à vetor de \n    # velocidade inicial, com no. de pontos em função do vetor de S\n    add &lt;- if (i == 1)\n        FALSE else TRUE  # controle de fluxo para plotagem\n    # de pontos no gráfico vazio\n    inv.S &lt;- 1/S\n    inv.v &lt;- 1/((Vm * S/(Km + S)) + erro)  # novos valores para o \n    # duplo-recíproco em função da iteração\n    points(inv.v ~ inv.S, xlab = \"1/S\", ylab = \"1/v\", col = i, add = add)\n    # adição de pontos ao gráfico de Lineweaver-Burk, com identificação por\n    # cores (1, 2, 3, 4 e 5)\n    lm.LB &lt;- lm(inv.v ~ inv.S)  # elabora o ajuste linear\n    abline(lm.LB, col = i, lty = i)  # sobrepõe as linhas de ajuste\n}\n\n\n\n\n\n\n\nFigura 5.10: Gráficos duplo-recíproco para a curva simulada de Michaelis-Menten, para distintos teores de S inicial.\n\n\n\n\n\n      Observe agora que pela Figura 5.10 resultante, tanto o intercepto como a inclinação obtidos a partir dos ajustes foram dependentes da faixa de seleção de S, o que resulta em distintos valores para Vm e Km. Isto mostra como a seleção da faixa de S para o cálculo de Km e Vm é crucial.\n\n\n\n5.2.2 Linearização por transformação de Eadie-Hofstee\n      Como já mencionado, as duas linearizações da equação de Michaelis-Menten mais comuns referem-se à do subtítulo acima. A equação de linearização de Eadie-Hosftee é dada abaixo:\n\\[\nv = \\frac{1}{Km} * \\frac{v}{S} + Vm\n\\tag{5.7}\\]\n      A partir dos dados da Figura 5.3 obtém-se os parâmetros cinéticos diretamente do intercepto (Vm) e da inclinação linear (1/Km) por:\n\n# Linearização por Eadie-Hofstee\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500)  # semente fixa para erro aleatório\nerro &lt;- runif(length(S), 0, 0.1)\nS &lt;- seq(1, 10, 0.1)\nv &lt;- Vm * S/(Km + S) + erro\nv.S &lt;- v/S\nplot(v.S ~ v, xlab = \"v\", ylab = \"v/S\")\n\nlm_EH &lt;- lm(v.S ~ v)\nsummary(lm_EH)\n\n\nCall:\nlm(formula = v.S ~ v)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.11602 -0.06496  0.01172  0.05466  0.12483 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 20.31073    0.07906   256.9   &lt;2e-16 ***\nv           -2.02191    0.00893  -226.4   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.07036 on 98 degrees of freedom\nMultiple R-squared:  0.9981,    Adjusted R-squared:  0.9981 \nF-statistic: 5.126e+04 on 1 and 98 DF,  p-value: &lt; 2.2e-16\n\nabline(lm_EH, col = \"blue\")\n\n\n\n\n\n\n\n\n\n\n5.2.3 Distribuição de erros nas linearizações de Michaelis-Mentem\n      Embora ambas as representações, Lineweaver-Burk e Eadie-Hofstee, sejam as mais utilizadas e apresentem semelhança na obtenção dos parâmetros cinéticos, sua distribuição de resíduos é bem distinta, assim como as demais transformações lineares de Michaelis-Mentem (Figura 5.4).\n      O código abaixo ilustra a distribuição de erros dessas transformações, introduzindo uma função importante do R para construção de gráficos com barras de erros: arrows.\n\n# Erros aleatórios na eq. de MM e linearizações\n\nVm &lt;- 10\nKm &lt;- 0.5  # fixa os parâmetros de MM\nset.seed(1500)  # fixa semente para erro aleatório\nerro &lt;- runif(length(S), 0, 0.5)  # vetor de erro uniforme\nS &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20)  # vetor de substrato\nv &lt;- Vm * S/(Km + S)  # equação de MM\npar(mfrow = c(2, 2))  # área de plot pra 4 gráficos\nplot(S, v, type = \"o\", main = \"Michaelis-Mentem\")\narrows(S, v, S, v - erro, length = 0.05, angle = 90)  # barra inferior de erro\narrows(S, v, S, v + erro, length = 0.05, angle = 90)  # barra superior de erro\n\nplot(1/S, 1/v, type = \"o\", main = \"Lineweaver-Burk\")\narrows(1/S, 1/v, 1/S, 1/(v - erro), length = 0.05, angle = 90)\narrows(1/S, 1/v, 1/S, 1/(v + erro), length = 0.05, angle = 90)\n\nplot(v, v/S, type = \"o\", main = \"Eadie-Hofstee\")\narrows(v, v/S, v, (v - erro)/S, length = 0.05, angle = 90)\narrows(v, v/S, v, (v + erro)/S, length = 0.05, angle = 90)\n\nplot(S, S/v, type = \"o\", main = \"Hanes-Woolf\")\narrows(S, S/v, S, S/(v - erro), length = 0.05, angle = 90)\narrows(S, S/v, S, S/(v + erro), length = 0.05, angle = 90)\n\npar(mfrow = c(1, 1))  # retorno à janela gráfica normal\n\n\n\n\n\n\n\nFigura 5.11: Distribuição de erros aleatórios para a equação de Michaelis-Mentem e suas transformações lineares.\n\n\n\n\n\n      Pelo gráfico da Figura 5.11 fica evidente que as transformações de Lineweaver-Burk e de Eadie-Hofstee, ainda que tenham prevalência na literatura, são as que apresentam a maior variabilidade de erro a partir dos dados experimentais, o que converge para uma menor precisão na determinação de parâmetros cinéticos. Além disso, observa-se que a transformação de Hanes-Woolf é a que apresenta a menor dispersão de resíduos entre as demais, igualando-se aos erros experimentais da equação hiperbólica de Michaelis-Mentem. Apesar disso, a linearização de Hanes-Woolf é muito pouco reportada na literatura.\n      Ainda que a representação dos duplos-recíprocos tenha em si algumas desvantagens, tais como a dispersão de erros principalmente em valores baixos de S, é a única dentre as mencionadas que permite um ajuste linear por mínimos quadrados, se considerarmos as premissas estatísticas desse.\n      Para que se possa obter parâmetros de intercepto e inclinação a partir de uma regressão linear, é necessário que se cumpra as premissas estatísticas de 1) distribuição normal de resíduos, 2) homogeneidade de variâncias, e 3) independência das variáveis. Se observarmos as três linearizações, tanto a de Eadie-Hofstee como a de Hanes-Woolf não cumprem a premissa de independência, já que a variável dependente (y) é função da independente (x).\n      Para que uma transformação por duplos-recíprocos possa ser utilizada mais fielmente à obtenção de parâmetros cinéticos, contudo, pode-se adotar o cômputo de peso na fórmula de ajuste linear, tal como sugerido por Wilkinson (Wilkinson 1961), considerando-o como o recíproco das variâncias estimadas. Nesse caso, o ajuste linear considerando o quadrado do vetor de erros aleatórios como variância e o peso como seu recíproco (1/s²), pode ser esboçado como:\n\n# Regressão linear ponderada de Lineweaver-Burk\n\nS &lt;- seq(0.1, 1, length.out = 20)\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500)\nerro &lt;- runif(20, 0, 1)\nv &lt;- Vm * S/(Km + S) + erro\ninv.S &lt;- 1/S\ninv.v &lt;- 1/v\nreg.LB.peso &lt;- lm(inv.v ~ inv.S, weights = 1/erro^2)  # expressão para\n# ajuste linear\nsummary(reg.LB.peso)  # resultados do ajuste\n\n\nCall:\nlm(formula = inv.v ~ inv.S, weights = 1/erro^2)\n\nWeighted Residuals:\n     Min       1Q   Median       3Q      Max \n-0.04779 -0.02231 -0.01849  0.00162  0.04830 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 0.117327   0.002545   46.11  &lt; 2e-16 ***\ninv.S       0.034906   0.001452   24.04 3.93e-15 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.02967 on 18 degrees of freedom\nMultiple R-squared:  0.9698,    Adjusted R-squared:  0.9681 \nF-statistic:   578 on 1 and 18 DF,  p-value: 3.932e-15\n\n\n      Ainda que os ajustes tenham sido realizados para valores com baixa variabilidade de erros uniformes, uma comparação entre esse resultado e o da Figura 5.6 revela ligeira superioridade para o primeiro, com maior valor para o coeficiente de determinação R², menor para p-valor, e menores para o erro-padrão das estimativas.\n      Complementarmente, pode-se obter uma comparação estatística entre o modelo linear simples e o que adotou o peso estatístico por:\n\nanova(reg.LB, reg.LB.peso)\n\nAnalysis of Variance Table\n\nModel 1: inv.v ~ inv.S\nModel 2: inv.v ~ inv.S\n  Res.Df       RSS Df Sum of Sq F Pr(&gt;F)\n1     18 0.0038295                      \n2     18 0.0158493  0  -0.01202",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Enzimas</span>"
    ]
  },
  {
    "objectID": "enzimas.html#ajuste-não-linear",
    "href": "enzimas.html#ajuste-não-linear",
    "title": "5  Enzimas",
    "section": "5.3 Ajuste não-linear",
    "text": "5.3 Ajuste não-linear\n      Ainda que linearizações sejam frequentemente utilizadas mesmo hoje em dia, principalmente para discernir entre modelos cinéticos distintos, a determinação precisa dos parâmetros de catálise é contudo melhor conduzida por ajuste ou regressão não-linear. Esse ajuste tem por objetivo a determinação de parâmetros de uma equação (Vm e Km, no caso) sem a necessidade de qualquer transformação dos dados, eliminando por essa razão os erros associados.\n      O ajuste não-linear difere do linear em algumas características, tais como:\n\nA busca iterativa de um valor mínimo (local ou global) para a soma dos quadrados dos erros das estimativas;\na necessidade de um valor inicial para os parâmetros (sementes);\na linearidade nos erros e no gradiente da função sobre os parâmetros.\na necessidade de algoritmo mais sofisticado para solução simbólica e matricial para minimizar a derivada da função sobre cada parâmetro;\na necessidade de programa que trabalhe com álgebra matricial (computador, dispositivo móvel ou calculadora);\no uso de algoritmos mais sofisticados (Gauss, Newton-Raphson, Levenberg-Marquadt, Simplex).\n\no emprego da equação original do modelo, por vezes de difícil linearização.\n\n\n5.3.1 Ajuste não-linear da equação de Michaelis-Mentem\n      Para uma regressão não-linear da equação de Michaelis-Mentem reproduzindo-se a simulação exemplificada na Figura 5.3:\n\n# Regressão não linear para simulação de eq. de MM\n\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500)\nerro &lt;- runif(20, 0, 1)\nS &lt;- seq(0, 1, length.out = 20)\nv &lt;- Vm * S/(Km + S) + erro\ndat.Sv &lt;- data.frame(S, v)  # criação de planilha com S e v\nplot(v ~ S, type = \"p\", from = 0, to = 1, n = 20, xlab = \"[S}\", ylab = \"v\")  # construção do gráfico de MM\n\nnl.MM &lt;- nls(v ~ Vm * S/(Km + S), start = list(Vm = 7, Km = 0.2), data = dat.Sv)  # linha de código para ajuste não linear\nlines(S, fitted(nl.MM), col = \"red\")  # sobreposição da linha\n\n\n\n\nAjuste não linear para a simulação experimental da equação de Michaelis-Menten.\n\n\n\n# ajustada\nsummary(nl.MM)  # sumário dos resultados\n\n\nFormula: v ~ Vm * S/(Km + S)\n\nParameters:\n   Estimate Std. Error t value Pr(&gt;|t|)    \nVm  9.75490    0.52114  18.718 3.01e-13 ***\nKm  0.36979    0.05015   7.373 7.68e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.3514 on 18 degrees of freedom\n\nNumber of iterations to convergence: 5 \nAchieved convergence tolerance: 1.64e-06\n\n\n      Observe agora pela tabela de sumário do ajuste que os parâmetros são fornecidos diretamente, sem necessidade de transformação, como no ajuste linear. A tabela diferencia-se do sumário de ajuste linear por apresentar o número de iterações para convergência, e o valor de convergência para tolerância. Contudo, não apresenta o coeficiente de determinação R², mas somente o erro padrão residual. Ainda que a discussão esteja longe da proposta desta obra, alguns autores declinam do emprego de R² em regressão não-linear pelo mesmo ser decorrente de relações lineares entre os parâmetros, o que não ocorre no caso.\n      Assim como para ajuste linear, os parâmetros que abrangem a função nls envolvem:\n\nargs(nls)\n\nfunction (formula, data = parent.frame(), start, control = nls.control(), \n    algorithm = c(\"default\", \"plinear\", \"port\"), trace = FALSE, \n    subset, weights, na.action, model = FALSE, lower = -Inf, \n    upper = Inf, ...) \nNULL\n\n\n      Além do pacote incluido na distribuição básica do R e que permite ajustes não-lineares (stats), existem diversos outros que permitem ajustes com algoritmos, avaliações e plotagens variadas, tais como nlme (mixed-effects), nlrwr, nlstools, nls2, nls.multstart, minpack.lm (algoritmo de Levenberg-Marquadt), nlshelper, e nlsLM.\n\n\n5.3.2 Algumas vantagens do modelo linear sobre o não-linear\n  Ainda que a estimativa de parâmetros de modelos não lineares seja mais precisa utilizando-se ajustes também não lineares, o algoritmo linear oferece algumas vantagems, entre as quais:\n\nÉ mais fácil, com algoritmo simplificado, e mesmo pelo uso de somatórias de algumas quantidades envolvendo x e y, sendo resolvido com calculadora científica simples, ou mesmo à mão;\né mais intuitivo visualmente, posto que o modelo final será sempre uma reta;\npossui apenas dois parâmetros na equação, intercepto e inclinação;\nrequer poucas medidas, já que uma reta se constroi com apenas dois pontos;\nnão requer sementes para estimativas iniciais o que, a depender do modelo não-linear, pode ser bem abstrato, culminando em mínimos locais ou mesmo na falta de solução para o ajuste;\npermite interpretação experimental quando há fuga da linearidade;\nindepende de um modelo físico específico;\nnão requer, por vezes, a necessidade de constrição de resultados (constraints), por exemplo instruindo o algoritmo a buscar uma estimativa obrigatoriamente de valor positivo para o parâmetro.\nrelações lineares e transformações são encontradas em inúmeros modelos físicos nas Ciências Naturais.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Enzimas</span>"
    ]
  },
  {
    "objectID": "enzimas.html#enzimas-alostéricas",
    "href": "enzimas.html#enzimas-alostéricas",
    "title": "5  Enzimas",
    "section": "5.4 Enzimas alostéricas",
    "text": "5.4 Enzimas alostéricas\n      A alosteria constitui um dos principais recursos da metabolismo para a regulação dos níveis de compostos celulares. De etiologia grega (allos = outro, stereos = estrutura), uma enzima alostérica é aquela que altera seu perfil catalítico em função de transições conformacionais mediadas por moléculas que interagem fora de seu sítio ativo, sejam elas substrato, coenzimas, ou outros compostos (Traut 2007). O efeito resultante constitui em uma modulação da atividade enzimática, quer ativando-a ou inibindo-a. Enzimas alostérica comportam-se portanto como enzimas regulatórias em uma rota metabólica, e cuja atividade pode ser modulada em função de retroinibição ou inibição por feedback, bem como por ativação pelo precursor (Leone 2021).\n      A equação que define uma enzima alostérica em função do teor de seu substrato dada abaixo:\n\\[\nv=\\frac{Vm*S^n}{(Km^n+S^n)}\n\\tag{5.8}\\]\nOnde nH representa o coeficiente de cooperatividade ou constante de Hill para a ligação com moléculas de S (de maneira similar à ligação de \\(O_{2}\\) à hemoglobina. De modo geral, o valor de nH pode ser inferior à unidade (cooperatividade negativa) ou superior a essa (cooperatividade positiva). Para ilustrar o comportamento cinético de uma enzima alostérica, segue o trecho abaixo, que também introduz outro formato para representar curvas no R nomeando a variável independente (x).\n\n# Gráfico para enzima alostérica\n\nv &lt;- function(S, Vm = 10, Km = 3, nH = 2) {\n    Vm * S^nH/(Km^nH + S^nH)\n}\ncurve(v, from = 0, to = 10, n = 100, xlab = \"S\", ylab = \"v\", bty = \"L\")  # eixos em L\n\n\n\n\nGráfico do Michaelis-Mentem para uma enzima alostérica\n\n\n\n\n  Interessante também observar como o perfil enzimático alostérico se define frente à variação do coeficiente nH.\n\n# Influência da constante de Hill (nH) sobre uma enzima alostérica\n\nnH &lt;- seq(from = 0.1, to = 3, length.out = 7)  # sequência para 7 valores de nH\nfor (i in 1:length(nH)) {\n    # loop para adicionar curva alostérica a cada valor de nH\n    add &lt;- if (i == 1)\n        FALSE else TRUE  # controle de fluxo\n    v &lt;- function(S, Vm = 10, Km = 3, a = nH[i]) {\n        Vm * S^a/(Km^a + S^a)\n    }\n    curve(v, from = 0, to = 4, n = 500, col = i, xlab = \"S\", ylab = \"v\", bty = \"L\",\n        add = add)\n}\narrows(0, 5, 3, 2, length = 0.1, angle = 45, col = \"blue\")  # seta para nH\ntext(0.5, 5.2, \"nH\", col = \"blue\")  # indexador para nH\n\n\n\n\nPerfil alostérico de uma enzima sob variação do coeficiente de cooperatividade nH.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Enzimas</span>"
    ]
  },
  {
    "objectID": "enzimas.html#inibição-enzimática",
    "href": "enzimas.html#inibição-enzimática",
    "title": "5  Enzimas",
    "section": "5.5 Inibição Enzimática",
    "text": "5.5 Inibição Enzimática\n      Capítulo vasto na enzimologia e com aplicação direta em Química, Farmacologia, Biotecnologia, Biomedicina e áreas afins, a inibição enzimática encontra-se no âmago dos fármacos, medicamentos e biosensores. Sob um ponto de vista simplificado, a atividade enzimática pode ser reduzida na presença de vários efetores, entre moléculas endógenas ou exógenas do metabolismo celular, incluindo o próprio substrato. Genericamente a inibição enzimática classifica-se como irreversível quando a ativide decai pela ligação covalente de um inibidor, ou reversível, quando há um equilíbrio de associação/dissociação com a macromolécula. A seguir serão ilustradas inibições reversíveis.\n\n5.5.1 Inibição pelo substrato\n      Uma inibição enzimática comum ao metabolismo é a protagonizada pelo próprio substrato em excesso no meio, sendo definida por:\n\\[\nv=\\frac{Vm*S}{S(1+\\frac{S}{Ks})+Km}\n\\tag{5.9}\\]\n      Dessa forma, o gráfico resultante de uma inibição por excesso de substrato pode ser reproduzido por:\n\n# Inibição por excesso de S\n\nS &lt;- seq(0, 10, 0.1)\nv_alos &lt;- function(S, Vm = 10, Km = 0.5, Ks = 2) {\n    Vm * S/(S * (1 + S/Ks) + Km)\n}\ncurve(v_alos, xlim = c(0, 10), xlab = \"S\", ylab = \"v\")\n\n\n\n\n\n\n\nFigura 5.12: Comportamento cinético de uma enzima inibida por excesso de substrato.\n\n\n\n\n\n      Percebe-se pela figura Figura 5.12 que a atividade da enzima alcança um limite sendo reduzida com o aumento do teor de substrato.\n\n\n5.5.2 Modelos de inibição enzimática\n      A inibição de enzimas por moléculas que não o próprio substrato pode ser representada por um diagrama no qual o efetor altera um dos elementos representados na Equação 5.1, tal como na figura abaixo.\n\n\n\n\n\n\n\nDiagrama representativo dos tipos de inibição enzimática. kcat: constante catalítica; Ki: constante de equilíbrio de dissociação do inibidor, com índices para inibição competitiva (Ki), incompetitiva (Kiu) e não competitiva (Kic e Kiu).\n\n\n\n\n      Nesse caso, pode-se definir os três tipos principais de inibição enzimática reversível como inibição competitiva, incompetitiva e não competitiva (pura ou mista). Em síntese, a inibição competitiva dá-se quando o inibidor complexa-se ao sítio ativo da enzima; a inibição incompetitiva, quando o inibidor interage com o complexo enzima-substrato; e a inibição não competitiva, quando o inibidor liga-se em outro local que não o sítio ativo da enzima, podendo ainda ser pura (Kiu = Kic) ou mista (Kiu &gt; ou &lt; Kic).\n      Um modelo matemático que abrange esses três tipos de inibição enzimática é descrito na equação abaixo:\n\\[\nv=\\frac{Vm*S}{Km(1+\\frac{I}{Kic})+S(1+\\frac{I}{Kiu})}\n\\tag{5.10}\\]\n      Dessa forma, a Equação 5.10 reduz-se em seus termos multiplicadores no denominador, em função do tipo de inibição enzimática presente, até o modelo primitivo de Michaelis-Mentem, quando na ausência do inibidor.\n\n\n5.5.2.1 Curva de Michaelis-Mentem para modelos de inibição enzimática\n      Podemos simular no R as cuvas michaelianas para modelos clássicos de inibição, considerando valores para as constantes de equilíbrio de dissociação dos inibidores como Kic = 0.2, e Kiu = 1, como no trecho de código abaixo.\n\n# Inibição clássica & Michaelis-Mentem\n\npar(mfrow = c(2, 2))  # divide a área de plotagem\nS &lt;- seq(0, 10, 0.1)  # geração de teores de S\ncontr &lt;- function(S, Vm = 10, Km = 0.5) {\n    Vm * S/(Km + S)\n}  # função de MM, sem inibição\ncurve(contr, xlim = c(0, 10), xlab = \"S\", ylab = \"v\", main = \"Competitiva\")\n# cuva controle; veja que o título tem que ser adicionado para o 1a. de par de\n# curvas, controle e inibição\n\n# Modelos de inibição:\n\n# Competitiva\ncomp.i &lt;- function(S, Vm = 10, Km = 0.5, I = 2, Kic = 0.2) {\n    Vm * S/(Km * (1 + I/Kic) + S)\n}\ncurve(comp.i, add = TRUE, col = \"red\", lty = 2)  # competitiva\n\n# Não competitiva pura\npura.i &lt;- function(S, Vm = 10, Km = 0.5, I = 2, Ki = 1) {\n    Vm * S/(Km * (1 + I/Ki) + S * (1 + I/Ki))\n}\ncurve(contr, xlim = c(0, 10), xlab = \"S\", ylab = \"v\", main = \"Não Compet. Pura\")\ncurve(pura.i, add = TRUE, col = \"red\", lty = 2)  # não competitiva pura (Kiu=Kic=Ki)\n\n# Não competitiva mista\nmista.i &lt;- function(S, Vm = 10, Km = 0.5, I = 2, Kic = 0.2, Kiu = 1) {\n    Vm * S/(Km * (1 + I/Kic) + S * (1 + I/Kiu))\n}\ncurve(contr, xlim = c(0, 10), xlab = \"S\", ylab = \"v\", main = \"Não Compet. Mista\")\ncurve(mista.i, add = TRUE, col = \"red\", lty = 2)  # não competitiva mista\n\n# Incompetitiva\nincomp.i &lt;- function(S, Vm = 10, Km = 0.5, I = 2, Kiu = 1) {\n    Vm * S/(Km + S * (1 + I/Kiu))\n}\ncurve(contr, xlim = c(0, 10), xlab = \"S\", ylab = \"v\", main = \"Incompetitiva\")\ncurve(incomp.i, add = TRUE, col = \"red\", lty = 2)  # incompetitiva\nlayout(1)  # retorna à janela gráfica original\n\n\n\n\n\n\n\nFigura 5.13: Curva de Michaelis-Mentem na presença de inibidores de comportamento clássico.\n\n\n\n\n\n      Perceba que para o modelo competitivo a velocidade limite Vm da reação tende a ser alcançada, já que a ocupação do sítio ativo da enzima é mutualmente exclusiva entre substrato e inibidor, privilegiando o primeiro quando em alto teor. Por outro lado, o valor de Vm não é tangível para os demais modelos de inibição, já que o inibidor se liga em outro sítio na enzima (não competitivo) ou ao próprio substrato (incompetitivo). Para visualizar alterações nos gráficos, experimente modificar os parâmetros da simulação (Vm, Km, Ki, Kic, Kiu, I).\n      Ainda que seja possível um discernimento do modelo competitivo dos demais, perceba também que isso só foi possível por uma simulação que empregou um teor S 20 vezes maior que o valor de Km da reação. Isso nem sempre é possível na prática, como elencado abaixo, já que o emprego de altos teores de S:\n\nAgrega maior custo financeiro ao ensaio.\nPode resultar em inibição por excesso de substrato.\nPode elevar a viscosidade do meio, reduzindo a taxa catalítica.\n\n      Percebe-se, da figura Figura 5.13 e das observações acima, a dificuldade em classificar o tipo de inibição enzimática baseado na observação direta de uma curva de Michaelis-Mentem.\n\n\n5.5.2.2 Diagnóstico de modelos de inibição enzimática por Lineweaver-Burk\n      As transformações lineares da equação de Michaelis-Mentem são muito úteis no diagnóstico visual de modelos de inibição. Nesse sentido, o emprego da linearização por duplos-recíprocos para esses modelos resutará nas equações de inibição que seguem:\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km(1+\\frac{I}{Kic})}{Vm}*\\frac{1}{S} \\quad ;\\,  competitivo\n\\tag{5.11}\\]\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km(1+\\frac{I}{Ki})}{Vm}*\\frac{1}{S(1+\\frac{I}{Ki})} \\quad ;\\,  puro\n\\tag{5.12}\\]\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km(1+\\frac{I}{Kic})}{Vm}*\\frac{1}{S(1+\\frac{I}{Kiu})} \\quad ;\\,  misto\n\\tag{5.13}\\]\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km}{Vm}*\\frac{1}{S(1+\\frac{I}{Kiu})} \\quad ;\\,  incompetitivo\n\\tag{5.14}\\]\n      Observe que os termos multiplicadores inseridos em S e Km na equação de duplo-recíproco apenas alteram seu formalismo apresentado Equação 5.4. Dessa forma, os modelos de inibição enzimática podem ser ilustrados pelo R junto à transformação de Lineweaver-Burk (ou qualquer outra), como abaixo.\n\n# Diagnóstico de inibição por Lineweaver-Burk\n\n\n# Substrato e Inibidor\nS &lt;- seq(0.1, 10, length = 10)  # cria um vetor para substrato\nI &lt;- 2  # concentração de inibidor\n\n# Parâmetros cinéticos:\nKm &lt;- 0.5\nVm &lt;- 10\nKic &lt;- 0.2\nKi &lt;- 0.2\nKiu &lt;- 1\n\n# Equações\nv &lt;- Vm * S/(Km + S)  # equação de MM\nv.comp &lt;- Vm * S/(Km * (1 + I/Kic) + S)  # competitivo\nv.puro &lt;- Vm * S/(Km * (1 + I/Ki) + S * (1 + I/Ki))\n# não competitivo puro\nv.misto &lt;- Vm * S/(Km * (1 + I/Kic) + S * (1 + I/Kiu))\n# não competitivo misto\nv.incomp &lt;- Vm * S/(Km + S * (1 + I/Kiu))\n\n# Gráficos\npar(mfrow = c(2, 2))  # área de plot pra 4 gráficos\n\nplot(1/S, 1/v, type = \"l\", main = \"Competitivo\", ylim = c(0, 2))\npoints(1/S, 1/v.comp, type = \"l\", col = \"red\")\nplot(1/S, 1/v, type = \"l\", main = \"Puro\", ylim = c(0, 5))\npoints(1/S, 1/v.puro, type = \"l\", col = \"red\")\nplot(1/S, 1/v, type = \"l\", main = \"Misto\", ylim = c(0, 2))\npoints(1/S, 1/v.misto, type = \"l\", col = \"red\")\nplot(1/S, 1/v, type = \"l\", main = \"Incompetitivo\", ylim = c(0, 1))\npoints(1/S, 1/v.incomp, type = \"l\", col = \"red\")\n\n\n\n\nDiagnóstico de modelos de inibição enzimática por Lineweaver-Burk.\n\n\n\nlayout(1)  # volta à janela gráfica normal\n\n      Agora a distinção de modelos de inibição se torna mais evidente pela linearização. Assim como mencionado para os modelos representados na equação direta de Michaelis-Mentem, pode-se variar os parâmetros cinéticos e experimentar a visualização dos duplos-recíprocos.\n      Novamente, ainda que a linearização permita um melhor diagnóstico do tipo de inibição presente, o ajuste não linear é mais adequado para a determinação das constantes de inibição (Ki’s), uma vez que não agrega os erros advindos das transformações lineares (embora a inserção de pesos estatísticos possa aliviar a imprecisão dos resultados).\n\n\n5.5.2.3 Ki & IC\\(_{50}\\)\n      A concentração inibitória a 50% do teor de inibidor, definida como IC\\(_{50}\\), pode ser determinada empiricamente sem o conhecimento dos parâmetros de catálise enzimática envolvidos. Para isso, basta se obter um valor de inibição relativa num ensaio a concentração fixa de S, variando-se o teor de inibidor. De fato, análogos ao IC\\(_{50}\\) existem em ampla gama nas Ciências Naturais, não envolvendo necessariamente qualquer informação cinética ou termodinâmica dos compostos envolvidos, mas tão somente a informação empírica do resultado. Exemplificando, os parâmetros DE\\(_{50}\\) (dose efetiva) ou DL\\(_{50}\\) (dose letal), e mesmo projeções de X\\(_{50}\\), tal como Tm (temperatura de desnaturação a 50%), e o valor de pKa em tampões (pH em que as espécies encontram-se 50% ionizadas/protonadas em solução).\n  No entanto, existe uma relação útil entre a constante de equilíbrio de dissociação do inibidor Ki e o valor de IC\\(_{50}\\) que permite sua permuta, desde que conhecido o modelo de inibição (Yung-Chi e Prusoff 1973). Generalizando para os modelos de inibição, pode-se definir uma equação geral pra relação de Cheng-Prusoff como:\n\\[\nIC_{50} = \\frac{(1+\\frac{S}{Km})}{(\\frac{1}{Kic})+(\\frac{1}{Km*Kiu})}\n\\tag{5.15}\\]\n      Exemplificando, para um modelo competitivo de inibição, onde Kiu é nulo:\n\\[\nIC_{50} = Kic(1+\\frac{S}{Km})\n\\tag{5.16}\\]\n   Como acima mencionado, o valor de IC\\(_{50}\\) pode ser obtido a partir de dados experimentais de inibição relativa (v/Vm, por ex) em diferentes concentrações de inibidor fixando um valor de S. Nesse caso, podemos ilustrar no R a obtenção de IC\\(_{50}\\), utilizando-se um ajuste não linear para a equação de quatro parâmetros que segue (curva de Rodbard, DeLean, Munson, e Rodbard (1978)).\n\\[\nativ. residual \\, \\% =\\frac{v}{Vm} = inf+\\frac{sup-inf}{1+log(\\frac{I}{IC_{50}})^{nH}})\n\\] {#eq:eqRodb}\n\n# Ajuste não-linear para curva de IC50\n\nlogI.nM &lt;- c(5.5, 5.2, 4.9, 4.6, 4.3, 3.7, 3.3, 3, 2.8)\n# conc. de I, em unidade log10\nativ.res &lt;- c(0.02, 0.07, 0.12, 0.22, 0.36, 0.53, 0.67, 0.83, 0.85)\n# ativ. residual, v/Vm\ndados &lt;- data.frame(logI.nM, ativ.res)  # criação do dataframe\nplot(ativ.res ~ logI.nM, dados)  # plot dos dados\nic50.fit &lt;- nls(formula(ativ.res ~ inf + (sup - inf)/(1 + (logI.nM/logIC50)^nH)),\n    algorithm = \"port\", data = dados, start = list(inf = 0, sup = 0.8, logIC50 = 4,\n        nH = 10), lower = c(inf = -Inf, sup = -Inf, logIC50 = 0, nH = -Inf))  # ajuste não linear\nsummary(ic50.fit)  # sumário do ajuste\n\n\nFormula: ativ.res ~ inf + (sup - inf)/(1 + (logI.nM/logIC50)^nH)\n\nParameters:\n        Estimate Std. Error t value Pr(&gt;|t|)    \ninf      -0.3211     0.2932  -1.095  0.32348    \nsup       1.1200     0.2311   4.847  0.00469 ** \nlogIC50   4.0807     0.2309  17.675 1.06e-05 ***\nnH        4.0540     1.7462   2.322  0.06792 .  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.02769 on 5 degrees of freedom\n\nAlgorithm \"port\", convergence message: relative convergence (4)\n\nlines(logI.nM, fitted(ic50.fit), col = \"blue\")  # linha ajustada\n\n\n\n\n\n\n\n# E para extrair o valor de IC50...\nIC50 &lt;- 10^(coef(ic50.fit)[3])  # extração do 3o. parâmetro da tabela \n# de ajuste, isto é: logIC50:\nIC50\n\n logIC50 \n12042.04 \n\n\n      Perceba que o parâmetro de logIC50 foi extraído da tabela de ajuste não linear pelo comando coef. Isto é muito útil quando desejamos utilizar um coeficiente obtido em cálculos automáticos (programáveis), como veremos mais adiante. Por ora, faz-se interessante apresentar o parâmetro de IC50 obtido de forma mais elegante.\n      Para isso, podemos utilizar duas funções do R para exprimir resultados quantitativos junto à caracteres (palavras, frases): print() e cat. O trecho de código abaixo ilustra esse output, e algumas diferenças.\n\ncat(\"Valor de IC50 (nM):\", IC50, \"\\n\")\n\nValor de IC50 (nM): 12042.04 \n\nprint(paste(\"Valor de IC50 (nM):\", IC50))\n\n[1] \"Valor de IC50 (nM): 12042.0403466162\"\n\n\n      Basicamente, print exibe aspas e indexa o nome da coluna, enquanto cat os omite. Em adição, pode-se perceber outra variação no formato de impressão entre os dois comandos pelo exemplo abaixo:\n\nprint(paste(\"teores:\", c(10, 25, 50)))\n\n[1] \"teores: 10\" \"teores: 25\" \"teores: 50\"\n\ncat(\"teores:\", c(10, 25, 50))\n\nteores: 10 25 50\n\n\n      Outra possibilidade no R é a de se reduzir o número de casas decimais apresentados. Nesse caso, pode-se utilizar o comando round.\n\nIC50 &lt;- 10^(coef(ic50.fit)[3])\nprint(paste(\"Valor de IC50 (nM):\", round(IC50, digits = 2)))\n\n[1] \"Valor de IC50 (nM): 12042.04\"\n\n# arredondamento para duas casas decimais\n\n      Mais uma vez, salienta-se a existência de alguns pacotes úteis do R para o cálculo de IC50, entre esse o pacote drc (dose-response curve).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Enzimas</span>"
    ]
  },
  {
    "objectID": "enzimas.html#diagnóstico-estatístico-de-inibição-enzimática",
    "href": "enzimas.html#diagnóstico-estatístico-de-inibição-enzimática",
    "title": "5  Enzimas",
    "section": "5.6 Diagnóstico estatístico de inibição enzimática",
    "text": "5.6 Diagnóstico estatístico de inibição enzimática\n      Em paralelo à inspeção visual dos gráficos de linearização para inibição enzimática, é possível validar-se um modelo sobre outro por uma análise de dispersão de erros dos modelos. Mas também é possível o emprego da função BIC ou da função AIC do R, e que respectivamente calculam valores para o Critério de Informação Bayseiano (Spiess e Neumeyer 2010) ou do Critério de Informação de Akaike (Akaike 1974). Em comum esse parâmetros calculam um valor relativo de informação não computada por um modelo avaliado. O menor valor encontrado para ambos espelha a solução do melhor modelo de ajuste.\n      Matematicamente, BIC e AIC podem ser expressos como:\n\\[\nBIC = p*ln(n)-2*ln(RSE)\\\\\n\\\\\nAIC = n*ln(\\frac{RSE}{n})+2k+[\\frac{2k(k+1)}{n-k-1}])\\\\\n\\tag{5.17}\\]\nOnde p representa o no. de parâmetros do modelo, n o número total de pontos experimentais, k o fator p+1, e RSE o valor da soma dos quadrados dos resíduos (residual sum squares).\n      Para exemplificar o uso desses parâmetros de qualidade do modelo estatístico, pode-se empregar um conjunto de dados contido no pacote nlstools, provendo o ajuste, plotagem, inspeção de resíduos, e aplicação de BIC e AIC:\n\n# Aplicação de critérios de informação para ajuste de curvas cinéticas\n\nlibrary(nlstools)\n\n\n'nlstools' has been loaded.\n\n\nIMPORTANT NOTICE: Most nonlinear regression models and data set examples\n\n\nrelated to predictive microbiolgy have been moved to the package 'nlsMicrobio'\n\ncomp &lt;- nls(compet_mich, vmkmki, list(Km = 1, Vmax = 20, Ki = 0.5))\n# ajuste competitivo, com dados, equação e sementes fornecidas pelo pacote\n# nlstools\nplotfit(comp, variable = 1)  # comando de plotagem do pacote\n\n\n\n\n\n\n\nsummary(comp)\n\n\nFormula: v ~ S/(S + Km * (1 + I/Ki)) * Vmax\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \nKm    15.2145     2.5005   6.085 5.79e-08 ***\nVmax  18.0557     0.6288  28.713  &lt; 2e-16 ***\nKi    22.2822     4.9060   4.542 2.30e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.603 on 69 degrees of freedom\n\nNumber of iterations to convergence: 11 \nAchieved convergence tolerance: 5.116e-06\n\nres_comp &lt;- nlsResiduals(comp)  # resíduos do ajuste\nplot(res_comp, which = 1)  # plotagem de resíduos\n\n\n\n\n\n\n\nnoncomp &lt;- nls(non_compet_mich, vmkmki, list(Km = 1, Vmax = 20, Ki = 0.5))\n# o mesmo que acima, mas para o modelo não competitivo\nplotfit(noncomp, variable = 1)\n\n\n\n\n\n\n\nsummary(noncomp)\n\n\nFormula: v ~ S/((S + Km) * (1 + I/Ki)) * Vmax\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \nKm    22.7787     1.4738   15.46   &lt;2e-16 ***\nVmax  20.5867     0.4306   47.80   &lt;2e-16 ***\nKi   101.3563     7.3303   13.83   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.8925 on 69 degrees of freedom\n\nNumber of iterations to convergence: 7 \nAchieved convergence tolerance: 8.27e-06\n\nres_noncomp &lt;- nlsResiduals(noncomp)\nplot(res_noncomp, which = 1)\n\n\n\n\n\n\n\nBIC(comp, noncomp)  # Critério de informação de Baysean\n\n        df      BIC\ncomp     4 286.2994\nnoncomp  4 201.9981\n\nAIC(comp, noncomp)  # Critério de informação de Akaike\n\n        df      AIC\ncomp     4 277.1928\nnoncomp  4 192.8915\n\n\n      Pode-se observar na comparação dos ajustes não lineares que o modelo não competitivo ajustou-se melhor que o modelo competitivo (valores menores para BIC e AIC)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Enzimas</span>"
    ]
  },
  {
    "objectID": "enzimas.html#cinética-de-estado-pré-estacionário",
    "href": "enzimas.html#cinética-de-estado-pré-estacionário",
    "title": "5  Enzimas",
    "section": "5.7 Cinética de estado pré-estacionário",
    "text": "5.7 Cinética de estado pré-estacionário\n      Existem basicamente três tipos de comportamentos cinéticos para as enzimas: comportamento de Henry-Michaelis-Mentem-Briggs-Haldane, sucintamente denominado por michaeliano ou de estado estacionário (steady-state), comportamento de fase lag (quando o substrato leva algum tempo para ser convertido em produto), e comportamento de burst, transiente, ou de estado pré-estacionário (quando uma fase com rápida liberação de produto precede o estado estacionário). Algumas enzimas trabalham seguindo a cinética de burst, entre as quais algumas nucleosidades e glicosidases, e dehalogenases Tang et al. (2003).\n      A cinética de estado pré-estacionário segue um formalismo um pouco distinto, e que depende do quantitativo de etapas reacionais. Exemplificando abaixo para uma reação de 3 etapas (Johnson 1992):\n\\[\nE+S \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{km1} \\end{array}\nE*S\n\\begin{array}{c}\n_{k2}\\\\\n\\rightleftharpoons\\\\\n^{km2} \\end{array}\nE*P\n\\begin{array}{c}\n_{k3}\\\\\n\\rightarrow \\\\\n  ^{}\\end{array}\nE+P\n\\tag{5.18}\\]\n      Nesse caso, as equações derivadas das observações experimentais, e que conduzem à determinação das constantes de velocidade são:\n\\[\nkobs=k2+km2+k3\n\\tag{5.19}\\]\n\\[\nAo=\\frac{k2*(k2+km2)}{kobs^2}\n\\tag{5.20}\\]\n\\[\nkcat=\\frac{k2*k3}{kobs}\n\\tag{5.21}\\]\nOnde kobs e Ao representam parâmetros experimentais de constante de velocidade observada e amplitude, respectivamente. Esses parâmetros podem ser obtidos a partir do ajuste não linear da equação abaixo aos dados experimentais:\n\\[\nP=Ao(1-e^ {-kobs} + kcat * t)\n\\tag{5.22}\\]\n      O trecho de código que segue simula uma curva de comportamento pré-estacionário, quando conhecidas as constantes de velocidade que determinam os parâmetros experimentais.\n\n# Curva de MM em enzima de comportamento pré-estacionário\n\n# Parâmetros\nk2 &lt;- 387\nkm2 &lt;- 3\nk3 &lt;- 22\nxmin &lt;- 0\nxmax &lt;- 0.075  # definição de limites para função\n\n# Variáveis da equação de simulação (função dos parâmetros)\nkobs &lt;- k2 + km2 + k3\nAo &lt;- k2 * (k2 + km2)/kobs^2\nkcat &lt;- k2 * k3/kobs\n\n# Definição da função de simulação\nsim &lt;- function(x, kobs, Ao, kcat) {\n    Ao * (1 - exp(-kobs * x)) + kcat * x\n}\n\n# Curval de simulação\ncurve(sim(x, kobs = kobs, Ao = Ao, kcat = kcat), col = \"blue\", type = \"o\", xlim = c(xmin,\n    xmax), cex = 0.5, xlab = \"tempo\", ylab = \"[P]\")\n\n\n\n\n\n\n\nFigura 5.14: Formação de produto num modelo cinético de estado pré-estacionário.\n\n\n\n\n\n      Note pela figura Figura 5.14 que na cinética de estado transiente, existe uma fase pré-estacionária inicial eleva o teor de produto P rapidamente, e que antecede a fase estacionária de liberação constante de P.\n      Por outro lado, por vezes é necessário o oposto, ou seja, determinar as constantes de velocidade a partir do conhecimento dos parâmetros experimentais kobs e Ao. Nesse caso (e em tantos outros transdisciplinares) o R possui funções de minimização que permitem encontrar a raíz de equações lineares ou não lineares.\n      O procedimento envolve minimizar iterativamente um vetor de equações dadas as sementes para cada parâmetro. Para tal busca-se obter f(x) = 0 pela diferença entre um valor de referência; ou seja, quando a solução encontrar x quando f(x)-y = 0. Exemplificando, supondo que f(x) seja a+b/x, e que y seja 3. Então a busca se dá no sentido de encontrar a e b em a+b/x-3.\n      Para a determinação das constantes de velocidade representadas na cinética transiente, vale mencionar a função optim em stats ou o pacote rootSolve, que buscam minimizar equações lineares e não lineares para encontrar os valores de seus parâmetros.\n      Na solução dos parâmetros para estado pré-estacionário, ilustra-se abaixo o emprego do R com rootSolve, adicionando ainda a busca para Km como segue.\n\\[\nKm = \\frac{k3}{k2+k3}\n\\] {#eq:burstKm}\n\n# Cálculo de constantes cinéticas por solução de sistema de equações não\n# lineares aplicadas à cinética de burst.\n\nlibrary(rootSolve)\nkobs &lt;- 0.06\nAo &lt;- 50\nkcat &lt;- 300\nKs &lt;- 15\n# define os parâmetros de ajuste não linear obtidos por curva progressiva\n# experimental, t x P; Obs: Ks obtido experimentalmente de curva de S x kobs\n\n# Parâmetros x[1]=k2 x[2]= k3 x[3] = Km\n\n# Modelo\nmodel &lt;- function(x) c(x[1]/kobs^2 - Ao, (x[1] * x[2])/kobs - kcat, Ks * x[2]/(x[1] +\n    x[2]) - x[3])\n# o modelo acima deve conter uma lista de equações cuja igualdade é zero, ou\n# seja, f(x)=0\n(ss &lt;- multiroot(model, c(1, 1, 1)))  # comando de execução do rootSolve\n\n$root\n[1]   0.18000 100.00000  14.97305\n\n$f.root\n[1]  0.000000e+00  1.136868e-13 -1.243054e-09\n\n$iter\n[1] 4\n\n$estim.precis\n[1] 4.143891e-10\n\n# (sementes pro algoritmo)\n\n      Os resultados da minimização podem ser interpretados como:\n\nroot = valores de xi pra f(xi)=0 ; ou seja, k2, k3, e Km;\nf.root = valor de cada função pra cada xi (deve ser próximo de zero para cada);\niter = no. iterações ;\nesti.precis = estimativa da precisão.\n\n      A contemplar um capítulo ainda que extenso sobre cinética enzimática, existem inúmeros tópicos deixados de lado, dado o foco principal do emprego do R na solução de problemas quantitativos em biofísico-química. Dessa forma, omitimos diversos conceitos, tais como cinética lenta de interação de substrato (slow binding), cinética de múltiplos substratos (reação sequencial e ping-pong), equação integrada de Michaelis-Menten e curvas progressivas, ativação de moduladores, influência de pH e temperatura na catálise, e enzimas multisítios, entre vários.\n\n\n\n\nAkaike, Hirotugu. 1974. «A new look at the statistical model identification». IEEE transactions on automatic control 19 (6): 716–23.\n\n\nDeLean, A, PJ Munson, e Dl Rodbard. 1978. «Simultaneous analysis of families of sigmoidal curves: application to bioassay, radioligand assay, and physiological dose-response curves.» American Journal of Physiology-Endocrinology And Metabolism 235 (2): E97.\n\n\nJohnson, Kenneth A. 1992. «1 transient-state kinetic analysis of enzyme reaction pathways». Em The enzymes, 20:1–61. Elsevier.\n\n\nLeone, Francisco de Assis. 2021. Fundamentos de Cinética Enzimática. Appris Ed.\n\n\nMichaelis, L., e ML Menten. 1913. «Die Kinetik der Invertinwirkung». Biochem Z 49 (4): 333–69.\n\n\nScatchard, George. 1949. «The attractions of proteins for small molecules and ions». Annals of the New York Academy of Sciences 51 (4): 660–72.\n\n\nSpiess, Andrej-Nikolai, e Natalie Neumeyer. 2010. «An evaluation of R2 as an inadequate measure for nonlinear models in pharmacological and biochemical research: a Monte Carlo approach». BMC pharmacology 10 (1): 1–11.\n\n\nTang, Lixia, Jeffrey H Lutje Spelberg, Marco W Fraaije, e Dick B Janssen. 2003. «Kinetic mechanism and enantioselectivity of halohydrin dehalogenase from Agrobacterium radiobacter». Biochemistry 42 (18): 5378–86.\n\n\nTraut, Thomas W. 2007. Allosteric regulatory enzymes. Springer Science & Business Media.\n\n\nWilkinson, GN. 1961. «Statistical estimations in enzyme kinetics». Biochemical Journal 80 (2): 324–32.\n\n\nYung-Chi, Cheng, e William H Prusoff. 1973. «Relationship between the inhibition constant (KI) and the concentration of inhibitor which causes 50 per cent inhibition (I50) of an enzymatic reaction». Biochemical pharmacology 22 (23): 3099–3108.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Enzimas</span>"
    ]
  },
  {
    "objectID": "binding.html",
    "href": "binding.html",
    "title": "6  Interação Bimolecular",
    "section": "",
    "text": "6.1 Modelos de Interação e Representações Lineares\n\\[\nP+L \\begin{array}{c}\n_{k_{on}}\\\\\n\\rightleftharpoons\\\\\n^{k_{off}} \\end{array} PL\n\\tag{6.1}\\]\nOnde P representa o teor de proteína livre, L o ligante livre, e PL o complexo formado. As taxas de reação são definidas para a formação (k\\(_{on}\\); M\\(^{-1}\\)s\\(^{-1}\\)) e dissociação (k\\(_{off}\\); s\\(^{-1}\\)) do complexo.\n\\[\nKd=\\frac{[P]*[L]}{[P]+[L]}\n\\tag{6.2}\\]\nOnde Kd representa a constante de equilíbrio de dissociação para o complexo PL formado, tal como condicionado ao equilíbrio de formação/dissociação do complexo (v\\(_{assoc}\\) = v\\(_{dissoc}\\)), e também definido como:\n\\[\nKd=\\frac{k_{off}}{k_{on}}\n\\tag{6.3}\\]\n\\[\n\\nu=\\frac{n * [L]}{Kd + [L]}\n\\tag{6.4}\\]\n# Linearizações em interação bimolecular\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-06\nKd &lt;- 1e-06\nn &lt;- 1\nv &lt;- n * L/(Kd + L)\npar(mfrow = c(2, 3))  # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1/L, 1/v, type = \"o\", main = \"Klotz\")\nplot(v, v/L, type = \"o\", main = \"Scatchard\")\nplot(L, L/v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v/(n - v)), type = \"o\", main = \"Hill\")\n\n\n\n\nPrincipais linearizações da isoterma de ligação ligante-proteína.\n\n\n\npar(mfrow = c(1, 1))  # volta à janela gráfica normal\n\\[\nK = \\frac{1}{Kd}\n\\tag{6.5}\\]\n\\[\n\\nu=\\frac{K1*[L]}{1+K1*[L]} + \\frac{K2*[L]}{1+K2*[L]}\n\\tag{6.6}\\]\n# Heterogeneidade de sítios de ligação\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-06\nKd1 &lt;- 2e-06\nn1 &lt;- 1\nKd2 &lt;- 2e-08\nn2 &lt;- 1\nv &lt;- (n1 * L/(Kd1 + L)) + (n2 * L/(Kd2 + L))\n\npar(mfrow = c(2, 3))  # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1/L, 1/v, type = \"o\", main = \"Klotz\")\nplot(v, v/L, type = \"o\", main = \"Scatchard\")\nplot(L, L/v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v/(n1 + n2 - v)), type = \"o\", main = \"Hill\")\n\n\n\n\nModelo e linearizações para heterogeneidade de 2 conjuntos de sítios de ligação\n\n\n\n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1))  # volta à janela gráfica normal\n# Criação de novo sítio sob interação com ligante\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-06\nKd1 &lt;- 2e-06\nn1 &lt;- 1\nKd2 &lt;- 2e-05\nn2 &lt;- 1\nnH &lt;- 0.5\nv &lt;- (n1 * L * 1/Kd1)/(1 + 1/Kd1 * L) + ((n2 * 1/Kd1 * 1/Kd2 * L^2)/(1 + 1/Kd1 *\n    L) * (1 + 1/Kd2 * L))\npar(mfrow = c(2, 3))  # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1/L, 1/v, type = \"o\", main = \"Klotz\")\nplot(v, v/L, type = \"o\", main = \"Scatchard\")\nplot(L, L/v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v/(n - v)), type = \"o\", main = \"Hill\")\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): NaNs produced\n\n\n\n\n\nModelo e linearizações para criação de novo sítio: 1-site creator.\n\n\n\n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1))  # volta à janela gráfica normal\n# Cooperatividade negativa em ligand-binding\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-06\nKd &lt;- 2e-06\nn &lt;- 1\nnH &lt;- 0.5\nv &lt;- (n * L^nH/(Kd + L^nH))\npar(mfrow = c(2, 3))  # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1/L, 1/v, type = \"o\", main = \"Klotz\")\nplot(v, v/L, type = \"o\", main = \"Scatchard\")\nplot(L, L/v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v/(n - v)), type = \"o\", main = \"Hill\")\n\n\n\n\nModelo e linearizações para cooperatividade negativa de sítios de ligação.\n\n\n\n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1))  # volta à janela gráfica normal\n# Cooperatividade positiva em ligand binding\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-06\nKd &lt;- 2e-06\nn &lt;- 1\nnH &lt;- 1.5\nv &lt;- (n * L^nH/(Kd + L^nH))\npar(mfrow = c(2, 3))  # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1/L, 1/v, type = \"o\", main = \"Klotz\")\nplot(v, v/L, type = \"o\", main = \"Scatchard\")\nplot(L, L/v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v/(n - v)), type = \"o\", main = \"Hill\")\n\n\n\n\nModelo e linearizações para cooperatividade positiva de sítios de ligação.\n\n\n\n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1))  # volta à janela gráfica normal",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interação Bimolecular</span>"
    ]
  },
  {
    "objectID": "binding.html#modelos-de-interação-e-representações-lineares",
    "href": "binding.html#modelos-de-interação-e-representações-lineares",
    "title": "6  Interação Bimolecular",
    "section": "",
    "text": "Observe que a Equação 6.4 praticamente repete o formalismo já visto com a formação do complexo ativado de enzima-substrato (Equação 5.2), bem como sua representação resultante como uma hipérbole quadrática. De fato, ocorre essencialmente a substituição do parâmetro cinético v da reação pelo parâmetro termodinâmico \\(\\nu\\) (“nu”, do Grego) para a isoterma de ligação. As demais quantidades envolvidas mantém-se análogas (P no lugar de E; L no lugar de S;Kd no lugar de Km; e n no lugar de Vmax).\n      Mantida essa similaridade com o formalismo da equação de Michaelis-Menten, da mesma maneira decorrem as linearizações para a Equação 6.4), bem como ajustes não lineares à mesma, na busca de uma solução analítica para os parâmetros termodinâmicos Kd e n. Exemplificando um trecho de código para as linearizações mais comuns no tratamento de dados de interação ligante-proteína:\n\n      Desvios da linearidade, por outro lado, são frequentemente utilizados como diagnósticos para modelos que distintos do de homogeneidade de sítios de ligação como acima (heterogeneidade de sítios, criação de sítio, cooperatividade. As equações abaixo descrevem esses modelos, e consideram K, constante de equilíbrio de associação ligante-proteína, como o reverso de Kd, a fim de tornar as expressões mais legíveis:\n\n      O modelo de heterogeneidade de sítios de ligação pressupõe que haja na proteína mais um sítio com afinidades distintas para o ligante (Dahlquist 1978). Formalmente esse modelo pode ser exemplificado para 2 conjuntos de sítios de ligação, como segue:\n\n      O trecho de código abaixo exemplifica o modelo no R, bem como suas principais linearizações diagnósticas.\n\n      O modelo de criação de novo sítio - “one-site creator”; (Parsons e Vallner 1978) estabelece uma cooperatividade positiva resultante da produção de novos sítios para o ligante na proteína. Segue o modelo exemplificado e suas linearizações resultantes.\n\n      Os modelos de cooperatividade (negativa e positiva) seguem um formalismo similar descrito para a ligação de oxigênio à hemoglobina em Capítulo 4 (Equação 4.2). Na cooperatividade negativa uma segunda molécula de ligante interage com a proteína com menor afinidade:\n\n      Já na cooperatividade positiva, uma segunda molécula de ligante interage com a proteína com maior afinidade que a primeira molécula (Parsons e Vallner 1978):\n\n      Observe que a inclinação do gráfico de Hill é inferior à unidade para a cooperatividade negativa, e superior a essa, para a cooperatividade positiva, e representa o mesmo parâmetro nH visto na Equação 4.2.\n      Ainda que sujeito à crítica por sua inconsistência estatística (variável dependente em ambos os eixos), a representação de Scatchard tem sido privilegiada ao longo de décadas como diagnóstico de modelos de interação ligante-proteína. Entre suas vantagens, aloca-se a possibilidade de facilmente distinguir-se o modelo de cooperatividade positiva (aclive) do de heterogeneidade de sítios de ligação (declive abrupto) ou de cooperatividade negativa (declive suave).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interação Bimolecular</span>"
    ]
  },
  {
    "objectID": "binding.html#ajuste-não-linear-em-interação-ligante-proteína",
    "href": "binding.html#ajuste-não-linear-em-interação-ligante-proteína",
    "title": "6  Interação Bimolecular",
    "section": "6.2 Ajuste Não-Linear Em Interação Ligante-Proteína",
    "text": "6.2 Ajuste Não-Linear Em Interação Ligante-Proteína\n      Ajustes diretos da equação não linear dos modelos de interação também podem ser efetuados como fora realizado para a equação de Michaelis-Menten no Capítulo 5 sobre Enzimas. Exemplificando, pode-se simular a obtenção de dados experimentais de binding pelo trecho a seguir, utilizando-se o comando ‘runif’ (random uniform) para geração de sequência aleatória (como fora realizado no capítulo Capítulo 5). Para ilustrar, segue a Figura 6.1.\n\n# Isoterma de Interação Ligante-Proteína\nn &lt;- 1\nKd &lt;- 10\nL &lt;- 120\ni &lt;- 3\nL &lt;- seq(0, L, i)\nv &lt;- (L * n)/(Kd + L) + rnorm(40, 0, 0.1)\n\nWarning in (L * n)/(Kd + L) + rnorm(40, 0, 0.1): longer object length is not a\nmultiple of shorter object length\n\nplot(L, v)\n\n\n\n\n\n\n\nFigura 6.1\n\n\n\n\n\n      Observe que o comando ‘rnorm’ adiciona um erro de distribuição normal aos dados. Outra forma para simulação desses é dada abaixo, introduzindo-se o comando ‘runif’ de geração de números aleatórios.\n\n# Simulação de dados de interação bimolecular (1 sítio)\n\n# Simulação de dados\nset.seed(20160227)  # estabelece semente para geração de números aleatórios\nL &lt;- seq(0, 50, 1)\nPL &lt;- ((runif(1, 10, 20) * L)/(runif(1, 0, 10) + L)) + rnorm(51, 0, 1)\n# 1. runif(n,min,max); quando sem atributos, considera-se min=0 e max=1 2.\n# rnorm(no. pontos,media,desvio) - erro aleatório de distribuição normal\nplot(L, PL, xlab = \"L\", ylab = \"PL\")\n\n\n\n\nDados simulados para isoterma de interação bimolecular.\n\n\n\n\n      Agora precisamos utilizar o comando ‘nls’ para o ajuste não linear, sobreposição da curva teórica, e tabela estatística de resultados:\n\n# Ajuste não linear em ligand binding\nm &lt;- nls(PL ~ n * L/(Kd + L), start = list(n = 1, Kd = 1))\n\n# Coef. de correlação\ncor(PL, predict(m))  # Coeficiente de correlação de Pearson\n\n[1] 0.9496598\n\n# Gráfico de dados e simulação\nplot(L, PL)\nlines(L, predict(m), lty = 2, col = \"red\", lwd = 3)\n\n\n\n\n\n\n\nsummary(m)\n\n\nFormula: PL ~ n * L/(Kd + L)\n\nParameters:\n   Estimate Std. Error t value Pr(&gt;|t|)    \nn   11.8478     0.2620  45.216  &lt; 2e-16 ***\nKd   4.2778     0.5113   8.366  5.3e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.7826 on 49 degrees of freedom\n\nNumber of iterations to convergence: 6 \nAchieved convergence tolerance: 1.554e-06",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interação Bimolecular</span>"
    ]
  },
  {
    "objectID": "binding.html#sistemas-gráficos-no-r",
    "href": "binding.html#sistemas-gráficos-no-r",
    "title": "6  Interação Bimolecular",
    "section": "6.3 Sistemas Gráficos no R",
    "text": "6.3 Sistemas Gráficos no R\n      A última curva de simulação obtida o foi junto à biblioteca padrão para manipulação de gráficos da instalação do ‘R’, Graphics. Trata-se um conjunto de funções amplo também utilizado por vários outros pacotes do ambiente. Contudo, existem no ‘R’ diversas outras bibliotecas para elaboração de gráficos, dentre os quais vale destacar o Lattice, também incluido na instalação padrão, e o ggplot2. Ambos os sistemas geram resultados com melhor estética e flexibilidade gráfica que a biblioteca Graphics padrão, e possuem empregos e semânticas distintas entre si.\n      O sistema Lattice (Sarkar 2008) é baseado no sistema Trellis para representação gráfica de dados multivariados. Sua força está na representação de dados em paineis contendo subgrupos e, embora tenha sintaxe menos intuitiva e por vezes mais elaborada que o pacote Graphics, produz um grafismo superior a esse com poucos cliques de teclado. De modo geral, o Lattice produz o gráfico dentro do próprio algoritmo, de modo diferente aos sistemas Graphics (pode-se acumular linhas sucessivas de modificação do gráfico) ou ggplot2.\n     Por outro lado a biblioteca ggplot2 é baseada na gramática de gráficos (Wickham 2011), e produz o gráfico utilizando uma única linha de comando que combina camadas sobrepostas, de modo similar à aplicativos de manipulação de imagens (ex: Inkscape, Gimp, Corel Draw, Photoshop). Dessa forma é possível alterar cada ítem do gráfico em suas camadas específicas (tema, coordenadas, facets, estatísticas, geometria, estética, dados). Exemplificando o resultado gráfico da curva de simulação acima de binding para Lattice e ggplot2:\n\n# Os sistemas lattice e ggplot2\n\n# Simulação de dados\n\nset.seed(20160227)  # estabelece semente para geração de números aleatórios\nL &lt;- seq(0, 50, 1)\nPL &lt;- ((runif(1, 10, 20) * L)/(runif(1, 0, 10) + L)) + rnorm(51, 0, 1)\n# 1. runif(n,min,max); quando sem atributos, considera-se min=0 e max=1 2.\n# rnorm(no. pontos,media,desvio) - erro aleatório de distribuição normal\n\n# Produção do gráfico com sistema Lattice\nlibrary(lattice)\nxyplot(PL ~ L)\n\n\n\n\n\n\n\n# Produção do gráfico com sistema ggplot2\nlibrary(ggplot2)\nqplot(L, PL)\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\n\n\n\n\n      Como a percepção de peculiaridades dos sistemas gráficos se revela melhor com dados mais elaborados, as ilustrações a seguir utilizarão o conjunto de dados ‘Puromycin’, que integra a biblioteca ‘datasets’ do ‘R’. Os dados apresentam a velocidade de reação enzimática sobre um substrato em células tratadas e não tratadas com puromicina.\n      O código abaixo retorna a plotagem, ajuste não linear e resultados obtidos com a biblioteca Graphics padrão, e foi extraído do própria documentação do dataset.\n\nlibrary(datasets)\n\n# O sistema base `graphics`\n\nplot(rate ~ conc, data = Puromycin, las = 1, xlab = \"[S], mM\", ylab = \"v (contagem/min/min)\",\n    pch = as.integer(Puromycin$state), col = as.integer(Puromycin$state), main = \"Ilustração de Ajuste Com Graphics\")\n\n## Ajuste da equação de Michaelis-Mentem\nfm1 &lt;- nls(rate ~ Vm * conc/(K + conc), data = Puromycin, subset = state == \"treated\",\n    start = c(Vm = 200, K = 0.05))\nfm2 &lt;- nls(rate ~ Vm * conc/(K + conc), data = Puromycin, subset = state == \"untreated\",\n    start = c(Vm = 160, K = 0.05))\nsummary(fm1)\n\n\nFormula: rate ~ Vm * conc/(K + conc)\n\nParameters:\n    Estimate Std. Error t value Pr(&gt;|t|)    \nVm 2.127e+02  6.947e+00  30.615 3.24e-11 ***\nK  6.412e-02  8.281e-03   7.743 1.57e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 10.93 on 10 degrees of freedom\n\nNumber of iterations to convergence: 5 \nAchieved convergence tolerance: 8.768e-06\n\nsummary(fm2)\n\n\nFormula: rate ~ Vm * conc/(K + conc)\n\nParameters:\n    Estimate Std. Error t value Pr(&gt;|t|)    \nVm 1.603e+02  6.480e+00  24.734 1.38e-09 ***\nK  4.771e-02  7.782e-03   6.131 0.000173 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 9.773 on 9 degrees of freedom\n\nNumber of iterations to convergence: 5 \nAchieved convergence tolerance: 4.473e-06\n\n## Adição de linhas de ajuste ao plot\nconc &lt;- seq(0, 1.2, length.out = 101)\nlines(conc, predict(fm1, list(conc = conc)), lty = 1, col = 1)\nlines(conc, predict(fm2, list(conc = conc)), lty = 2, col = 2)\nlegend(0.8, 120, levels(Puromycin$state), col = 1:2, lty = 1:2, pch = 1:2)\n\n\n\n\nPlotagem e análise com graphics.\n\n\n\n\n      O sistema ggplot2, por sua vez, exige que os comandos sejam elencados em camadas justapostas intercaladas com o sinal “+”, como segue:\n\n# Gráfico e análise com ggplot2\nlibrary(datasets)\np &lt;- ggplot(data = Puromycin, aes(conc, rate, color = state)) + geom_point() + geom_smooth(method = \"nls\",\n    formula = y ~ Vm * x/(Km + x), method.args = list(start = list(Vm = 200, Km = 0.1)),\n    se = FALSE)  # expressão que define o plot\np  # variável que apresenta o plot\n\n\n\n\nPlotagem e análise com ggplot2.\n\n\n\n\n      Perceba o menor número de instruções do script para a produção do gráfico. Além disso, e diferente do Graphics, ggplot2 permite adicionar camadas à linha de comandos principais, e apresentar os dados multivariados em paineis (funções ‘facet_grid’ e ‘facet_wrap’), sem a necessidade de se utilizar o comando ‘mfrow’ ou ‘mfcol’ visto no capítulo, como segue:\n\np + facet_grid(rows = vars(state))\n\n\n\n\nPlotagem e análise com ggplot2 - paineis (faceting).\n\n\n\n\n      Lattice também possui uma economia de instruções em relação à Graphics. Não considerando o ajuste estatístico, os grupos podem ser apresentados simplesmente utilizando-se a fórmula:\n\\[\nxyplot(y \\sim x~|~ groups = z)\n\\tag{6.7}\\]\n\nlibrary(lattice)\nxyplot(rate ~ conc, data = Puromycin, groups = state)\n\n\n\n\n\n\n\n\n      E para a representação dos ajustes não lineares:\n\n# Um gráfico com dataset para lattice\n\nlibrary(nlme)\nn1 &lt;- nlsList(rate ~ Vmax * conc/(Km + conc) | state, data = Puromycin, start = list(Vmax = 200,\n    Km = 0.1))\nsummary(n1)\nxyplot(rate ~ conc, groups = state, data = Puromycin) + layer(panel.curve(Vmax[1] *\n    x/(Km[1] + x), col = 1), data = as.list(coef(n1))) + layer(panel.curve(Vmax[2] *\n    x/(Km[2] + x), col = 2), data = as.list(coef(n1)))\n\n      A biblioteca Lattice também permite a apresentação em paineis; diferente de ggplot2, contudo, o gráfico é gerado algoritmicamente, sem a sobreposição de comandos:\n\n# Gráfico e análise não linear com lattice\n\nlibrary(nlme)  # pacote quer permite regressão não linear com subgrupos\nnonlinLatt &lt;- nlsList(rate ~ Vmax * conc/(Km + conc) | state, start = list(Vmax = 200,\n    Km = 0.1), data = Puromycin)\nsummary(nonlinLatt)\n\nCall:\n  Model: rate ~ Vmax * conc/(Km + conc) | state \n   Data: Puromycin \n\nCoefficients:\n   Vmax \n          Estimate Std. Error  t value     Pr(&gt;|t|)\ntreated   212.6836   6.608088 32.18535 3.241151e-11\nuntreated 160.2800   6.896011 23.24242 1.384612e-09\n   Km \n            Estimate  Std. Error  t value     Pr(&gt;|t|)\ntreated   0.06412110 0.007876774 8.140529 0.0000156514\nuntreated 0.04770812 0.008281147 5.761052 0.0001727056\n\nResidual standard error: 10.40003 on 19 degrees of freedom\n\nxyplot(rate + fitted(nonlinLatt) ~ conc | state, data = Puromycin, type = c(\"p\",\n    \"l\"), distribute.type = TRUE, col.line = \"red\", ylab = \"rate\")\n\n\n\n\nPlotagem e análise com Lattice - ajuste externo e paineis.\n\n\n\n\n      Das muitas diferenças que os pacotes ggplot2 e Lattice apresentam, há uma que vale a pena ressaltar. Como visto acima, o ggplot2 realiza o ajuste não linear dentro da linha de comandos de geração do gráfico, ao passo que o Lattice permite fazê-lo fora da linha. Isso é inerente do ggplot2, uma biblioteca desenhada para a produção de gráficos, e não para análises computacionais. Dessa forma o algoritmo que permite o ajuste não linear pelo ggplot2, ainda que seja o mesmo ‘nls’ já trabalhado, não expressa seus resultados explicitamente (embora haja formas de “pescá-los” utilizando-se outros pacotes).\n      De certa forma, ainda que o Lattice exija uma curva de aprendizado menos intutiva, ele permite que se utilize os resultados estatísticos obtidos anteriormente para inclusão no algoritmo de plotagem. Isso é vantajoso quando se deseja outros algoritmos estatísticos para ajuste, como acima, ou mesmo sua flexibilização, além do ‘nls’ incluido em ggplot2. Não obstante, o Lattice também permite que se inclua a linha de ajuste dentro do próprio algoritmo, como abaixo:\n\n# Ajuste não linear em paineis (Lattice)\n\nxyplot(rate ~ conc | state, data = Puromycin, panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    n3 &lt;- nls(y ~ Vmax * x/(Km + x), data = Puromycin, start = list(Vmax = 200, Km = 0.1))\n    panel.lines(seq(0.02, 1.1, 0.02), predict(n3, newdata = data.frame(x = seq(0.02,\n        1.1, 0.02))), col.line = 2)\n}, xlab = \"conc\", ylab = \"rate\")\n\n\n\n\nPlotagem e análise com Lattice - ajuste interno e paineis.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interação Bimolecular</span>"
    ]
  },
  {
    "objectID": "binding.html#solução-numérica-para-o-equilíbrio-de-complexos-ligante-proteína",
    "href": "binding.html#solução-numérica-para-o-equilíbrio-de-complexos-ligante-proteína",
    "title": "6  Interação Bimolecular",
    "section": "6.4 Solução Numérica Para o Equilíbrio de Complexos Ligante-Proteína",
    "text": "6.4 Solução Numérica Para o Equilíbrio de Complexos Ligante-Proteína\n      Como visto no capítulo Capítulo 3, por vezes uma solução numérica pode ser empregada quando a solução analítica não converge, ou quando estamos diante de uma equação mais complexa. Nesse sentido a formação de complexos de que trata este subtítulo pode também ser tratada por uma solução numérica.\n      Usualmente o tratamento dado para a solução numérica envolve encontrar as raízes de uma equação ou sistema de equações, ou seja:\n\\[\nF(x) = 0\n\\tag{6.8}\\]\n\\[\nP+L \\rightleftarrows PL\n\\\\\nKd = \\frac{[P][L]}{[PL]}\n\\\\\nEntão,\\ [PL]=\\frac{[P][L]}{Kd}\n\\tag{6.9}\\]\n\\[\n\\begin{cases}\n[Pt] = [P]+[PL] = [P]+\\frac{[P][L]}{Kd}\\\\\n[Lt] = [L]+[PL] = [L]+\\frac{[P][L]}{Kd}\n\\end{cases}\\\n\\tag{6.10}\\]\n      Assim, tem-se um sistema de equações lineares nos parâmetros ([P] livre, [L] livre, e complexo [PL]) que pode ser solucionado pelo R por diversas maneiras, uma das quais pela função de minimização rootSolve:\n\n# Cálculo de L, P, e PL em interação biomolecular para 1 conjunto de sítios de\n# mesma afinidade\nlibrary(rootSolve)\nPt &lt;- 1\nLt &lt;- 10\nKd &lt;- 4\n\n# Modelo\nmodel &lt;- function(x) c(x[1] + (x[1] * x[2])/Kd - Pt, x[2] + (x[1] * x[2])/Kd - Lt,\n    Pt - x[1] - x[3])\n# o modelo acima deve conter uma lista de equações cuja igualdade é zero, ou\n# seja, f(x)=0\n(ss &lt;- multiroot(model, c(1, 1, 1)))  # comando de execução do \n\n$root\n[1] 0.3007353 9.3007353 0.6992647\n\n$f.root\n[1] 5.466137e-08 5.463051e-08 5.191070e-12\n\n$iter\n[1] 5\n\n$estim.precis\n[1] 3.643236e-08\n\n# rootSolve (sementes pro algoritmo)\n\n      Dessa forma os valores resultantes (f.root) quando [Lt] = 10 são apresentados como [P] = 0,3, [L] = 9,3 e [PL] = 0,7.\n      Outras soluções numéricas permitem um maior controle sobre o algoritmo empregado, tais como a função optim do R (limites de busca da solução, emprego de vetores, por ex). Para isso será exemplificado a mesma situação acima, embora apresentando uma variação do formalismo que relaciona P, L e PL :\n\\[\n\\begin{cases}\n[PL] = [Pt]-[L]\\\\\n[PL] = [Lt]-[L]\\\\\n[P]*[L]=Kd*[PL]\n\\end{cases}\\\n\\tag{6.11}\\]\n      Dessa forma pode-se contruir uma relação quadrática envolvendo as três incógnitas:\n\\[\n([Pt]-[L]-[PL])^2 + ([Lt]-[L]-[PL])^2 + ([P]*[L]-Kd*[PL])^2\n\\tag{6.12}\\]\n      Aplicando-se o algoritmo de minimização optim do R:\n\n# Cálculo de L, P, PL em interação para 1 sítio\n\nmodel2 &lt;- function(x, Pt, Lt, K) {\n    L &lt;- x[1]\n    P &lt;- x[2]\n    PL &lt;- x[3]\n    (Pt - P - PL)^2 + (Lt - L - PL)^2 + (P * L - Kd * PL)^2\n}  # declaração da função\nPt &lt;- 1\nLt &lt;- 10\nKd &lt;- 4  # parâmetros da função\nsol2num &lt;- optim(c(0.5, 1, 0.5), model2, method = \"L-BFGS-B\", lower = c(0, 0, 0),\n    upper = c(Lt, Pt, Pt), Pt = Pt, Lt = Lt)\n# método BFGS permite bounds (lower, upper)\nsol2num$par  # LF, PF, PL calculados\n\n[1] 9.3007349 0.3007355 0.6992652\n\n\n      Perceba que são os mesmos resultados anteriores, embora com maior controle da solução. Agora pode-se utilizar essa minimização para criar um vetor de soluções para as três quantidades, como segue:\n\n# Declaração da função\nbind1 &lt;- function(x, Pt, Lt, Kd) {\n    L &lt;- x[1]\n    P &lt;- x[2]\n    PL &lt;- x[3]\n    (Pt - P - PL)^2 + (Lt - L - PL)^2 + (P * L - Kd * PL)^2\n}\n\n# Parâmetros da função\nPt &lt;- 1\nLt &lt;- c(5, 10, 20)\nKd &lt;- 4\n\n# Minimização (parâmetros para que a função acima dê zero)\ny &lt;- function(i) {\n    optim(c(1, 1, 1), bind1, method = \"L-BFGS-B\", lower = c(0, 0, 0), upper = c(Lt[i],\n        Pt, Pt), Lt = Lt[i], Pt = Pt, Kd = Kd)\n}\n\n# Resultados em matriz\nypar &lt;- function(i) y(i)$par\nyp &lt;- matrix(nrow = length(Lt), ncol = 2 + length(Kd), byrow = T)\nfor (i in 1:length(Lt)) yp[i, ] &lt;- y(i)$par\ncolnames(yp) &lt;- c(\"L\", \"P\", \"PL\")\nrownames(yp) &lt;- c(\"5\", \"10\", \"20\")\nyp\n\n           L         P        PL\n5   4.472136 0.4721359 0.5278640\n10  9.300736 0.3007344 0.6992634\n20 19.172624 0.1726180 0.8273844",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interação Bimolecular</span>"
    ]
  },
  {
    "objectID": "binding.html#cinética-de-interação-ligante-proteína-e-solução-numérica",
    "href": "binding.html#cinética-de-interação-ligante-proteína-e-solução-numérica",
    "title": "6  Interação Bimolecular",
    "section": "6.5 Cinética de Interação Ligante-Proteína e Solução Numérica",
    "text": "6.5 Cinética de Interação Ligante-Proteína e Solução Numérica\n      Sob o mesmo princípio da solução numérica apresentada no ítem anterior para o equilíbrio da interação ligante-proteína, o R permite solução de mesma natureza para a cinética da formação dos complexos, ou seja, os teores de P, L e PL observados no tempo. Nesse caso pode-se desenvolver outras relações a partir da Eq. @ref(eq:diagPL). Tomando-se por base que no equilíbrio as taxas cinéticas de k\\(_{on}\\) e k\\(_{off}\\) se igualam (steady-state), pode-se relacionar algumas equações diferenciais para a associação, bem como para a dissociação dos complexos:\n\\[\nPara \\, a\\, associação:\n\\begin{cases}\n\\frac{d[PL]}{dt} = k_{on}*[L]*[P]\\\\\n\\frac{d[L]}{dt} = -k_{on}*[L]*[P]\\\\\n\\frac{d[P]}{dt} = -k_{on}*[L]*[P]\n\\end{cases}\n\\tag{6.13}\\]\n\\[\nPara \\, a\\, dissociação:\n\\begin{cases}\n\\frac{d[PL]}{dt} = -k_{off}*[PL]\\\\\n\\frac{d[L]}{dt} = k_{off}*[PL]\\\\\n\\frac{d[P]}{dt} = k_{off}*[PL]\n\\end{cases}\n\\tag{6.14}\\]\n       Assim, as taxas globais resultantes para cada quantidade (taxa líquida) envolverá a soma das taxas de associação e dissociação de cada:\n\\[\nTaxas \\, líquidas:\n\\begin{cases}\n\\frac{d[PL]}{dt} = k_{on}*[L]*[P]-k_{off}*[PL]\\\\\n\\frac{d[L]}{dt} = -k_{on}*[L]*[P]+k_{off}*[PL]\\\\\n\\frac{d[P]}{dt} = -k_{on}*[L]*[P]+k_{off}*[PL]\n\\end{cases}\n\\tag{6.15}\\]\n      A solução para esse sistema final de equações diferenciais (taxas líquidas) envolve resolver a variação de cada quantidade (\\(\\Delta\\)x) num determinado intervalo de tempo (\\(\\Delta\\)t), tal que:\n\\[\n\\Delta x=f(x)*\\Delta t\n\\tag{6.16}\\]\n      Para isso é necessário utilizar uma biblioteca do R que permita a solução de um sistema de equações diferenciais. Entre as muitas soluções (odeintr, pracma, rODE), o emprego da biblioteca deSolve, que utiliza uma função para integração do sistema por algoritmo de Runge-Kutta de 4a. ordem:\n\n# Cinética de interação ligante-protéina para 1 conjunto de sítios\nlibrary(deSolve)\n\n# Condições experimentais\ntempo &lt;- seq(0, 100)  # intervalo de tempo\nparms &lt;- c(kon = 0.02, koff = 0.001)  # parâmetros do estado estacionário \n# da interação (uM^-1*s^-1 e s^-1, respectivamente)\nval.inic &lt;- c(L = 0.8, P = 1, PL = 0)  # valores iniciais, uM\n\n# Integração do sistema por Runge-Kutta de 4a. ordem\nsolNumKin &lt;- function(t, x, parms) {\n    # definição da lista de parâmetros\n    L &lt;- x[1]  # ligante\n    P &lt;- x[2]  # proteína\n    PL &lt;- x[3]  # complexo\n\n    with(as.list(parms), {\n        # definição da lista de equações diferenciais\n        dL &lt;- -kon * L * P + koff * PL\n        dP &lt;- -kon * L * P + koff * PL\n        dPL &lt;- kon * L * P - koff * PL\n        res &lt;- c(dL, dP, dPL)\n        list(res)\n    })\n}\n\nsol.rk4 &lt;- as.data.frame(rk4(val.inic, tempo, solNumKin, parms))  # rotina para Runge-Kutta 4a. ordem\n\n# Gráfico\nplot(sol.rk4$time, sol.rk4$L, type = \"l\", xlab = \"tempo\", ylab = \"[composto], uM\")\nlegend(\"topright\", c(\"L\", \"P\", \"PL\"), text.col = c(\"black\", \"red\", \"blue\"), bty = \"n\",\n    lty = c(1, 2, 3))\nlines(sol.rk4$time, sol.rk4$P, type = \"l\", lty = 2, col = 2, lwd = 1.5)\nlines(sol.rk4$time, sol.rk4$PL, type = \"l\", lty = 3, col = 3, lwd = 1.5)\n\n\n\n\nTeores de ligante e proteína livres (L e P), bem como do complexo PL apresentados ao longo do tempo de acordo com o método Runge-Kutta de 4a. ordem para solução de equações diferenciais.\n\n\n\n\n\n\n\n\nDahlquist, FW. 1978. «[13] The meaning of scatchard and hill plots». Methods in enzymology 48: 270–99.\n\n\nParsons, DL, e JJ Vallner. 1978. «Theoretical models for cooperative binding—I. one-site creator of binding sites». Mathematical Biosciences 41 (3-4): 189–215.\n\n\nSarkar, Deepayan. 2008. Lattice: multivariate data visualization with R. Springer Science & Business Media.\n\n\nWickham, Hadley. 2011. «ggplot2». Wiley interdisciplinary reviews: computational statistics 3 (2): 180–85.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interação Bimolecular</span>"
    ]
  },
  {
    "objectID": "acnucleic.html",
    "href": "acnucleic.html",
    "title": "7  Ácidos Nucleicos",
    "section": "",
    "text": "7.1 Análise de sequências\n# Conversão de sequência alfabética em vetor de bases\n\nlibrary(stringr)\nliso.nucl &lt;- \"GCAGTCCCGCTGTGTGTACGACACTGGCAACATGAGGTCTTTGCTAATCTTGGTGC\nTTTGCTTCCTGCCCCTGGCTGCTCTGGGGAAAGTCTTTGGACGATGTGAGCTGGCAGCGGCTATGAAGCG\nTCACGGACTTGATAACTATCGGGGATACAGCCTGGGAAACTGGGTGTGTGCCGCAAAATTCGAGAGTAAC\nTTCAACACCCAGGCTACAAACCGTAACACCGATGGGAGTACCGACTACGGAATCCTACAGATCAACAGCC\nGCTGGTGGTGCAACGATGGCAGGACCCCAGGCTCCAGGAACCTGTGCAACATCCCGTGCTCAGCCCTGCT\nGAGCTCAGACATAACAGCGAGCGTGAACTGCGCGAAGAAGATCGTCAGCGATGGAAACGGCATGAACGCG\nTGGGTCGCCTGGCGCAACCGCTGCAAGGGCACCGACGTCCAGGCGTGGATCAGAGGCTGCCGGCTGTGAG\nGAGCTGCCGCGCCCGGCCCGCCCGCTGCACAGCCGGCCGCTTTGCGAGCGCGACGCTACCCGCTTGGCAG\nTTTTAAACGCATCCCTCATTAAAACGACTATACGCAAACGCC\"\n\nliso.nucl &lt;- unlist(strsplit(liso.nucl, \"\"))\n# converte sequência gênica de uma palavra em nucleotídios separados\nliso.nucl[1:100]  # uma amostra do resultado\n\n  [1] \"G\"  \"C\"  \"A\"  \"G\"  \"T\"  \"C\"  \"C\"  \"C\"  \"G\"  \"C\"  \"T\"  \"G\"  \"T\"  \"G\"  \"T\" \n [16] \"G\"  \"T\"  \"A\"  \"C\"  \"G\"  \"A\"  \"C\"  \"A\"  \"C\"  \"T\"  \"G\"  \"G\"  \"C\"  \"A\"  \"A\" \n [31] \"C\"  \"A\"  \"T\"  \"G\"  \"A\"  \"G\"  \"G\"  \"T\"  \"C\"  \"T\"  \"T\"  \"T\"  \"G\"  \"C\"  \"T\" \n [46] \"A\"  \"A\"  \"T\"  \"C\"  \"T\"  \"T\"  \"G\"  \"G\"  \"T\"  \"G\"  \"C\"  \"\\n\" \"T\"  \"T\"  \"T\" \n [61] \"G\"  \"C\"  \"T\"  \"T\"  \"C\"  \"C\"  \"T\"  \"G\"  \"C\"  \"C\"  \"C\"  \"C\"  \"T\"  \"G\"  \"G\" \n [76] \"C\"  \"T\"  \"G\"  \"C\"  \"T\"  \"C\"  \"T\"  \"G\"  \"G\"  \"G\"  \"G\"  \"A\"  \"A\"  \"A\"  \"G\" \n [91] \"T\"  \"C\"  \"T\"  \"T\"  \"T\"  \"G\"  \"G\"  \"A\"  \"C\"  \"G\" \n\nliso.nucl &lt;- liso.nucl[liso.nucl != \"\\n\"]\n# elimina a quebra de linha do resultado anterior\nliso.nucl[1:100]  # uma amostra do resultado sem os '\\n'\n\n  [1] \"G\" \"C\" \"A\" \"G\" \"T\" \"C\" \"C\" \"C\" \"G\" \"C\" \"T\" \"G\" \"T\" \"G\" \"T\" \"G\" \"T\" \"A\"\n [19] \"C\" \"G\" \"A\" \"C\" \"A\" \"C\" \"T\" \"G\" \"G\" \"C\" \"A\" \"A\" \"C\" \"A\" \"T\" \"G\" \"A\" \"G\"\n [37] \"G\" \"T\" \"C\" \"T\" \"T\" \"T\" \"G\" \"C\" \"T\" \"A\" \"A\" \"T\" \"C\" \"T\" \"T\" \"G\" \"G\" \"T\"\n [55] \"G\" \"C\" \"T\" \"T\" \"T\" \"G\" \"C\" \"T\" \"T\" \"C\" \"C\" \"T\" \"G\" \"C\" \"C\" \"C\" \"C\" \"T\"\n [73] \"G\" \"G\" \"C\" \"T\" \"G\" \"C\" \"T\" \"C\" \"T\" \"G\" \"G\" \"G\" \"G\" \"A\" \"A\" \"A\" \"G\" \"T\"\n [91] \"C\" \"T\" \"T\" \"T\" \"G\" \"G\" \"A\" \"C\" \"G\" \"A\"\n# Alguns cálculos manuais com a sequência de bases\n\nlength(liso.nucl[liso.nucl == \"A\"])\n\n[1] 133\n\n# quantifica as bases de purina na sequência\n\ntable(liso.nucl)  # contagem de cada nucleotídio\n\nliso.nucl\n  A   C   G   T \n133 173 174 108 \n\nlibrary(seqinr)\nliso.nucl2 &lt;- tolower(liso.nucl)  # a biblioteca seqinr opera com \n# letras minúsculas, havendo a necessidade de conversão das maiúsculas obtidas\n# pelo FASTA seqinr::count(liso.nucl2,1) # a mesma operação acima, mas com a\n# biblioteca seqinr, e outro formato de chamada\n\n# Outros cálculos seqinr:: count(liso.nucl2, 1 ) seqinr::count(liso.nucl2,2) #\n# teor de dinucleotídios seqinr::count(liso.nucl2,3) # teor de trinucleotídios\nnucls &lt;- table(liso.nucl)\nGC &lt;- 100 * (nucls[2] + nucls[3])/(nucls[1] + nucls[2] + nucls[3] + nucls[4])\ncat(\"percentual de conteúdo GC em lisozima de galinha: \", round(GC, 3))\n\npercentual de conteúdo GC em lisozima de galinha:  59.014\n\nGC(liso.nucl) * 100  # o mesmo comando anterior, mas com a biblioteca seqinr\n\n[1] 59.01361\n\n# contag.liso &lt;- count(liso.nucl2,2) barplot(sort(contag.liso)) # gráfico de\n# barras do teor de dinucleotídios organizado por frequência\n\n# Conversão de sequência nucleotídica em numérica\nliso.nucl.numer &lt;- gsub(\"T\", \"4\", gsub(\"G\", \"3\", gsub(\"C\", \"2\", gsub(\"A\", \"1\", liso.nucl))))  # substitui bases por valores\nliso.nucl.numer2 &lt;- as.numeric(liso.nucl.numer)\nliso.nucl.numer2[1:100]  # 100 primeiros valores da sequência\n\n  [1] 3 2 1 3 4 2 2 2 3 2 4 3 4 3 4 3 4 1 2 3 1 2 1 2 4 3 3 2 1 1 2 1 4 3 1 3 3\n [38] 4 2 4 4 4 3 2 4 1 1 4 2 4 4 3 3 4 3 2 4 4 4 3 2 4 4 2 2 4 3 2 2 2 2 4 3 3\n [75] 2 4 3 2 4 2 4 3 3 3 3 1 1 1 3 4 2 4 4 4 3 3 1 2 3 1\n\n# Obs: também pode ser obtido pelas funções s2n e n2s do pacote seqinr\n\nseq.liso &lt;- seq(1:length(liso.nucl))\nplot(seq.liso, as.vector(liso.nucl.numer2), type = \"l\", xlim = c(100, 300), main = \"Sequência de bases entre  resíduos 100 a 300\",\n    sub = \"A=1;C=2;G=3;T=4\")\n\n\n\n\n\n\n\n# Obtenção de sequência complementar\ncomp.liso.nucl &lt;- seqinr::comp(liso.nucl)\nhead(seqinr::c2s(comp.liso.nucl), 50)  # apresenta os primeiros \n\n[1] \"cgtcagggcgacacacatgctgtgaccgttgtactccagaaacgattagaaccacgaaacgaaggacggggaccgacgagacccctttcagaaacctgctacactcgaccgtcgccgatacttcgcagtgcctgaactattgatagcccctatgtcggaccctttgacccacacacggcgttttaagctctcattgaagttgtgggtccgatgtttggcattgtggctaccctcatggctgatgccttaggatgtctagttgtcggcgaccaccacgttgctaccgtcctggggtccgaggtccttggacacgttgtagggcacgagtcgggacgactcgagtctgtattgtcgctcgcacttgacgcgcttcttctagcagtcgctacctttgccgtacttgcgcacccagcggaccgcgttggcgacgttcccgtggctgcaggtccgcacctagtctccgacggccgacactcctcgacggcgcgggccgggcgggcgacgtgtcggccggcgaaacgctcgcgctgcgatgggcgaaccgtcaaaatttgcgtagggagtaattttgctgatatgcgtttgcgg\"\n\n# 50 nucleotídios complementares",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ácidos Nucleicos</span>"
    ]
  },
  {
    "objectID": "acnucleic.html#análise-de-sequências",
    "href": "acnucleic.html#análise-de-sequências",
    "title": "7  Ácidos Nucleicos",
    "section": "",
    "text": "Ácidos nucleicos podem ser considerados como sequências alfabéticas de 1 letra (bases), 2 letras (dinucleotídeo), ou de 3 letras (codon). Tomando-se o exemplo da lisozima de galinha:\n\nAcessa-se o banco de dados do NCBI - National Center for Biotechnology Information 1;\n\n\nSeleciona-se o banco de dados Nucleotide;\nDigita-se a sequência de interesse; ex: “hen egg” lysozyme”;\nSeleciona-se LYZF1 (ou a referência de sequência do NCBI: NM_205281.2); Obs: Com o número de referência é possível acessar o conteúdo desejado a partir de uma consulta simples no Google.\nProcura-se pela sequência referenciada em FASTA\nO sítio apresentará a sequência nucleotídica para a lisozima, que pode ser copiada/colada no R, ou exportada como arquivo em “Send to….File”.\n\n      Agora precisa-se converter esta sequência de letras (string) em um vetor de bases que possa ser lido pelo R, e omitindo-se a quebra de linha. Isso pode ser agilizado com o pacote seqinr ou TmCalculator pela função s2c (converte string em vetor de strings; c2s faz o oposto). Ou também pelo pacote stringr:\n\n      Com a sequência gênica em mãos pode-se avaliar um extenso conjunto de propriedades ou manipular o vetor de bases, tal como referenciado em alguns pacotes do R (seqinr, DNASeqtest, haplotypes, rDNAse). Também pode-se proceder algum manuseio mais simples para o gene selecionado, como abaixo:\n\n  Outras manipulações da sequência, como o conteúdo de pares GC, gráfico da sequência de dinucleotídios, conversão da sequência de bases em uma sequência numérica e sua plotagem, e obtenção da sequência de bases complementar, por exemplo, podem ser obtidos por:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ácidos Nucleicos</span>"
    ]
  },
  {
    "objectID": "acnucleic.html#termoestabilidade-de-dna",
    "href": "acnucleic.html#termoestabilidade-de-dna",
    "title": "7  Ácidos Nucleicos",
    "section": "7.2 Termoestabilidade de DNA",
    "text": "7.2 Termoestabilidade de DNA\n      Em relação à propriedades físico-químicas de ácidos nucleicos, é bem conhecida a relação entre a termoestabilidade de DNA duplex e o conteúdo de pares GC, tal como explicitado pela relação empírica (Creighton et al. 2010):\n\\[\nTm=(81,5+16,6*log(\\frac{[Na^+]}{1+0,7*[Na^+]})+41*f_{GC}-\\frac{500}{L}-0,63\\%_f)\n\\tag{7.1}\\]\nOnde [Na\\(^{+}\\)] representa a concentração molar de sódio, f\\(_{GC}\\) a fração de pares GC da sequência, L seu comprimento, e %\\(_{f}\\) o teor de formamida.\n      Dessa forma é possível prever o valor de Tm (“melting temperature”) que indexa a termoestabilidade de uma sequência polinucleotídica em função do teor salino. Ilustrando-se para uma comparação entre a sequência da lisozima de galinha e a humana (NCBI ref. NC_000012.12), na ausência de formamida:\n\n# Comparação de curvas de desnaturação\n\n# Para lisozima de galinha:\ngc.teor &lt;- seqinr::GC(liso.nucl)  # teor de pares GC da lisozima\n\nNa.conc &lt;- seq(0.005, 0.2, 0.001)  # concentração de NaCl, mmol/L\n\nTm.Na &lt;- (81.5 + 16.6 * log10(Na.conc/(1 + 0.7 * Na.conc)) + 41 * gc.teor - 500/length(liso.nucl))\n# valor de Tm para a de galinha\n\n# Para a lisozima humana\n\nliso.nucl.h &lt;- \"AGCCTAGCACTCTGACCTAGCAGTCAACATGAAGGCTCTCATTGTTCTGGGGCTTGTCCTCCTTTCTGTT\nACGGTCCAGGGCAAGGTCTTTGAAAGGTGTGAGTTGGCCAGAACTCTGAAAAGATTGGGAATGGATGGCT\nACAGGGGAATCAGCCTAGCAAACTGTAAGTCTACTCTCCATAATTCCAGAGAATTAGCTACGTATGGAAC\nAGACACTAGGAGAGAAGGAAGAAGAAGAAGGGGCTTTGAGTGAATAGATGTTTTATTTCTTTGTGGGTTT\nGTATACTTACAATGGCTAAAAACATCAGTTTGGTTCTTTATAACCAGAGATACCCGATAAAGGAATACGG\nGCATGGCAGGGGAAAATTCCATTCTAAGTAAAACAGGACCTGTTGTACTGTTCTAGTGCTAGGAAGTTTG\nCTGGGTGCCTGAGATTCAATGGCACATGTAAGCTGACTGAAAGATACATTTGAGGACCTGGCAGAGCTCT\nCTCAAGTCCTTGGTATGTGACTCCAGTTATTTCCCATTTTGAACTTGGGCTCTGAGAGCCTAGAGTGATG\nCAGTATTTTTCTTGTCTTCAAGTCCCCTGCCGTGATGTGGGATTTTTATTTTTATTTTTATTTTATTTTA\nTTTTATTTTTAAAGACAGTCTCACTGTGTGGCCCAGGCTGGAGTGCAGTGGCATGATCTCAGCTCACTGC\nAACCTCTGCCTTCTGGGCTCAAGTGATTCTCGTGCTTCAGCCTTCTGAGTAGCTGTGACTACAGGTGTGT\nACCACCACACCCAGCTAATTTTTTGTATTTTCAGTACAGATGGGGTTTCACCATGTTGGCCAAGCTGGTC\nTTGAACTCCTGGCCTCAAATGATCTGCCCACCTCAGCCTCCCAAAGTGGTAGGATTACAGGTGTGAACCA\nCTGCACCCAGCCGACATGGGATTTTTAACAGTGATGTTTTTAAAGAATATATTGAATTCCCTACACAAGA\nGCAGTAGGAACCTAGTTCCCTTCAGTCACTCTTTGTATAGGATCCCAGAAACTCAGCATGAAATGTTTTA\nTTATTTTTATCTACTCTACTTGATTAACTATCTTTCATTTTCTCCCACACAATTCAAGATGTGCCATGAG\nGAAAAGTTATTTTATAGTTTAGTACATAGTTGTCGATGTAATAATCTCTGTAGTTTTCAGATTGAATTCA\nGACATTTCCCCTCAATAGCTATTTTTGAATGAATGAGTGAAGGGATGAAATCACGGAATAGTCTTGTTTT\nCAAGATTCTAACTTGATATCCAAATTCACCTTTAGATATTATAAGAAAATTTCTATCAGAAAATCCTTAT\nGTTTTTCTGATTAAAAAAAGCATTTTTCCATCAGCCTATGTATCTGCTATGAATTTACAAAATCTACTCA\nACAGCTCTGTTGATTTTTCTGTTCTTGGCTGAATGTTGCCTGAGGGATGGGAGCACGGGAAGGGTAAAAG\nCAATGGAACAAACATGTATTTTAATATTTTAAAAGTATGTTATATTGTTCGTTGGTGTTACAAGATGATT\nTGCATTACAAAAGGATTCTCTTACAAGTCCCTTATCTTAACACTAAAGTGCTAAGATATTTTATAAGTAA\nATCTTTATACTTATAAAACAAATCAGTAAAATAGAAGTAGCTAAGTAGAACTGATTTTGCTATAGAGTAT\nAAGTCACTTAGTGTTGCTGTTTATTACTAAAAATAAGTTCTTTTCAGGGATGTGTTTGGCCAAATGGGAG\nAGTGGTTACAACACACGAGCTACAAACTACAATGCTGGAGACAGAAGCACTGATTATGGGATATTTCAGA\nTCAATAGCCGCTACTGGTGTAATGATGGCAAAACCCCAGGAGCAGTTAATGCCTGTCATTTATCCTGCAG\nTGGTAAGACAAGCTAATATTTGACCAATCTGGTTATACTTACAAGAATTGAGACTCAATACAAATGAAAA\nAGCCTTGAAAGGTTCATGAGGGACCTAGAAAAACTACATCTCAACTTCCAGAAAGTCATTATTATTTTCC\nTCATAATTCCCTGAGTAAGAAATTAAAGAAGTGGTATCATAAAAGGTTGATGTTTTTTAATATACAGAAG\nTTTCTGGAATGACCTATTAATTTACTGTCAATGGCCTTACTGATGCTTTGTCCAGAACAATGCCATTGCT\nCCTGCTTACTTTGGGGAGGTTTTGGGATAATTTAGTTGTATGGTCCTTTTTCAATTGTTTTACTTTTTTT\nTTTATGAAATGTTCTAAATGTATAGAAAATTAGAGACATTAGTATAATAAACAGCCATATGCCCATTATG\nCACTTTAAAAGTTGTTAACATTTTGCCATAGTTGCTTCTTCTATGCCTTTTTTTTTTTTTTTTTTTTTTT\nTTTTTTTTTGCTGAGAGTTTTTTGTTTGGTTTTGTTTTGTTTTATTTTGAGACAGGGTCTCCCTGTCCCC\nAGGCTGTAGTGCAGTGGCACCATCACAGCTCACTGCAGCCTCAAGTGATCATCCCACCACAGCCTCCCAA\nGTAGCTGGGACTACAGGTGTGCACCACCATGCCTGGCAAATTTTTGAAATTTTTAGTACAGGCAAATTCT\nGTGTTGCCCAGGCTGGTCTTGAACTCCTGAGTTCAAGCAATCTTCCCACCTCAGCCTCCTTAAGTGCTGG\nAATTACAGGCGTTAGCCACTGTACCTGGCTACTGCTGAGAGACTTTTAAGTGAATTAGGAACATGATGAT\nATTCCATTTCTAAATTCTTTAGTTTACATCTTCAAAAAATACAGTTCCTGTAGAATTATTATTGTAAATA\nACAAATTAACTTAAGGATTTATTTATTTGGAGTGAAACAAATATTTTACTGAACTCATAAAAATAGAAAT\nACCATGTGGAATCCTCAGTGTCAAAAATATTGCAGAAATCTTGCAAAGTTGATATTATTAAATTGTTAAA\nTATTAAAATTCCCAATAAAGAACATTAATCTTATTTCTAAAATCCAGTTAATTAAAAAAATTTATATTAT\nATAATAATATTTGGTCATTAAATAAAAATTAGAAAATACAAATAAGAAAAATAACACCCATAATCTTACT\nACCCAGAGGTTTATAACCATGGGTAAATTCTGGTATATATTCTTCCAGAATGTATATCAATCATGTGTAT\nGAATGTTAAATTATATCATACACATATAAACCCACATACAAACATGTAAATACTGTGTGCTTTTGCAAAA\nATTAAATTGTATTATACACACGGCTTTACAATTTGCTTCTTATCACACAAAATTATTTGCATGTCAGCAA\nATACAAATCGGTTTTTAATGATCTTTTGCTCCATTTTCCAGATGAGAAAAAAATACAAATCTGTATCATC\nATTTTAAAAGAATGACTAGAATTTTAATATATGAATATTCTATAATTTACTGATCCAATTGTTACTATTG\nAGCACTTAGGTTGTTTCCATTTTTCCCTCATAAATTGCTATGAATAGCTTTTTGTATACATCTTTGGGTG\nCATTTCTTATTTCTTTTGGATAAATTTTCAATAATAGAACTGCTGAGTAAAATATCACTAGGTGTTTTTT\nTACAGTGTCTAGTGCAAAGAAGACCTTTAATCATTTTGTTAATACTTCCAGAGCTTCCAATGACTTTGGT\nAAATGAAGAAAAAAATGCTTCATTTCATGCTGAATGGGAGAGAATGAAGAGAGTTTTCCCCAACAATTAC\nACATATATGGACTCATAGAAAATAATATCTTACCATTCTTTCCACAGCCTAACAGAAAAAAGCTGGCTAA\nACCTAAATTTAAAATAAAATATCTATTAAAGTTTTTATTCCTTACCACCTGTCTTTCAGCTTTGCTGCAA\nGATAACATCGCTGATGCTGTAGCTTGTGCAAAGAGGGTTGTCCGTGATCCACAAGGCATTAGAGCATGGT\nATGTTTTAAGTGTTAAAAGGGAAAACTATCTTACTCTACTGTTGATATATACAATGAGAGCAGACTTTTA\nAAGACCAAAGTATGCTAATGACACCTCAAAATTGCAGCTTTTGGCTTATGCTAAATGATGTATTACCTAC\nATCCTTGAAGAAACAATCTACTTTAACTGATCCAGAATCTTACTCTTTTACTCCTCAATTTATTTTAGGG\nGATTTCTAGAGTTTTAAGATGCTTCACACTCTATCAGTTCCTTGTCATATCTTGAAATTCTTTTTAGAAT\nAAGTAAGTGTGGGCCGGGCACAGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGACCGAGGCAGATGG\nATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGCCTAACATGGCAAAACCCCATCTCCACTAAAAATACA\nAAAAATTAGCTGGGTGTGGTGGCAGGTGCCTGTAATCCCAGCCACTCGGGAGGCTGAGGCAGGAGACTTG\nCTTGAACCCGGGAGGTGGAGGTTGCAGAGGATTGCGCCATTGTACTTCAGCCTGGGCGACAGAGTGAGAC\nTCTGTCTCAAATAAATACATAAAAAATAAATGTGGAATTCACTTTGCAGTTGCTGCTGTACAACGCACAT\nTACTCAATCTTTATGTTCGGCATTCTATGCTCTACTGAGAAATTTGGGTAGGAGTGAAGTATTTTGTATA\nCATATCTTCATTTAATAAATAGCAATAGCTGGGTCTATCTTACTATTTTATCTATTGATAAAATATTTTG\nTTTCCCCAAGGAGTGCGAAGTATGTATATTACAATGAAGATATGTTTTAACCTTTCACCATTTGCTTCAT\nCTTTTTCTACAGGGTGGCATGGAGAAATCGTTGTCAAAACAGAGATGTCCGTCAGTATGTTCAAGGTTGT\nGGAGTGTAACTCCAGAATTTTCCTTCTTCAGCTCATTTTGTCTCTCTCACATTAAGGGAGTAGGAATTAA\nGTGAAAGGTCACACTACCATTATTTCCCCTTCAAACAAATAATATTTTTACAGAAGCAGGAGCAAAATAT\nGGCCTTTCTTCTAAGAGATATAATGTTCACTAATGTGGTTATTTTACATTAAGCCTACAACATTTTTCAG\nTTTGCAAATAGAACTAATACTGGTGAAAATTTACCTAAAACCTTGGTTATCAAATACATCTCCAGTACAT\nTCCGTTCTTTTTTTTTTTGAGACAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCAATCTCGGC\nTCACTGCAACCTCCACCTCCCGGGTTCACGCCATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACG\nGGCGCCCGCCACCACGCCCGGCTAATTTTTTGTATTTTTAGTAGAGACAGGGTTTCACCGTGTTAGCCAG\nGATGGTCTCGATCTCCTGACCTTGTGATCCACCCACCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTG\nAGCCACTGCGCCCGGCCACATTCAGTTCTTATCAAAGAAATAACCCAGACTTAATCTTGAATGATACGAT\nTATGCCCAATATTAAGTAAAAAATATAAGAAAAGGTTATCTTAAATAGATCTTAGGCAAAATACCAGCTG\nATGAAGGCATCTGATGCCTTCATCTGTTCAGTCATCTCCAAAAACAGTAAAAATAACCACTTTTTGTTGG\nGCAATATGAAATTTTTAAAGGAGTAGAATACCAAATGATAGAAACAGACTGCCTGAATTGAGAATTTTGA\nTTTCTTAAAGTGTGTTTCTTTCTAAATTGCTGTTCCTTAATTTGATTAATTTAATTCATGTATTATGATT\nAAATCTGAGGCAGATGAGCTTACAAGTATTGAAATAATTACTAATTAATCACAAATGTGAAGTTATGCAT\nGATGTAAAAAATACAAACATTCTAATTAAAGGCTTTGCAACACA\"\n\nliso.nucl.h &lt;- unlist(strsplit(liso.nucl.h, \"\"))\n# converte sequência gênica de uma palavra em nucleotídios separados\nliso.nucl.h &lt;- liso.nucl.h[liso.nucl.h != \"\\n\"]\n# elimina a quebra de linha do resultado anterior\n\ngc.teor.h &lt;- seqinr::GC(liso.nucl.h)  # teor de pares GC da lisozima hunana\n\nTm.Na.h &lt;- (81.5 + 16.6 * log10(Na.conc/(1 + 0.7 * Na.conc)) + 41 * gc.teor.h - 500/length(liso.nucl.h))\n# valor de Tm para a humana\n\n# Curvas de simulação\nplot(Na.conc, Tm.Na, type = \"l\", col = 2, xlab = \"[Na+], M\", ylab = \"Tm, oC\")\nlines(Na.conc, Tm.Na.h, type = \"l\", col = 3)\nlegend(x = 0.13, y = 78, legend = c(\"galinha\", \"humana\"), col = c(2, 3), cex = 1,\n    lty = c(1, 2))\n\n\n\n\nComparação entre a curvas simuladas de Tm para a sequência nucleotídica da lisozima de galinha e lisozima humana, em função do teor de NaCl do meio.\n\n\n\n\n      Observe como a diferença no teor de GC tem efeito direto na termoestabilidade de fitas duplas de DNA. Uma observação: embora a faixa do valor de Tm relatado na literatura para a lisozima encontra-se em torno de 74\\(^o\\)C, esse valor refere-se à desnaturação cooperativa da enzima em solução aquosa, e não ao desenovelamento de sua sequência gênica de DNA duplex.\n\n\n\n\nCreighton, Thomas E et al. 2010. biophysical chemistry of nucleic acids & proteins. Distributed by Gardners Books.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ácidos Nucleicos</span>"
    ]
  },
  {
    "objectID": "acnucleic.html#footnotes",
    "href": "acnucleic.html#footnotes",
    "title": "7  Ácidos Nucleicos",
    "section": "",
    "text": "NCBI. https://www.ncbi.nlm.nih.gov/protein↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ácidos Nucleicos</span>"
    ]
  },
  {
    "objectID": "membranas.html",
    "href": "membranas.html",
    "title": "8  Membranas",
    "section": "",
    "text": "8.1 Concentração micelar crítica (CMC)\n\\[\ny_1 = y_2 \\\\\na_1+b_1*x = a_2+b_2*x\\\\\na_1-a_2 = b_2*x-b_1*x\\\\\na_1-a_2 = x(b_2-b_1)\\\\\nx = \\frac{a_1-a_2}{b2-b1}\n\\tag{8.1}\\]\n# Determinação de concentração micelar crítica (CMC)\n\nconc &lt;- c(1e-05, 0.00179, 0.00357, 0.00527, 0.00881, 0.0106, 0.0141, 0.0159)\n# teor do corante (mol/L)\nA385 &lt;- c(0.003, 0.421, 0.712, 0.905, 1.09, 1.17, 1.41, 1.47)\n# absorbância em 385 nm\n\n# Gráfico\nplot(A385 ~ conc, xlab = \"[amarelo ácido 29]\", ylab = \"Abs 385\")\n\n# Ajuste linear para 2 conjuntos de dados\n\n# 1o. conjunto\nlinCmc1 &lt;- lm(A385 ~ conc, subset = (conc &lt; 0.007 & conc &gt; 0))\n# 1o. ajuste linear com limites\nabline(linCmc1, col = \"blue\", lty = \"dotted\")  # linha de regressão\n\n# 2o. conjunto:\nlinCmc2 &lt;- lm(A385 ~ conc, subset = (conc &lt; 0.02 & conc &gt; 0.007))\n# 2o. ajuste linear com limites\nabline(linCmc2, col = \"blue\", lty = \"dotted\")  # linha de regressão\n\n\n\n\n\n\n\n# Cálculo de CMC por intersecção das automática das duas retas:\ncmc_auto &lt;- abs((coef(linCmc2)[1] - coef(linCmc1)[1])/(coef(linCmc1)[2] - coef(linCmc2)[2]))\nas.numeric(cmc_auto)  # fornece o cmc em mol/L\n\n[1] 0.004642773",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Membranas</span>"
    ]
  },
  {
    "objectID": "membranas.html#concentração-micelar-crítica-cmc",
    "href": "membranas.html#concentração-micelar-crítica-cmc",
    "title": "8  Membranas",
    "section": "",
    "text": "A concentração micelar crítica refere-se ao teor de um surfactante mínimo acima do qual esse pode reorganizar-se em micelas ou lipossomos. É bastante utilizado na caracterização de tais compostos, como biosurfactantes na indústria, e pode ser medido por diversas técnicas, incluindo tensão superficial, fluorescência de polarização, turbidimetria e absorção molecular (fotometria).\n      De modo geral a determinação de cmc é obtida pelo valor da concentração do surfactante no ponto de cruzamento de duas retas obtidas por ajuste linear dos dados em baixo e alto teor do analito, como segue:\n\n      O ponto de intersecção pode ser obtido manualmente, pelo comando locator já referido, ou de forma automática. Nesse caso, o exemplo do R que ilustra esse cálculo baseia-se em resultados de espectrofometria obtidos para um corante, o amarelo ácido 29 (Duff e Giles 1972).\n\n      O valor encontrado pelos autores foi de 0,004 mol/L.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Membranas</span>"
    ]
  },
  {
    "objectID": "membranas.html#transporte-em-membranas-e-teoria-quimiosmótica",
    "href": "membranas.html#transporte-em-membranas-e-teoria-quimiosmótica",
    "title": "8  Membranas",
    "section": "8.2 Transporte em membranas e Teoria Quimiosmótica",
    "text": "8.2 Transporte em membranas e Teoria Quimiosmótica\n      O equilíbrio de transporte de solutos por membranas envolve um formalismo que abrange o potencial eletroquímico dos solutos envolvidos, suas concentrações (ou atividade), cargas, potenciais elétricos e volumes parciais em unidade molal. À despeito dessa complexidade, contudo, podemos ilustrar o transporte de íons H⁺ de modo simplificado, seguindo-se a equação abaixo:\n\\[\n\\Delta G_{transp}=2.303(RT*log\\frac{H^+_{in}}{H^+_{out}}) + z * F * \\Delta \\phi\n\\]\nOnde F representa a constante de Faraday, 96485 J\\(^{-1}\\)\\(V^{-1}\\)\\(mol^{-1}\\) (também representado como 1 mol de elétrons), e z a carga do íon equanto que \\(\\Delta\\)\\(\\phi\\) representa a variação de potencial elétrico, e \\(\\Delta\\)pH a variação do valor de pH, ambos obtidos por medições entre o lado interno (matriz mitocondrial) e externo (espaço intermembranas). H\\(^{+}\\)\\(_{in}\\) e H\\(^{+}\\)\\(_{out}\\) representam o teor de prótons do lado interno e externo da membrana, respectivamente.\n      Agora, considerando a carga unitária de H⁺ e a definição para pH (-log H⁺),\n\\[\n\\Delta G_{transp}=\\Delta \\phi * F-2.303RT*\\Delta pH\n\\]\n      Tangente ao transporte de solutos e íons por membranas celulares, é possível prever-se, por exemplo, o teor de ATP formado durante a fosforilação oxidativa que envolve o retorno de íons H⁺ do espaço intermembranas à matriz mitocondrial. Ilustrando-se, considerando um valor de \\(\\Delta\\)\\(\\phi\\) de 70 mV e um \\(\\Delta\\)pH de 1,4 para as medidas entre matriz e espaço intermembranas mitocondriais, prevê-se a obtenção de ATP pelas relações que seguem, considerando a energia de 31 kJ/mol de ATP :\n\n# Teor previsto de ATP durante fosforilação oxidativa\n\nR &lt;- 8.341  # J/mol\nT &lt;- 298  # K\nF &lt;- 96485  # constante de Faraday\nDphi &lt;- 0.07  # variação de potencial elétrico in/out membranas\nDpH &lt;- -1.4  # variação de pH in/out membranas\nDG_transp &lt;- F * Dphi - 2.303 * R * T * DpH  # equação de transporte\nDG_transp_4 &lt;- 4 * DG_transp  # 4 mol de H+\n\n# Considerando cada mol de ATP para 31 kJ/mol...\nDG_transp_4/31000\n\n[1] 1.905559\n\n\n      Percebe-se, portanto, a produção de 2 mols de ATP nas condições explicitadas.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Membranas</span>"
    ]
  },
  {
    "objectID": "membranas.html#proteínas-de-transporte-em-membranas",
    "href": "membranas.html#proteínas-de-transporte-em-membranas",
    "title": "8  Membranas",
    "section": "8.3 Proteínas de transporte em membranas",
    "text": "8.3 Proteínas de transporte em membranas\n      Enquanto prótons como H\\(^{+}\\) são transportados em função de seu gradiente de concentração entre o lado interno e externo de membranas, outros compostos e solutos dependem de uma proteína transportadora, como glicose e ácido cítrico. Nesse caso, o transporte não é passivo, mas de difusão facilitada, e seu comportamento cinético pela membrana obedece o formalismo de Michaelis-Menten como segue.\n\\[\nv_{transp}=\\frac{V_{max}*S_{out}}{K_{transp}+S_{out}}\n\\]\n      Onde, analogamente, V\\(_{max}\\) representa a velocidade máxima (ou limite) de transporte do substrato, S\\(_{out}\\) o teor do substrato transportado, e K\\(_{transp}\\) a constante de dissociação do complexo proteína-substrato (ou concentração do substrato a meia saturação do transportador).\n\n\n\n\nDuff, DG, e CH Giles. 1972. «Spectrophotometric determination of the critical micelle concentration of surfactants». Journal of Colloid and Interface Science 41 (3): 407–14.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Membranas</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html",
    "href": "bioenergetica.html",
    "title": "9  Bioenergética",
    "section": "",
    "text": "9.1 Solução de sistema de equações lineares no R\n\\[\n\\Delta G = \\Delta H - T * \\Delta S\n\\tag{9.1}\\]\n\\[\nN \\rightleftarrows D\n\\tag{9.2}\\]\n\\[\nK_{eq} = \\frac{[D]}{[N]}\n\\tag{9.3}\\]\n\\[\n\\Delta G = - R*T*ln(K_{eq})\n\\tag{9.4}\\]\nOnde \\(K_{eq}\\), [D], e [N] representam, respectivamente, a constante de equilíbrio de desnaturação da proteina, bem como as concentrações dessa na forma desnaturada e nativa.\nEm \\(35^{o}\\)C: \\(\\Delta\\)G\\(_{desn}\\) = \\(\\Delta\\)H\\(_{desn}\\) - 308 * \\(\\Delta\\)S\\(_{desn}\\) = +4,4 kJ \\(mol^{-1}\\)\nEm \\(45^{o}\\)C: \\(\\Delta\\)G\\(_{desn}\\) = \\(\\Delta\\)H\\(_{desn}\\) - 318 * \\(\\Delta\\)S\\(_{desn}\\) = -5,2 kJ \\(mol^{-1}\\)\n\\[\na_{11}*x_1 + a_{12} * x_2 = b_1\n\\\\\na_{21}*x_1 + a_{22} * x_2 = b_2\n\\tag{9.5}\\]\nOnde \\(x_1\\) e \\(x_2\\) representam, respectivamente, \\(\\Delta\\)H\\(_{desn}\\) e \\(\\Delta\\)S\\(_{desn}\\).\n\\[\na_{11}*x_1 + a_{12} * x_2 = b_1\n\\\\\na_{21}*x_1 + a_{22} * x_2 = b_2\n\\tag{9.6}\\]\n\\[\nA = \\begin{bmatrix}\na_{11} & a_{12}\\\\\na_{21} & a_{22}\n\\end{bmatrix} ,\n\\]\n\\[\nx = \\begin{bmatrix}\nb_1\\\\\nb_2\n\\end{bmatrix} ,\n\\]\n\\[\nb = \\begin{bmatrix}\nx_1\\\\\nx_2\n\\end{bmatrix}\n\\]\n\\[\nx = A^{-1} * b\n\\tag{9.7}\\]\n\\[\nA = \\begin{bmatrix}\n1 & -308\\\\\n1 & -318\n\\end{bmatrix} ,\n\\]\n\\[\nb = \\begin{bmatrix}\n+4,4\\\\\n-5,2\n\\end{bmatrix}\n\\]\n# Definição de matrizes\nA &lt;- matrix(c(1, -308, 1, -318), ncol = 2, byrow = TRUE)  # matriz A; \n# o sinal negativo decorre da função possuir inclinação negativa\nb &lt;- matrix(c(4.4, -5.2), ncol = 1)  # matriz b\n# Solução matricial para sistema linear\nsolve(A) %*% b  #  # a operação %*% indica o produto escalar de dois \n\n       [,1]\n[1,] 300.08\n[2,]   0.96\n\n# vetores ('dot product')\n\\[\n\\begin{pmatrix}\n  1  \\\\\n  2 \\\\\n  3  \\\\\n\\end{pmatrix} *\n\\begin{pmatrix}\n  1 & 2 & 3 \\\\\n\\end{pmatrix}\n= \\begin{pmatrix}\n  1 & 2 & 3  \\\\\n  2 & 4 & 6 \\\\\n  3 & 6 & 9 \\\\\n\\end{pmatrix}\n\\tag{9.8}\\]\n\\[\nln \\, K_{eq} = - \\frac{\\Delta H}{R} * \\frac{1}{T} + \\frac{\\Delta S}{R}\n\\] {?eq-eqVHoff}\n\\[\n\\beta = (X^T \\; X)^{-1} \\; X^T*y\n\\tag{9.9}\\]\n\\[\nX = \\begin{bmatrix}\n1 & x_{1}\\\\\n1 & x_{2}\\\\\n1 & x_{3}\\\\\n... & ...\n\\end{bmatrix}\n\\]\n# Solução matricial para os parâmetros cinéticos de Lineweaver-Burk\n\n# Repetindo os dados para as variáveis de Lineweaver-Burk\nS &lt;- seq(0.1, 1, length.out = 20)  # gera uma sequência com 20 pontos\n# entre 0 e 1 para valores de substrato\nVm &lt;- 10\nKm &lt;- 0.5  # parâmetros cinéticos\nset.seed(1500)  # estabelece a mesma semente aleatória do gráfico direto\n# de Michaelis-Menten, para reproducibilidade dos pontos\nerro &lt;- runif(20, 0, 1)  # comando para erro uniforme (no. de pontos, min, max)\nv &lt;- Vm * S/(Km + S) + erro  # equação de Michaelis-Menten\ninv.S &lt;- 1/S  # cria variáveis para o duplo-recíproco\ninv.v &lt;- 1/v\n\n# Criação das matrizes A e b\nA2 &lt;- matrix(c(rep(1, 20), inv.S), nrow = 20, byrow = FALSE)  # cria matriz\n# com valor unitário necessário antes da variável independente\nb2 &lt;- as.matrix(inv.v, nrow = 1, byrow = FALSE)  # vetor b\n\n# Solução matricial do ajuste linear\nbeta &lt;- solve(t(A2) %*% A2) %*% t(A2) %*% b2\nbeta\n\n           [,1]\n[1,] 0.11363419\n[2,] 0.03277244",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#solução-de-sistema-de-equações-lineares-no-r",
    "href": "bioenergetica.html#solução-de-sistema-de-equações-lineares-no-r",
    "title": "9  Bioenergética",
    "section": "",
    "text": "Pra solucionar o problema da seção anterior pelo R, define-se inicialmente a matriz para A e a matriz para b tal que:\n\n\nAssim,\n\n  Conforme representado na Equação 9.7, a solução matricial pode ser obtida pelo comando solve:\n\n      Nesse caso, os parâmetros termodinâmicos encontrados foram \\(\\Delta\\)H\\(_{desn}\\) = 300 kJ \\(mol^{-1}\\) e \\(\\Delta\\)S\\(_{desn}\\) = 960 J \\(mol^{-1}\\).\n      Observe a notação “%*%” para a multiplicação de duas matrizes na última linha do código. Trata-se de multiplicação cruzada ou dot product de duas matrizes. A multiplicação de matrizes é definida somente para duas matrizes dimensionalmente compatíveis em uma dada ordem. Essa implica que o número de colunas da 1a. matriz seja igual ao número de linhas da 2a. matriz. Nesse caso a matriz resultante terá o mesmo número de linhas da 1a. matriz e o mesmo número de colunas da 2a. matriz. Veja o exemplo:\n\n      Outra observação também deve ser pontuada em relação à solução matricial de sistemas lineares. Uma reflexão rápida sobre a natureza linear da Equação 9.1 de Gibbs e de sua aplicação à solução de parâmetros termodinâmicos para o sistema de equações lineares acima sugere que poderíamos obter outros valores para \\(\\Delta\\)G a partir de outras temperaturas ensaiadas. Supondo que fossem, digamos, 5 ou 6 valores de T com seus respectivos valores de \\(\\Delta\\)G\\(_{desn}\\), e reforçando a premissa de que os parâmetros \\(\\Delta\\)H\\(_{desn}\\) e \\(\\Delta\\)S\\(_{desn}\\) permanecessem constantes ao longo da faixa termal, poderíamos facilmente concluir tratar-se de uma relação linear de \\(\\Delta\\)G\\(_{desn}\\) em função de \\(\\Delta\\)H\\(_{desn}\\) T.\n      Dessa forma, tal como visto no capítulo Capítulo 5, poderíamos solucionar os parâmetros \\(\\Delta\\)H\\(_{desn}\\) e \\(\\Delta\\)SH\\(_{desn}\\) por ajuste linear. De fato, uma das expressões de Van’t Hoff que definem esta relação linear é:\n\n      Outra consequência direta é a de que qualquer conjunto de pares de dados de variáveis dependente (y) e independente (x), e que exibem homogeneidade de variâncias e distribuição normal, tal como explicitado no capítulo Enzimas, pode também ser resolvido em seus parâmetros (intercepto e inclinação) com auxílio de álgebra matricial.\n      De fato, a solução matricial de ajuste linear pode ser obtida a partir da relação abaixo:\n\n     Portanto, o ajuste linear ilustrado na figura Figura 5.6 do capítulo Capítulo 5 também pode ser efetuado com auxílio de matrizes, embora alguns indicadores estatísticos apresentados na tabela gerada pela função lm sejam extraídos por outras funções do algoritmo de cálculos matriciais/estatísticos. Na equação Equação 9.9 o termo entre parênteses envolve a operação de inversão da matriz. Em álgebra linear não existe a operação de divisão para matrizes, mas somente a multiplicação de uma matriz por um escalar ou pela inversa de outra. E mesmo assim, somente se tratar-se de uma matriz quadrada. Dessa forma o termo (X\\(^{T}\\) X)\\(^{-1}\\) só pode ser calculado com inversão matricial. No R essa ação é dada pelo comando solve.\n    Com dantes, é vital importância também que a matriz X contendo a variável independente seja criada com valores unitários à esquerda, tal como segue:\n\n      Dessa forma, a solução do problema explicitado na figura Figura 5.6 do capítulo Capítulo 5, pode ser matricialmente resolvida como:\n\n      Veja que os valores de intercepto (\\(\\beta\\) 1) e inclinação (\\(\\beta\\) 2) aproximaram-se dos encontrados com auxílio da função lm do R.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#matrizes-e-r",
    "href": "bioenergetica.html#matrizes-e-r",
    "title": "9  Bioenergética",
    "section": "9.2 Matrizes e R",
    "text": "9.2 Matrizes e R\n      O emprego de matrizes na solução de problemas lineares e não lineares é bastante vasto. De fato, um ajuste linear é resolvido computacionalmente pelo uso de matrizes, mais do que por somatórias. Da mesma forma, alguns algoritmos para ajuste não linear também implementam álgebra matricial na solução de problemas (Gauss-Newton, Levenberg-Marquadt).\n      Dessa forma, é interessante uma rápida panorâmica no potencial de matrizes que o R possui.\n\n# Algumas manipulações com matrizes\n\n## Identificação de linhas e colunas\nres &lt;- matrix(c(-308, -318),\n  nrow = 2, byrow = TRUE, # definição de matriz\n  dimnames = list(c(\"Delta H\", \"Delta S\"), \"kJ/mol\")\n)\nres\n\n        kJ/mol\nDelta H   -308\nDelta S   -318\n\n## Operações aritméticas\nm1 &lt;- matrix(c(1, 2, 3, 4), nrow = 2, byrow = T)\nm2 &lt;- matrix(c(4, 5, 6, 7), nrow = 2, byrow = T)\nm1 + 5\n\n     [,1] [,2]\n[1,]    6    7\n[2,]    8    9\n\nm2 - 7 # soma ou subtração em escalar\n\n     [,1] [,2]\n[1,]   -3   -2\n[2,]   -1    0\n\nm1^2\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    9   16\n\nsin(m2) # potência ou trigonometria\n\n           [,1]       [,2]\n[1,] -0.7568025 -0.9589243\n[2,] -0.2794155  0.6569866\n\nm1 + m2 # soma de elementos em matrizes de igual dimensão\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    9   11\n\nm1 * m2 # multiplicação de elementos em matrizes de igual dimensão\n\n     [,1] [,2]\n[1,]    4   10\n[2,]   18   28\n\nm1 %*% m2 # produto cruzado de matrizes (\"dot product\" de vetores)\n\n     [,1] [,2]\n[1,]   16   19\n[2,]   36   43\n\ndet(m1) # determinante da matriz\n\n[1] -2\n\nt(m2) # transposição da matriz\n\n     [,1] [,2]\n[1,]    4    6\n[2,]    5    7\n\ndiag(m1) # matriz diagonal\n\n[1] 1 4\n\nsolve(m2) # inverso da matriz\n\n     [,1] [,2]\n[1,] -3.5  2.5\n[2,]  3.0 -2.0\n\neigen(m1) # autovalor (\"eingenvalue\") e autovetor (\"eigenvector\") da matriz\n\neigen() decomposition\n$values\n[1]  5.3722813 -0.3722813\n\n$vectors\n           [,1]       [,2]\n[1,] -0.4159736 -0.8245648\n[2,] -0.9093767  0.5657675\n\n\n      O R também permite várias outras operações utilizadas em cálculo numérico e simbólico que utilizam matrizes, tais como as funções kronecker (multiplicação matricial), svd (Single Decomposition Value), qr (Decomposição QR), e chol(Decomposição de Cholesky).",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#solução-de-parâmetros-termodinâmicos-de-estabilidade-enzimática",
    "href": "bioenergetica.html#solução-de-parâmetros-termodinâmicos-de-estabilidade-enzimática",
    "title": "9  Bioenergética",
    "section": "9.3 Solução de parâmetros termodinâmicos de estabilidade enzimática",
    "text": "9.3 Solução de parâmetros termodinâmicos de estabilidade enzimática\n     Parâmetros termodinâmicos, tais como os contidos na expressão de Van’t Hoff ?eq-eqVHoff podem ser também obtidos simultaneamente por álgebra matricial. Exemplificandos-se, é comum em Biotecnologia a avaliação de parâmetros de termoestabilidade de enzimas submetidas a estresse térmico (como também químico, como pH, ureia ou uso de proteases). Isso é feito no intuito de se verificar, por exemplo, se uma enzima pode resistir a temperaturas elevadas de processos industriais, para comparar enzimas modificadas por mutação sítio-dirigida, ou para se avaliar o comportamento de enzimas associadas a patogenesias diversas. O formalismo dessa análise passa pela Teoria das Colisões de Arrhenius, bem como pela Teoria do Estado de Transição de Eyring, resultando no sistema linear de equações como o que segue:\n\\[\n\\begin{cases}\\Delta G^\\ddagger = \\Delta H^\\ddagger-T* \\Delta  S^\\ddagger\n\\\\\nln(\\frac{kcat*h}{K_B*T})=-\\frac{1}{RT}*\\Delta H^\\ddagger + \\frac{1}{R}*\\Delta S^\\ddagger\n\\end{cases}\n\\tag{9.10}\\]\nOnde os termos com \\(\\ddagger\\) simbolizam as variações de quantidades referentes à ativação (ou desativação) da enzima (estado de transição do complexo ativado), \\(K_{B}\\) representa a constante de Boltzmann (1,381x10\\(^{-23}\\) JK\\(^{-1}\\)), h a constante de Planck (6,686x10\\(^{-34}\\) J*s), e R a constante geral dos gases (8,314 JK\\(^{-1}\\) mol\\(^{-1}\\)). Nem sempre é possível convergir uma solução matricial pela simples utilização de multiplicação cruzada (dot product).\n      O trecho de código abaixo exemplifica essa tentativa, a partir dos dados publicados por Riaz e cols (Bhatti et al. 2007) abaixo, e considerando previamente as matrizes A e b em função dos parâmetros explicitados pelos autores:\n\\[\n\\Delta G^{\\ddagger}=65920\\, J\\,mol^{-1} \\\\\nT = 328 K \\\\\nkcat = 217 s^{-1}\n\\tag{9.11}\\]\n\\[\nA = \\begin{bmatrix}\n1 & -328\\\\\n-3.67e-4 & 0.120\\\\\n\\end{bmatrix} ,\n\\]\n\\[\nb = \\begin{bmatrix}\n65920\\\\\n-24.17\\\\\n\\end{bmatrix}\n\\]\n\n# Tentativa de solução matricial simples em dados publicados (Appl. Microbiol.\n# Biotechnol, 73, 1290, 2007):\n\nA &lt;- matrix(c(1, -0.000367, -328, 0.12), nrow = 2, byrow = TRUE)\nb &lt;- matrix(c(65921, -24.17), nrow = 2)\nsolve(A) %*% b\n\n             [,1]\n[1,]    -21038593\n[2,] -57505488910\n\n\n      Perceba a inconsistência para os parâmetros termodinâmicos resultantes. A solução matricial pelo comando solve também sofre de resolução para o problema, incorrendo em erro se executada, tal como no trecho que segue. Observe também a possibilidade distinta para a construção das matrizes.\n\nAframe &lt;- data.frame(c(1, -0.000367), c(-328, 0.12))\nA &lt;- as.matrix(Aframe)\nb &lt;- as.matrix(c(65921, -24.17))\nsolve(t(A) %*% A) %*% t(A) %*% b\n\n      Para essas situações de maior complexidade pode ser de utilidade o emprego de pacotes do R, tal como o rootSolve já utilizado ou o nleqslv empregado anteriormente. Nesse sentido, a minimização de busca de raízes para o sistema de equações pode ser demonstrada a seguir:\n\nlibrary(rootSolve)\nT &lt;- 328\nR &lt;- 8.314\nh &lt;- 6.626e-34\nkb &lt;- 1.381e-23\nkcat &lt;- 217\nDG &lt;- -R * T * log((kcat * h)/(kb * T))  # 65920 J/mol\nmodel &lt;- function(x) c(x[1] - T * x[2] - DG, x[2]/R - x[1]/(R * T) - log((kcat *\n    h)/(kb * T)))\n(ss &lt;- multiroot(model, start = c(50000, 50000)))\n\n$root\n[1] 40843.50837   -76.45441\n\n$f.root\n[1]  2.110028e-09 -7.744916e-13\n\n$iter\n[1] 3\n\n$estim.precis\n[1] 1.055401e-09\n\n\n      Por esta solução numérica os valores encontrados para os parâmetros foram de \\(\\Delta\\) H\\(^{\\ddagger}\\) = 40,8 kJmol\\(^{-1}\\) e \\(\\Delta\\) S\\(^{\\ddagger}\\) = -76,5 Jmol\\(^{-1}\\)K\\(^{-1}\\).\n      Comparando-se os valores, os autores encontraram \\(\\Delta\\) H\\(^{\\ddagger}\\) = 33,3 kJmol\\(^{-1}\\) e \\(\\Delta\\) S\\(^{\\ddagger}\\) = -99,8 Jmol\\(^{-1}\\)K\\(^{-1}\\). Perceba a semelhança dos resultados obtidos pela minimização de raízes com os parâmetros encontrados pelos autores. A obtenção do valor de \\(\\Delta\\) H\\(^{\\ddagger}\\) para esses, contudo, foi obtida somente a partir da obtenção do valor experimental de energia de ativação de Arrhenius (Ea), pela inclinação de um gráfico linearizado da taxa de reação, tal como segue:\n\\[\\begin{equation}\nk = A *e^{-Ea/RT} \\\\\nln(k) = \\frac{\\Delta S^{\\ddagger}}{R} - \\frac{\\Delta H^{\\ddagger}}{R} * \\frac{1}{T}\n(\\#eq:Arrhenius)\n\\end{equation}\n\\]\n      Ainda que se perceba uma significativa adequação dos valores obtidos pelos autores e em uma única temperatura, há que se ter cautela com o procedimento, pois minimizações costumam exigir boas sementes de inicialização do algoritmo para surtir bons resultados. Além disso, a natureza própria da relação termodinâmica entre uma taxa de reação (tal como kcat) e a variação de energia de Gibbs resultante ocorre em escala exponencial:\n\\[\\begin{equation}\nk = f(kcat) = e^{-\\Delta G^{\\ddagger}/RT}\n(\\#eq:dGkcatRel)\n\\end{equation}\\]\n      Isso significa na prática que pequenas variações em \\(\\Delta\\) G\\(^{\\ddagger}\\) resultam em enormes variações no valor de k (no caso, de kcat). Por esta razão, diferenças mínimas no valor de \\(\\Delta\\) G\\(^{\\ddagger}\\) podem resultar em enormes diferenças em \\(\\Delta\\) H\\(^{\\ddagger}\\) e \\(\\Delta\\) S\\(^{\\ddagger}\\) para a solução do sistema linear. Exemplificando mais diretamente esse impacto, experimente alterar o valor de \\(\\Delta\\) G\\(^{\\ddagger}\\), arredondando-o:\n\nrequire(rootSolve)\nT &lt;- 328\nR &lt;- 8.314\nh &lt;- 6.626e-34\nkb &lt;- 1.381e-23\nkcat &lt;- 217\nDG &lt;- 66000\nmodel &lt;- function(x) c(x[1] - T * x[2] - DG, x[2]/R - x[1]/(R * T) - log((kcat *\n    h)/(kb * T)))\n(ss &lt;- multiroot(model, start = c(50000, 50000)))\n\n$root\n[1] 51579492242   157254348\n\n$f.root\n[1] 177.50881195  -0.09422566\n\n$iter\n[1] 3\n\n$estim.precis\n[1] 88.80152",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#entalpia-de-reação-por-matrizes",
    "href": "bioenergetica.html#entalpia-de-reação-por-matrizes",
    "title": "9  Bioenergética",
    "section": "9.4 Entalpia De Reação Por Matrizes",
    "text": "9.4 Entalpia De Reação Por Matrizes\n      Reações químicas são geralmente representadas pela equação que segue:\n\\[\\begin{equation}\n0 = \\sum_{i=1}^{N} \\nu_i B_i\n(\\#eq:eqReacGen)\n\\end{equation}\\]\n      Dessa forma, se observarmos as representações que acompanham as reações químicas, veremos que essas também constituem funções lineares, tal como nos exemplos abaixo:\n\\[\\begin{equation}\n2 C_2H_2(g)+ 5 O_2(g) \\rightleftarrows 4 CO_2(g) + 2 H_2O(l), \\Delta_fH^o = -2600 \\,\nkJ/mol\\\\\n2 C_2H6(g) + 7 O_2(g) \\rightleftarrows 4 CO_2(g) + 6 H_2O(l), \\; \\Delta_fH^o = -3210 \\, kJ/mol \\\\\nH_2(g) + \\frac{1}{2} O_2(g) \\rightleftarrows H_2O(l), \\; \\Delta_fH^o = -286 \\, kJ/mol\\\\\nC_2H_2(g) + 2H_2(g) \\rightleftarrows C_2H_6(g), \\; \\Delta_fH^o = ?\n(\\#eq:eqReac)\n\\end{equation}\\]\n      E, se selecionarmos algumas reações que possuem relações entre si, tal como as apresentadas na equação @ref(eq:eqReac) acima, teremos então um sistema de equações lineares, passível de solução por álgebra matricial. Essa relação entre reações químicas que envolvem a formação de compostos refere-se à Lei de Hess.\n      Matematicamente a Lei de Hess pode ser expressa como:\n\\[\\begin{equation}\n\\Delta_fH^o =  \\sum_{n=1}^{\\infty} \\nu \\Delta_fH^o_P - \\sum_{n=1}^{\\infty} \\nu \\Delta_fH^o_R\n(\\#eq:eqHess)\n\\end{equation}\\]\nOnde \\(\\nu\\) representa a estequiometria da reação, ou seja, o número de mols de cada composto/elemento, enquanto P e R referem-se à Produto e Reagente.\n      Retomando o exemplo da equação @ref(eq:eqReac), o que se deseja é obter o valor da entalpia de reação para o etano (\\(C_2H_6\\)), baseando-se nos valores de entalpia de reação das espécies correlatas (Khalil 2000). Há pelos três soluções possíveis, em que a entalpia de reação pode ser determinada pela entalpia de ligação, pela própria entalpia de formação, e pela Lei de Hess, essa passível de cálculo por matrizes.\n      Para isso, é necessário 1) compor as matrizes A e b, 2) calcular o vetor de coeficients beta, e 3) efetuar o produto escalar (%*%) de beta com uma matriz formada pelos valores de entalpia de formação. O racional para compor as matrizes envolve elencar cada composto com sua estequiometria de reação, e exige que para reagentes seja conferido valor negativo, enquanto que para produtos, valor positivo.\n      A tabela abaixo ilustra essa construção para o problema em questão.\n\nlibrary(knitr)  # para gerar a tabela\ncomp &lt;- c(\"C2H2\", \"O2\", \"CO2\", \"H2O\", \"C2H6\", \"H2\")  # elenco dos compostos envolvidos\nrea1 &lt;- c(-2, -5, +4, +2, 0, 0)  # estequiometria (reação1)\nrea2 &lt;- c(0, -7, +4, +6, -2, 0)  # estequiometria (reação2)\nrea3 &lt;- c(0, -0.5, 0, +1, 0, -1)  # estequiometria (reação3)\nincog &lt;- c(-1, 0, 0, 0, +1, -2)  # estequiometria da reação com entalpia desconhecida\ntab_esteq &lt;- data.frame(comp, rea1, rea2, rea3, incog)  # dataframe com os resultados\ncolnames(tab_esteq) &lt;- c(\"composto\", \"reação 1\", \"reação 2\", \"reação 3\", \"etano\")  # nomeia as colunas\nknitr::kable(tab_esteq, caption = \"Estequiometria reacional para solução matricial de formação de etano (C2H6).\",\n    \"pipe\")  # tabela\n\n\nEstequiometria reacional para solução matricial de formação de etano (C2H6).\n\n\ncomposto\nreação 1\nreação 2\nreação 3\netano\n\n\n\n\nC2H2\n-2\n0\n0.0\n-1\n\n\nO2\n-5\n-7\n-0.5\n0\n\n\nCO2\n4\n4\n0.0\n0\n\n\nH2O\n2\n6\n1.0\n0\n\n\nC2H6\n0\n-2\n0.0\n1\n\n\nH2\n0\n0\n-1.0\n-2\n\n\n\n\n\n      E o trecho de código que segue calcula o valor de \\(\\Delta H_r^o\\) para a formação de etano.\n\n# Solução matricial para entalpia de formação\nA &lt;- matrix(c(-2, 0, 0, -5, -7, -0.5, 4, 4, 0, 2, 6, 1, 0, -2, 0, 0, 0, -1), nrow = 6,\n    byrow = T)  # cria matrix das reações com variação de entalpia conhecida\nb &lt;- matrix(c(-1, 0, 0, 0, 1, -2), nrow = 6, byrow = T)  # cria matriz dos coeficientes estequiométricos da reação com variação de entalpia desconhecida\nbeta &lt;- solve(t(A) %*% A) %*% t(A) %*% b  # cálcula beta\nenerg &lt;- matrix(c(-2600, -3210, -286), nrow = 1, byrow = T)  # cria matriz com os valores de entalpia\n\netano &lt;- energ %*% beta\ncat(\"Valor para deltaHr etano: \", etano, \" kJ/mol\")\n\nValor para deltaHr etano:  -267  kJ/mol",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#quantidades-termodinâmicas-por-ajuste-polinomial",
    "href": "bioenergetica.html#quantidades-termodinâmicas-por-ajuste-polinomial",
    "title": "9  Bioenergética",
    "section": "9.5 Quantidades Termodinâmicas Por Ajuste Polinomial",
    "text": "9.5 Quantidades Termodinâmicas Por Ajuste Polinomial\n      Como visto nas seções anteriores deste capítulo e do capítulo @ref(Enzimas), as relações lineares permitem a extração de parâmetros cinéticos ou termodinâmicos associados a fenômenos biofísico-químicos, tais como no estudo de associações de ligantes com biopolímeros, auto-associação de biomacromoléculas, cinética de enzimas, ou equilíbrio de estabilidade termodinâmica de biopolímeros. Referente à esse último, a equação ?eq-eqVHoff ilustra a relação linear entre um parâmetro termodinâmico monitorado durante o experimento, tal como \\(K_{eq}\\) ou \\(\\Delta\\)G, e a temperatura (embora outros perturbantes poderiam igualmente viabilizar-se, tais como pH, teor de desnaturante, força iônica, etc).\n      Não obstante, não poderíamos utilizar as relações lineares de matrizes ou ajustes lineares para solucionar parâmetros quantitativos em situações que não repousassem no comportamento linear entre as variáveis, tal como referido pela equação ?eq-eqVHoff, por exemplo.\n      Ilustrando, a relação entre a temperatura e o valor para \\(\\Delta\\)G da auto-associação da apolipoproteína Apo A-II presente na lipoproteína HDL não exibe perfil linear, e pode ser obtida da literatura com auxílio do trecho de código que segue: (Waelbroeck, Van Obberghen, e De Meyts 1979).\n\nT &lt;- c(5.29, 10.07, 15.23, 20.21, 25.11, 30.29, 37.39) + 273  # dados de temperatura, em graus Kelvin\ndG &lt;- c(11.74, 12.17, 12.46, 12.73, 12.88, 12.98, 13.13) * -1000  # dados de -deltaG, em kcal/mol\nplot(T, dG, xlab = \"T, K\", ylab = expression(paste(Delta, \"G, kcal/mol\")))\n\n\n\n\nDependência da temperatura com a variação de energia de Gibbs da interação de insulina com seu receptor.\n\n\n\n\n      Observa-se pela figura @ref(fig:insuRec) uma tendência parabólica entre a temperatura de ensaio e a variação de energia de Gibbs do processo. Dessa forma, pode-se ajustar um polinômio de grau 3 aos dados, tal como segue.\n\npol3 &lt;- lm(dG ~ poly(T, 3, raw = TRUE)) # ajuste a polinômio de 3o. grau; \"raw=TRUE\" é essencial\n# Alternativamente, pode-se também ajustar polinômios como\n# pol3&lt;-lm(dG ~ T + I(T^2)+I(T^3))\n\nsummary(pol3)\n\n\nCall:\nlm(formula = dG ~ poly(T, 3, raw = TRUE))\n\nResiduals:\n      1       2       3       4       5       6       7 \n  2.350 -13.432  26.731 -16.407  -8.577  12.164  -2.829 \n\nCoefficients:\n                          Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)              8.970e+05  2.449e+05   3.663   0.0352 *\npoly(T, 3, raw = TRUE)1 -8.836e+03  2.498e+03  -3.537   0.0385 *\npoly(T, 3, raw = TRUE)2  2.866e+01  8.492e+00   3.375   0.0433 *\npoly(T, 3, raw = TRUE)3 -3.105e-02  9.613e-03  -3.230   0.0482 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 21.6 on 3 degrees of freedom\nMultiple R-squared:  0.999, Adjusted R-squared:  0.9981 \nF-statistic:  1045 on 3 and 3 DF,  p-value: 5.02e-05\n\nplot(T, dG,\n  xlab = \"T, K\", ylab = expression(paste(Delta, \"G, kcal/mol\"))\n  # gráfico de T x deltaG\n)\nlines(T, fitted(pol3), col = \"red\") # curva ajustada sobre os dados\n\n\n\n\nAjuste polinomial sobre os dados de variação de energia de Gibbs da interação de insulina com seu receptor.\n\n\n\n\n      Aqui vale ressaltar que a obtenção dos parâmetros de um polinômio também pode validar-se com auxílio da álgebra linear (matrizes). Exemplificando, construa a matriz A dos valores de temperatura, e a matriz b dos valores de \\(\\Delta\\)G:\n\\[A = \\begin{bmatrix}\n1 & 278.29\\\\\n1 & 283.07\\\\\n1 & 288.23\\\\\n1 & 293.21\\\\\n1 & 298.11\\\\\n1 & 303.29\\\\\n1 & 310.39\\\\\n\\end{bmatrix} , \\] \\[b = \\begin{bmatrix}\n-11740\\\\\n-12170\\\\\n-12460\\\\\n-12730\\\\\n-12880\\\\\n-12980\\\\\n-13130\\\\\n\\end{bmatrix} \\]\n      Nesse caso, a operação matricial leva em conta a conversão da matriz A da variável independente numa matriz de alternância, também conhecida como matriz de Vandermonde. Uma matriz de Vandermonde se apresenta como abaixo:\n\\[matriz \\,V = \\begin{bmatrix}\n1 & x_1 & x_1^2 & x_1^3 & ... \\\\\n1 & x_2 & x_2^2 & x_2^3 & ...  \\\\\n1 & x_3 & x_3^2 & x_3^3 & ...\\\\\n1 & ...& ... & ... & ...\\\\\n\\end{bmatrix} , \\]\n      Uma aparente limitação desse procedimento é que o ajuste deve ser realizado com poucos pontos experimentais, já que o termo exponencial cresce com o número de pontos. Por outro lado, a solução matricial contorna a necessidade em se obter somatórias estatísticas das variáveis. O R possui um pacote para automatizar essa transformação, matrixcalc, exemplificado no trecho de código abaixo:\n      Agora basta aplicar a mesma relação matricial da equação @ref(eq:eqAm1xb), no caso, para quatro pontos intercalados dos dados experimentais acima, e portanto produzindo um polinômio de 4o grau:\n\nT &lt;- c(5.29, 15.23, 25.11, 37.39) + 273  # dados de temperatura, em graus Kelvin\ndG &lt;- c(11.74, 12.46, 12.88, 13.13) * -1000  #\n\nlibrary(matrixcalc)\n# Criação das matrizes A (Vandermonde) e b\nb &lt;- as.matrix(dG, nrow = 4, byrow = TRUE)  # vetor b\nA &lt;- vandermonde.matrix(alpha = T, n = 4)\nA  # função para criar matriz de alternância (Vandermonde)\n\n     [,1]   [,2]     [,3]     [,4]\n[1,]    1 278.29 77445.32 21552259\n[2,]    1 288.23 83076.53 23945149\n[3,]    1 298.11 88869.57 26492908\n[4,]    1 310.39 96341.95 29903579\n\nsol.vnd &lt;- solve(A) %*% b\nsol.vnd  # coeficientes polinomiais (4o. grau)\n\n              [,1]\n[1,]  5.095658e+05\n[2,] -4.886799e+03\n[3,]  1.525183e+01\n[4,] -1.589352e-02\n\n\n      Para a plotagem dos dados, basta converter os coeficientes polinomiais acima na expressão polinomial resultante, o que pode ser realizado com o pacote polynom:\n\nlibrary(polynom)  # converte vetor de coeficientes em polinômio simbólico\np &lt;- as.polynomial(sol.vnd)\np2 &lt;- as.function(p)  # permite converter o polinômio pra função curve\nplot(T, dG)\ncurve(p2, from = 273, to = 315, add = TRUE)  # curva polinomial suave\n\n\n\n\n\n\n\n\n      Embora o ajuste polinomial, quer pela função própria do R (lm) como pela solução matricial acima, revele boa adesão do modelo aos dados experimentais, como representado pela Figura @ref(fig:TdG) e pela tabela de resultados acima, não há correlação de parâmetros termodinâmicos, posto tratar-se de um modelo matemático empírico, e não analítico para o sistema.\n      Entretanto, é possível obter uma boa aproximação das quantidades \\(\\Delta\\)H (entalpia), \\(\\Delta\\)S (entropia) e \\(\\Delta\\)Cp (capacidade calorífica) que modelam fenomenologicamente o comportamento termodinâmico em determinada temperatura, por relações próprias entre essas quantidades (Edelhoch e Osborne Jr 1976).\n\\[\\begin{equation}\n\\Delta S = -(\\frac{\\partial \\Delta G}{\\partial T})_p\n(\\#eq:eqdS)\n\\end{equation}\\]\n      Em suma, a variação de entropia pode ser definida como o gradiente da variação de energia de Gibbs com a temperatura. Outra forma de dizê-lo seria afirmar então que a variação de entropia pode ser também definida como a primeira derivada daquela relação, a qual pode ser definida empiricamente por:\n\\[\\begin{equation}\n\\Delta G = a+bT+cT^2+dT^3\n(\\#eq:eqGibbsEmp)\n\\end{equation}\\]\nAssim, o valor de \\(\\Delta\\)S pode ser obtido pela primeira derivada da relação empírica acima (@ref(eq:eqGibbsEmp)):\n\\[\\begin{equation}\n\\Delta S = -(\\frac{\\partial \\Delta G}{\\partial T})_p = -b-2cT-3dT^2\n(\\#eq:eqdSEmp)\n\\end{equation}\\]\nO valor de \\(\\Delta\\)H, por sua vez, pode agora ser extraído da equação @ref(eq:eqGibbs) aqui repetida, juntamente com a equação @ref(eq:eqGibbsEmp):\n\\[\\begin{equation}\n\\Delta G = \\Delta H - T * \\Delta S\n(\\#eq:eqGibbs)\n\\end{equation}\\]\n\\[\\begin{equation}\n\\Delta H = \\Delta G +T * \\Delta S\n(\\#eq:eqdH)\n\\end{equation}\\]\n Aplicando-se as equações empíricas para os parâmetros termodinâmicos acima:\n\\[\\begin{equation}\n\\Delta H = (a+bT+cT^2+dT^3) +T(-b-2cT-3dT^2)\n(\\#eq:eqdHEmp)\n\\end{equation}\\]\n\\[\\begin{equation}\n\\Delta H = a-cT^2-2dT^3\n(\\#eq:eqdHEmp2)\n\\end{equation}\\]\n      De forma similar, a capacidade calorífica em pressão constante pode ser definida como:\n\\[\\begin{equation}\n\\Delta Cp = -(\\frac{\\partial \\Delta H}{\\partial T})_p\n(\\#eq:eqdCp)\n\\end{equation}\\]\nOu seja, o valor de \\(\\Delta\\)Cp pode ser aproximado pela primeira derivada de \\(\\Delta\\)H (equação @ref(eq:eqdHEmp)) sobre T. Ou seja:\n\\[\\begin{equation}\n\\Delta Cp = -2cT-6dT^2\n(\\#eq:eqdCpEmp)\n\\end{equation}\\]\n      Ainda que constituam aproximações, os parâmetros termodinâmicos assim obtidos refletem a possibilidade de se descrever um fenômeno, tal como a interação de insulina com seu receptor (Waelbroeck, Van Obberghen, e De Meyts (1979)), sob a óptica de ligações fracas preponderantes, como ligações de hidrogênio, forças de van der Waals, efeito salino, interações eletrostáticas e efeito hidrofóbico (Ross e Subramanian 1981), apenas monitorando-se uma constante de equilíbrio com a temperatura. O trecho de código abaixo soluciona os parâmetros termodinâmicos para a complexação de insulina a seu receptor em 25\\(^o\\)C pelo método descrito.\n\n# Solução polinomial de parâmetros termodinâmicos para interação de insulina\n# com receptor\n\nT &lt;- c(5.29, 10.07, 15.23, 20.21, 25.11, 30.29, 37.39) + 273  # dados de temperatura, em graus Kelvin\ndG &lt;- c(11.74, 12.17, 12.46, 12.73, 12.88, 12.98, 13.13) * -1000  # dados de -deltaG, em kcal/mol\n\n# Ajuste a polinômio de 2o. grau\npol3 &lt;- lm(dG ~ poly(T, 3, raw = TRUE))  # ajuste a polinômio de 3o. grau\n\nTref &lt;- 298  # temperatura de referência, em graus Kelvin\n\n# Cálculos\ndG &lt;- coef(pol3)[1] + coef(pol3)[2] * Tref + coef(pol3)[3] * Tref^2 + coef(pol3)[4] *\n    Tref^3  # deltaG\ndS &lt;- -coef(pol3)[2] - 2 * coef(pol3)[3] * Tref - 3 * coef(pol3)[4] * Tref^2  # deltaS\ndH &lt;- coef(pol3)[1] - coef(pol3)[3] * Tref^2 - 2 * coef(pol3)[4] * Tref^3  # deltaH\ndCp &lt;- -2 * coef(pol3)[3] * Tref - 6 * coef(pol3)[4] * Tref^2  # deltaCp\n\n# Parâmetros em 298 K\ncat(\"valor de deltaG: \", dG, \"cal/mol\", \"\\n\")\n\nvalor de deltaG:  -12868.43 cal/mol \n\ncat(\"Valor de deltaS: \", dS, \"cal/mol/K\", \"\\n\")\n\nValor de deltaS:  27.29257 cal/mol/K \n\ncat(\"Valor de deltaH: \", dH, \"cal/mol\", \"\\n\")\n\nValor de deltaH:  -4735.248 cal/mol \n\ncat(\"valor de deltaCp: \", dCp, \"cal/mol/K\", \"\\n\")\n\nvalor de deltaCp:  -537.5956 cal/mol/K \n\n\n          Os valores encontrados para a interação são bem próximos dos reportados pelos autores em 25\\(^o\\)C (Waelbroeck, Van Obberghen, e De Meyts (1979)), embora esses tenham empregado um ajuste com polinômio de 2o. grau. Se você alterar o trecho de código acima para um polinômio de mesmo grau e omitir os termos das equações termodinâmicas que evidenciam o coeficiente d, deverá observar um valor de \\(\\Delta\\)Cp de -735 kcal/mol, bem similar ao reportado de -766 kcal/mol.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#estabilidade-termodinâmica-de-biopolímeros",
    "href": "bioenergetica.html#estabilidade-termodinâmica-de-biopolímeros",
    "title": "9  Bioenergética",
    "section": "9.6 Estabilidade Termodinâmica de Biopolímeros",
    "text": "9.6 Estabilidade Termodinâmica de Biopolímeros\n          A estabilidade termodinâmica de proteínas, enzimas e ácidos nucleicos é imprescindível do estudo de novos biopolímeros engenheirados, matrizes complexas modificadas (plasma artificial, por ex), bem como da pesquisa de candidatos à fármacos e medicamentos. Em linhas gerais, considera-se o biopolímero sob avaliação num modelo de dois estados, nativo e desnaturado, tal como apresentado na equação @ref(eq:eqKeq) deste capítulo.\n          No entanto, como torna-se complexa a determinação experimental das concentrações [N] e [D], busca-se obter uma relação entre elas, especificamente, sua fração, tal que:\n\\[\\begin{equation}\nf_D+f_N = 1\n(\\#eq:eqfDfN)\n\\end{equation}\\]\nO que resulta em:\n\\[\\begin{equation}\nf_N = 1 - f_D\n(\\#eq:eqSfD)\n\\end{equation}\\]\n          Dessa forma, um sinal experimental S obtido na presença de frações N e D em uma amostra de biopolímero pode ser representado como:\n\\[\\begin{equation}\nS = f_N * S_N +f_D * S_D\n(\\#eq:eqS)\n\\end{equation}\\]\n          Substituindo-se @ref(eq:eqSfD) em @ref(eq:eqS) obtém-se:\n\\[\\begin{equation}\nf_D = \\frac{S_i-S_N}{S_D-S_N}\n(\\#eq:eqfD)\n\\end{equation}\\]\nOnde Si representa o sinal no ponto i.\n          Dessa forma, mesmo que as concentrações [N] e [D] não sejam diretamente obtidas, suas frações podem ser recuperadas a partir do sinal obtido de ensaios de desnaturação frente a diversos perturbantes, tais como temperatura, pH, sais ou reagentes desnaturantes (ureia, cloreto de guanidina, por ex).\n           Dessa forma, também pode ser recuperado o valor da constante termodinâmica de equilíbrio de desnaturação K\\(_D\\), tal que:\n\\[\\begin{equation}\nK_D = \\frac{[D]}{[N]}=\\frac{f_D}{f_N}\n(\\#eq:eqKD)\n\\end{equation}\\]\n          Inserindo-se @ref(eq:eqSfD) em @ref(eq:eqKD), obtém-se:\n\\[\\begin{equation}\nK_D = \\frac{f_D}{1-f_D}\n(\\#eq:eqKD2)\n\\end{equation}\\]\nE, portanto,\n\\[\\begin{equation}\n\\Delta G_D = -RT*ln\\;K_D\n(\\#eq:eqdGD)\n\\end{equation}\\]\n          Dessa forma, é possível avaliar a estabilidade termodinâmica de um biopolímero por sua curva de estabilidade, contrastando-se o perturbante contra o valor de \\(\\Delta\\)G\\(_D\\) obtido pelos procedimentos acima.\n          Analiticamente, uma curva de estabilidade pode ser gerada a partir dos parâmetros constantes na equação integrada de Gibbs-Helmholtz (LiCata e Liu (2011)):\n\\[\\begin{equation}\n\\Delta G(T) = \\Delta H_m(\\frac{Tm-T}{Tm})-\\Delta Cp[Tm-T(1-ln \\; \\frac{Tm}{T})])\n(\\#eq:eqGibHelm)\n\\end{equation}\\]\n          Assim, pode-se ilustrar uma curva de estabilidade pelo trecho de código que segue:\n\nTm &lt;- 85\ndHm &lt;- 180\ndCp &lt;- 3\nx &lt;- 0:80\n\ncurve(dHm * (1 - x/Tm) + dCp * ((x - Tm - x * log(x/Tm))), xlim = c(0, 80))  # Nicholson1996; Sholz2009\n\n\n\n\nCurva de estabilidade simulada para a desnaturação de uma proteína. Tm = 75oC, DeltaHm = 180 kcal/mol, e DeltaCp = 3 kcal/mol/K.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#relação-quantitativa-estrutura-função-qsar-e-ajuste-multilinear",
    "href": "bioenergetica.html#relação-quantitativa-estrutura-função-qsar-e-ajuste-multilinear",
    "title": "9  Bioenergética",
    "section": "9.7 Relação Quantitativa Estrutura-Função (QSAR) e Ajuste Multilinear",
    "text": "9.7 Relação Quantitativa Estrutura-Função (QSAR) e Ajuste Multilinear\n      Os mesmos procedimentos empregados à solução de problemas matriciais, especificamente junto à equação @ref(eq:linMatr), podem acomodar também uma análise de QSAR (Quantitaive Structure-Function Relationship) de interesse. Por exemplo, derivados de benzodiazepinona (TIBO) são conhecidos inibir a transcriptase reversa (Tong et al. 2018), enzima que catalisa a conversão de RNA em DNA viral na síndrome de deficiência imunológica adquirida (SIDA). Nesse sentido, observações derivadas do estudo de QSAR podem contribuir para o desenho de potenciais inibidores da transcriptase do HIV. Assim, Tong e cols. propuseram um modelo preditivo multilinear relacionando algumas propriedades de análogos de TIBO com atividade biológica, como segue:\n\\[\\begin{equation}\npIC_{50}=x_0+x_1*S+x_2*W\n(\\#eq:eqTIBO)\n\\end{equation}\\]\n|Onde pIC\\(_{50}\\) representa a atividade biológica aferida (-log IC\\(_{50}\\)), S indexa valores de solubilidade, e W refere-se a parâmetro de largura do primeiro átomo do grupo substituinte. Esses dados são tabelados abaixo:\n\ngrupo &lt;- c(\"H\", \"Cl\", \"SCH3\", \"OCH3\", \"CN\", \"CHO\", \"Br\", \"CH3\", \"CCH\")  # grupos substituintes em TIBO\nS &lt;- c(3.53, 4.24, 4.09, 3.45, 2.96, 2.89, 4.39, 4.03, 3.8)  # parâmetro de solubilidade\nW &lt;- c(1, 1.8, 1.7, 1.35, 1.6, 1.6, 1.95, 1.6, 1.6)  # parâmetro de largura de grupo\npIC50 &lt;- c(7.36, 8.37, 8.3, 7.47, 7.25, 6.73, 8.52, 7.87, 7.53)  # atividade biológica de TIBO\n\ntab.tibo &lt;- data.frame(grupo, S, W, pIC50)\nknitr::kable(tab.tibo, caption = \"dados multivariáveis de atividade biológica de TIBO e parâmetros  preditivos.\",\n    \"pipe\")  # tabela\n\n\ndados multivariáveis de atividade biológica de TIBO e parâmetros preditivos.\n\n\ngrupo\nS\nW\npIC50\n\n\n\n\nH\n3.53\n1.00\n7.36\n\n\nCl\n4.24\n1.80\n8.37\n\n\nSCH3\n4.09\n1.70\n8.30\n\n\nOCH3\n3.45\n1.35\n7.47\n\n\nCN\n2.96\n1.60\n7.25\n\n\nCHO\n2.89\n1.60\n6.73\n\n\nBr\n4.39\n1.95\n8.52\n\n\nCH3\n4.03\n1.60\n7.87\n\n\nCCH\n3.80\n1.60\n7.53\n\n\n\n\n\n      Observe que existem duas variáveis preditoras e uma variável dependente, e cuja solução pode ser encontrada por ajuste multilinear ou linear múltiplo. O R permite fazê-lo por ao menos duas formas: função interna de ajuste linear (lm) ou álgebra matricial.\n\n9.7.1 Ajuste linear múltiplo por função lm:\n  De forma simplificada, pode-se obter a expressão multivariável que define a relação das quantidades preditivas W e S com a atividade biológica de TIBO por:\n\nlm.tibo &lt;- lm(tab.tibo$pIC50 ~ tab.tibo$S + tab.tibo$W)  # comando para ajuste multilinear;\n# Alternativamente, lm.tibo &lt;- lm(cbind(S,W)~pIC50)\nsummary(lm.tibo)\n\n\nCall:\nlm(formula = tab.tibo$pIC50 ~ tab.tibo$S + tab.tibo$W)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.27636 -0.15649  0.02922  0.08911  0.24761 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   3.5903     0.5435   6.606 0.000579 ***\ntab.tibo$S    0.9571     0.1519   6.300 0.000746 ***\ntab.tibo$W    0.3619     0.3020   1.199 0.275888    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2045 on 6 degrees of freedom\nMultiple R-squared:  0.912, Adjusted R-squared:  0.8826 \nF-statistic: 31.07 on 2 and 6 DF,  p-value: 0.0006826\n\n\n  Observe a forma mais direta de se atribuir variáveis já declaradas para uma função do R (*dataframe $ vetor). Essa é maneira mais simples, pois independe de pacotes extras (como o dplyr), embora seja menos legível.\n       Expressando-se os resultados na função linear múltipla:\n\\[\\begin{equation}\ny=5,75+0,14*S+0,95*W\n(\\#eq:eqTIBO2)\n\\end{equation}\\]\n\n\n9.7.2 Ajuste linear múltiplo por matrizes:\n      Os coeficientes beta obtidos acima podem ser também buscados por álgebra linear, utilizando-se a matriz b de atividade biológica e a matriz A contendo as variáveis independentes, essa também elaborada com valores unitários à esquerda, como antes, seguido da aplicação da equação @ref(eq:linMatr):\n\\[X = \\begin{bmatrix}\n1 & S_{1} & W_{1} \\\\\n1 & S_{2} & W_{2}\\\\\n1 & S_{3} & W_{3}\\\\\n... & ...\n\\end{bmatrix} \\]\n\n# Criação das matrizes A e b\nA &lt;- matrix(c(rep(1, 9), S, W), nrow = 9, byrow = FALSE)  # cria matriz com valor unitário necessário antes da variável independente\nb &lt;- as.matrix(pIC50, nrow = 1, byrow = FALSE)  # vetor b\n\n# Solução matricial do ajuste linear\nbeta &lt;- solve(t(A) %*% A) %*% t(A) %*% b\nbeta\n\n          [,1]\n[1,] 3.5902556\n[2,] 0.9571092\n[3,] 0.3619292\n\n\n      Veja que os valores para os coeficientes são coincidentes. Na prática o procedimento de ajuste linear múltiplo pode ser utilizado, como no exemplo acima, para a predição de uma resposta (como pIC\\(_{50}\\)) em função de variáveis preditoras (como S e W).\n      Esse procedimento matricial multilinear também pode ser aplicado em outros tipo de análise multivariável, como experimento fatorial e metodologia de superfície de resposta. Isso decorre da própria natureza desses sistemas, quando lineares. Veja as aplicações abaixo. Mesmo para metodologia de superfície de resposta quadrática (onde os parâmetros variam com o quadrado das variáveis preditoras), também é possível a solução matricial (equação @ref(eq:linMatr)).\n\\[\\begin{equation}\ny = b_0+b_1*x, \\, ajuste\\ linear\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+...+b_n*x_n, \\, ajuste \\, multilinear\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+...+b_n*x_n, \\, metodologia \\, de \\, superfície \\, de \\, resposta \\, linear\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_{12}*x_1*x_2, \\, planejamento \\, fatorial \\, 2^2\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_3*x_3+b_{12}*x_1*x_2+,b_{13}*x_1*x_3+b_{23}*x_2*x_3+b_{123}*x_1*x_2*x3 \\, experimento \\, fatorial \\, 2^3\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_{11}*x_1^2+b_{22}*x_2^2+b_{12}*x_1*x_2, \\, metodologia \\, de \\,superfície \\, de \\, resposta \\, quadrática\n\\\\\n(\\#eq:eqsLineares)\n\\end{equation}\\]\n      Via de regra, todas as aplicações listadas em ?eq-eqsLineares podem ser solucionadas com auxílio das relações matriciais das equações Equação 9.9 (ajustes linear, multilinear e superíficie de resposta linear) ou ?eq-eqAxb (planejamentos fatoriais). A seguir são exemplificadas duas situações dessa natureza.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#rendimento-de-reação-planejamento-fatorial-22",
    "href": "bioenergetica.html#rendimento-de-reação-planejamento-fatorial-22",
    "title": "9  Bioenergética",
    "section": "9.8 Rendimento de Reação & Planejamento Fatorial 2\\(^{2}\\)",
    "text": "9.8 Rendimento de Reação & Planejamento Fatorial 2\\(^{2}\\)\n      O experimento fatorial mais simples é o que se avalia a resposta de um experimento (rendimento, por ex) em que se variam dois fatores (temperatura e tipo de catalisador, por ex) em dois níveis cada (baixo e alto). A tabela elaborada no trecho abaixo a partir dos dados explicitados por Neto e cols (Neto, Scarminio, e Bruns 2010) exemplifica essa situação.\n\n# Dados do experimento\ntemp &lt;- c(40, 60, 40, 60)\ncatalis &lt;- c(\"A\", \"A\", \"B\", \"B\")\nrendim &lt;- c(59, 90, 54, 68)\n\n# Tabela do planejamento fatorial\n\ntab.fat &lt;- data.frame(temp, catalis, rendim)\nknitr::kable(tab.fat, caption = \"Dados de experimento fatorial (Neto e cols, 2010).\",\n    \"pipe\")  # tabela\n\n\nDados de experimento fatorial (Neto e cols, 2010).\n\n\ntemp\ncatalis\nrendim\n\n\n\n\n40\nA\n59\n\n\n60\nA\n90\n\n\n40\nB\n54\n\n\n60\nB\n68\n\n\n\n\n\n      Para conduzir a análise matricial dos dados é necessário converter a tabela de variáveis independentes (preditoras) em uma matriz de planejamento codificada, na qual valores altos (nível superior) são representados por +1 e valores baixos (nível inferior) por -1. Além disso, também é necessário atribuir-se +1 à 1a. coluna, e produzir uma 4a. coluna contendo o produto dos preditores codificados. Exemplificando, para temperatura a 40 (-1) e catalisador B (+1), a linha conterá o produto -1. Essa matriz final 4x4 é denominada matriz de coeficientes de contraste:\n\\[X = \\begin{bmatrix}\n1 & -1 & -1 & 1 \\\\\n-1 & -1 & 1 & 1 \\\\\n-1 & 1 & -1 & 1 \\\\\n1 & 1 & 1 & 1 \\\\\n\\end{bmatrix} \\]\n      Além disso, é necessário dividir a o resultado da operação matricial por um vetor escalar específico. Resumindo: elabora-se a matrix X codificada dos preditores, a matriz Y da resposta, aplica-se a equação @ref(eq:eqAxb), e divide-se o resultado por um vetor característico do planejamento fatorial 2\\(^{2}\\) (c(4,2,2,2)). O trecho de código abaixo soluciona o problema levantado:\n\n# Criação da matriz de planejamento codificada\nX &lt;- matrix(c(1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, 1, 1, 1), nrow = 4, byrow = TRUE)\n# Criação da matriz de rendimento\nY &lt;- as.matrix(rendim)\n# Determinação dos coeficientes beta:\nbeta &lt;- t(X) %*% Y/c(4, 2, 2, 2)\nbeta\n\n       [,1]\n[1,]  67.75\n[2,]  22.50\n[3,] -13.50\n[4,]  -8.50\n\n\n        Dessa forma, interpreta-se o resultado como:\n\\[\\begin{equation}\n\\begin{pmatrix}\n  M  \\\\\n  T \\\\\n  C  \\\\\n  TC \\\\\n\\end{pmatrix} =\n\\begin{pmatrix}\n  67,75  \\\\\n  22,50 \\\\\n  -13,50 \\\\\n  -8,50 \\\\\n\\end{pmatrix}\n(\\#eq:fator22)\n\\end{equation}\\]\nOnde M representa a média global da resposta, T e C os efeitos principais (temperatura e catalisador), e TC o efeito da interação. Em síntese, os resultados sugerem que 1) a temperatura favoreceu o rendimento, especialmente para o catalisador A, 2) há redução do rendimento quando se substitui o catalisador A pelo B, e c) os maiores rendimentos são obtidos com o catalisador A na temperatura mais alta. Expressando-se esses resultados na função linear múltipla:\n\\[\\begin{equation}\ny=67,75+22,5*T-13,5*C-8,5*T*C\n(\\#eq:eqFator)\n\\end{equation}\\]\n      Curiosamente, chega-se aos mesmos resultados se, ao invés de aplicarmos a equação @ref(eq:eqAxb), utilizarmos a equação @ref(eq:linMatr), seguido de multiplicação (e não divisão) por outro vetor (c(1,2,2,2):\n\nbeta &lt;- (solve(t(X) %*% X) %*% t(X) %*% Y) * c(1, 2, 2, 2)\nbeta\n\n       [,1]\n[1,]  67.75\n[2,]  22.50\n[3,] -13.50\n[4,]  -8.50",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "bioenergetica.html#metodologia-de-superfície-de-resposta-msr",
    "href": "bioenergetica.html#metodologia-de-superfície-de-resposta-msr",
    "title": "9  Bioenergética",
    "section": "9.9 Metodologia de Superfície de Resposta (MSR)",
    "text": "9.9 Metodologia de Superfície de Resposta (MSR)\n     Esta técnica estatística multivariável também é comumente empregada na modelagem de respostas influenciadas por mais de um fator, por vezes associada ao planejamento fatorial, e com vistas à otimização de uma resposta sem a necessidade de se avaliar todas as combinações possíveis. Isso pode ser particularmente útil quando se deseja otimizar um ensaio cuja resposta depende, por exemplo, de preditores escalares, como a faixa de concentração de determinado reagente e as condições de pH.\n      Exemplificando para uma superfície de resposta linear (Neto, Scarminio, e Bruns 2010), num ensaio em que se deseja verificar o melhor rendimento (rend, %) de uma reação variando-se 3 níveis de concentração de reagente (conc, %) e três velocidades de agitação magnética (agit, rpm), pode-se como dantes elaborar a matriz de contrastes a partir das informações da tabela que segue:\n\nconc &lt;- c(45, 55, 45, 55, 50, 50, 50)\nagit &lt;- c(90, 90, 110, 110, 100, 100, 100)\nx1 &lt;- c(-1, 1, -1, 1, 0, 0, 0)\nx2 &lt;- c(-1, -1, 1, 1, 0, 0, 0)\nrendim &lt;- c(69, 59, 78, 67, 68, 66, 69)\n\ntab.msr &lt;- data.frame(conc, agit, x1, x2, rendim)\nknitr::kable(tab.msr, caption = \"Dados de experimento de metodologia de superfície de resposta linear (Neto e cols, 2010).\",\n    \"pipe\")  # tabela\n\n\nDados de experimento de metodologia de superfície de resposta linear (Neto e cols, 2010).\n\n\nconc\nagit\nx1\nx2\nrendim\n\n\n\n\n45\n90\n-1\n-1\n69\n\n\n55\n90\n1\n-1\n59\n\n\n45\n110\n-1\n1\n78\n\n\n55\n110\n1\n1\n67\n\n\n50\n100\n0\n0\n68\n\n\n50\n100\n0\n0\n66\n\n\n50\n100\n0\n0\n69\n\n\n\n\n\n\n# Criação da matriz de coeficientes de contraste\nX &lt;- matrix(c(1, 1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 0, 0, 0, -1, -1, 1, 1, 0, 0, 0),\n    nrow = 7, byrow = FALSE)\n# Criação da matriz de rendimento\nY &lt;- as.matrix(rendim)\n# Determinação dos coeficientes beta:\nbeta &lt;- solve(t(X) %*% X) %*% t(X) %*% Y\nbeta\n\n      [,1]\n[1,] 68.00\n[2,] -5.25\n[3,]  4.25\n\n\n      Dessa forma, a função linear que expressa a superfície de resposta será:\n\\[\\begin{equation}\ny=68,00-5,25*conc+4,25*agit\n(\\#eq:eqMsr)\n\\end{equation}\\]\n\n9.9.1 Superfície Quadrática de Resposta\n      Por vezes o modelo linear pode não adequar-se ao planejamento experimental, o que pode ser verificado por uma Análise de Variância (ANAVA) do experimento. Nesses casos pode-se aplicar uma metodologia de superfície quadrática, e que pode ser expressa como visto na equação @ref(eq:eqsLineares). Nesses casos é usual uma construção denominada planejamento em estrela que acrescenta ao planejamento inicial um idêntico rotacionado 45\\(^{o}\\), e cujos pontos novos estão distantes \\(\\sqrt{2}\\) unidades codificadas do ponto central. O exemplo abaixo pretende exemplificar essa metodologia.\n\nconc &lt;- c(30, 40, 30, 40, 35, 35, 35, 28, 35, 42, 35)\nagit &lt;- c(115, 115, 135, 135, 125, 125, 125, 125, 139, 125, 119)\nx1 &lt;- c(-1, 1, -1, 1, 0, 0, 0, -sqrt(2), 0, sqrt(2), 0)\nx2 &lt;- c(-1, -1, 1, 1, 0, 0, 0, 0, sqrt(2), 0, -sqrt(2))\nrendim &lt;- c(86, 85, 78, 84, 90, 88, 89, 81, 80, 86, 87)\n\ntab.msr2 &lt;- data.frame(conc, agit, x1, x2, rendim)\nknitr::kable(tab.msr2, caption = \"Dados de experimento de metodologia de superfície quadrática de resposta (Neto e cols, 2010).\",\n    \"pipe\")  # tabela\n\n\nDados de experimento de metodologia de superfície quadrática de resposta (Neto e cols, 2010).\n\n\nconc\nagit\nx1\nx2\nrendim\n\n\n\n\n30\n115\n-1.000000\n-1.000000\n86\n\n\n40\n115\n1.000000\n-1.000000\n85\n\n\n30\n135\n-1.000000\n1.000000\n78\n\n\n40\n135\n1.000000\n1.000000\n84\n\n\n35\n125\n0.000000\n0.000000\n90\n\n\n35\n125\n0.000000\n0.000000\n88\n\n\n35\n125\n0.000000\n0.000000\n89\n\n\n28\n125\n-1.414214\n0.000000\n81\n\n\n35\n139\n0.000000\n1.414214\n80\n\n\n42\n125\n1.414214\n0.000000\n86\n\n\n35\n119\n0.000000\n-1.414214\n87\n\n\n\n\n\n      Dessa vez a matriz de coeficentes de contrastes expande-se para seis colunas em função dos termos x\\(_{1}^{2}\\), x\\(_{2}^{2}\\), e x\\(_{1}\\)x\\(_{2}\\), tornando-se:\n\\[\\begin{equation}\n\\begin{pmatrix}\n  1 & -1 & -1 & 1 & 1 & 1  \\\\\n  1 & 1 & -1 & 1 & 1 & -1 \\\\\n  1 & -1 & 1 & 1 & 1 & -1 \\\\\n  1 & 1 & 1 & 1 & 1 & 1  \\\\\n  1 & 0 & 0 & 0 & 0 & 0 \\\\\n  1 & 0 & 0 & 0 & 0 & 0 \\\\\n  1 & 0 & 0 & 0 & 0 & 0  \\\\\n  1 & -\\sqrt(2) & 0 & 2 & 0 & 0 \\\\\n  1 & 0 & \\sqrt(2) & 0 & 2 & 0 \\\\\n  1 & \\sqrt(2) & 0 & 2 & 0 & 0 \\\\\n  1 & 0 & -\\sqrt(2) & 0 & 2 & 0 \\\\\n\\end{pmatrix}\n(\\#eq:msr2)\n\\end{equation}\\]\n      O procedimento para a supefície quadrática repete a operação matricial realizada com a linear:\n\n# Criação da matriz de coeficientes de contraste para a superfície quadrática\nX &lt;- matrix(c(rep(1, 11), -1, 1, -1, 1, 0, 0, 0, -sqrt(2), 0, sqrt(2), 0, -1, -1,\n    1, 1, 0, 0, 0, 0, sqrt(2), 0, -sqrt(2), 1, 1, 1, 1, 0, 0, 0, 2, 0, 2, 0, 1, 1,\n    1, 1, 0, 0, 0, 0, 2, 0, 2, 1, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0), nrow = 11, byrow = FALSE)\n# Criação da matriz de rendimento\nY &lt;- as.matrix(rendim)\n# Determinação dos coeficientes beta:\nbeta &lt;- solve(t(X) %*% X) %*% t(X) %*% Y\nbeta\n\n          [,1]\n[1,] 89.000000\n[2,]  1.508883\n[3,] -2.362437\n[4,] -2.812500\n[5,] -2.812500\n[6,]  1.750000\n\n\n      O resultado expressa função quadrática de superfície encontrada, tal como segue:\n\\[\\begin{equation}\ny=89,00+1,51*x_1-2,36*x_2-2,81*x_1^2-2,81*x_2^2+1,75*x_1*x_2\n(\\#eq:eqMsr2)\n\\end{equation}\\]\n      Pelo resultado acima é possível prever-se as condições otimizadas para o ensaio. Nesse sentido, o R permite, por exemplo, a construção de um gráfico tridimensional que represente a função obtida, e sem a necessidade de pacote adicional: tal como segue:\n\nx &lt;- seq(-1, 1, 0.1)  # preditor x\ny &lt;- seq(-1, 1, 0.1)  # preditor y\nmrs &lt;- function(x, y) {\n    89 + 1.51 * x - 2.36 * y - 2.81 * x^2 - 2.81 * y^2 + 1.75 * x * y\n}  # função aplicada aos preditores\nz &lt;- outer(x, y, mrs)  # saída do gráfico 3D (resposta)\nres &lt;- persp(x, y, z, xlab = \"x1\", ylab = \"x2\", zlab = \"z\", shade = 0.4, theta = 30,\n    phi = 15, ticktype = \"detailed\")  # plotagem de superfície da função z(x,y)\npontos &lt;- trans3d(x1, x2, rendim, pmat = res)  # comando para adição de pontos experimentais\npoints(pontos, pch = 19, col = 1)  # adição dos pontos\n\n\n\n\nSuperfície quadrática descrita pela equação de MSR com superposição dos valores experimentais.\n\n\n\n\n      Não obstante, existem para o R alguns pacotes para representação tridimensional de dados e funções (rgl, plot3D, scatterplot3d), como também para análise de planejamento fatorial (agricolae,afex,FMC), e de metodologia de superfície de resposta (rsm`).\n\n\n9.9.2 Uma palavra sobre matrizes e aplicações\n      Como já percebido, o emprego de matrizes extende-se a situações diversas, não necessariamente de cunho Bioquímico ou Biofísico, ajustes de dados, Lei de Hess ou Lambert-Beer, como também a construção de um cardápio (matriz de ingredientes de cada prato por preço de cada ingrediente), ou o gasto calórico diário em atividade física (matriz de carga horária semanal de cada atividade por matriz de gasto calórico da atividade). De fato, são ferramentas utilizadas em Bioinformática, Economia, Ecologia, Engenharia, e tantas outras áreas, satisfeitas as relações básicas entre as variáveis em estudo. Essas condições, por sua vez, nada representam além do que a somatória de produtos, em que esses se manifestam por quantidades declaradas no problema. Assim, uma pequena representação da afirmação acima poderia ilutrar-se singelamente como:\n\\[\\begin{equation}\ny = \\sum_{n=1}^{\\infty} (x_1*x_2)\n(\\#eq:soulMatrix)\n\\end{equation}\n\\]\n\n\n\n\nBhatti, Haq Nawaz, M Hamid Rashid, Rakhshanda Nawaz, A Mukhtar Khalid, Muhammad Asgher, e A Jabbar. 2007. «Effect of aniline coupling on kinetic and thermodynamic properties of Fusarium solani glucoamylase». Applied microbiology and biotechnology 73 (6): 1290–98.\n\n\nCooper, Alan. 2004. «Thermodynamics and interactions». Em Biophysical Chemistry, 99–122.\n\n\nEdelhoch, Harold, e James C Osborne Jr. 1976. «The thermodynamic basis of the stability of proteins, nucleic acids, and membranes». Advances in protein chemistry 30: 183–250.\n\n\nKhalil, Mutasim I. 2000. «Calculating enthalpy of reaction by a matrix method». Journal of Chemical Education 77 (2): 185.\n\n\nLiCata, Vince J, e Chin-Chi Liu. 2011. «Analysis of free energy versus temperature curves in protein folding and macromolecular interactions». Methods in enzymology 488: 219–38.\n\n\nNeto, Benı́cio Barros, Ieda Spacino Scarminio, e Roy Edward Bruns. 2010. Como Fazer Experimentos-: Pesquisa e Desenvolvimento na Ciência e na Indústria. Bookman Editora.\n\n\nRoss, Philip D, e S Subramanian. 1981. «Thermodynamics of protein association reactions: forces contributing to stability». Biochemistry 20 (11): 3096–3102.\n\n\nTong, Jianbo, Shan Lei, Shangshang Qin, e Yang Wang. 2018. «QSAR studies of TIBO derivatives as HIV-1 reverse transcriptase inhibitors using HQSAR, CoMFA and CoMSIA». Journal of Molecular Structure 1168: 56–64.\n\n\nWaelbroeck, Magali, E Van Obberghen, e P De Meyts. 1979. «Thermodynamics of the interaction of insulin with its receptor.» Journal of Biological Chemistry 254 (16): 7736–40.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Bioenergética</span>"
    ]
  },
  {
    "objectID": "metabolismo.html",
    "href": "metabolismo.html",
    "title": "10  Metabolismo",
    "section": "",
    "text": "10.1 Rotas metabólicas & Balanceamento de Reações",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Metabolismo</span>"
    ]
  },
  {
    "objectID": "metabolismo.html#rotas-metabólicas-balanceamento-de-reações",
    "href": "metabolismo.html#rotas-metabólicas-balanceamento-de-reações",
    "title": "10  Metabolismo",
    "section": "",
    "text": "O metabolismo se dá uma intrincada rede de reações químicas catalisadas (ou não) por enzimas diversas, resultando numa rede equilibrada e dinâmica de processos autocatalíticos. Por vezes essa teia de reações pode ser observada no sem número dos chamados mapas metabólicos disponíveis, impressos ou na internet. Não obstante, os caminhos metabólicos são classificados para melhor compreensão em subconjuntos de reações pertinentes a determinado grupo de nutrientes ou compostos biológicos, como carboidratos, lipídios e ácidos nucleicos, por ex.\n      E numa visão mais ampliada desses subconjuntos, uma classificação ulterior resulta por diversas em reações bioquímicas sequenciais e interdependentes, as chamadas vias ou rotas metabólicas. Essas vias metabólicas sumarizam processos catabólicos ou anabólicos envolvendo substratos, produtos, enzimas, cofatores e coenzimas, tal como ilustrado na glicólise, gliconeogênese, glicogenólise, ciclo do ácido cítrico, cadeia respiratória, via das pentoses, \\(\\beta\\)-oxidação de ácidos graxos, entre outras.\n      Dessa forma pode-se considerar uma rota metabólica como uma combinação linear de reações catalisadas enzimaticamente (ex: glicólise anaeróbia). Em adição, também pode-se considerar as reações bioquímicas como equações bioquímicas, e portanto como um sistema linear de equações bioqumímicas com resolução por álgebra linear. Assim, pode-se empregar relações matriciais para solucionar o balanceamento estequiométrico (massa e carga), obtendo-se a reação líquida final a partir de um conjunto de reações conhecidas. Em síntese, equações bioquímicas como equações matriciais (Alberty 1991).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Metabolismo</span>"
    ]
  },
  {
    "objectID": "metabolismo.html#operação-matricial",
    "href": "metabolismo.html#operação-matricial",
    "title": "10  Metabolismo",
    "section": "10.2 Operação matricial",
    "text": "10.2 Operação matricial\n      Aplicando-se álgebra linear é possível obter-se o balanceamento final de reações sequenciais pela relação que segue, também vista no capítulo @ref(Bioenerg):\n\\[\\begin{equation}\nA =\n\\begin{pmatrix}\na_{11} & a_{12} & a_{13} & ... & a_{1n}   \\\\\na_{21} & a_{22} & a_{23} & ... & a_{2n}   \\\\\na_{31} & a_{32} & a_{33} & ... & a_{3n}   \\\\\n... & ... & ... & ... & a_{jn}\\\\\n\\end{pmatrix} ,\\\nb =\n\\begin{pmatrix}\nb_1 \\\\\nb_2 \\\\\nb_3 \\\\\n...  \\\\\nb_n \\\\\n\\end{pmatrix} ,\\\ny =\n\\begin{pmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3 \\\\\n...  \\\\\ny_n \\\\\n\\end{pmatrix}\n(\\#eq:mtrxGlic)\n\\end{equation}\\]\n      Nesse caso, A representa a matriz estequiométrica de reações e compostos, b o vetor de rota metabólica, e y o vetor da reação líquida balanceado. O vetor de rota indica o número de vezes necessário para cada reação ocorrer, de modo a produzir a reação líquida final. A matriz A é disposta de tal forma a apresentar cada reação em cada coluna, e cada reagente em cada linha, prenchendo-a com os coeficientes estequiométricos de reagentes e produtos. Para esses, é necessário apresentar sinal positivo para produtos (são formados) e negativo para reagentes (são consumidos).\n      A operação matricial para a obtenção da reação líquida envolve apenas um produto cruzado, tal que:\n\\[\\begin{equation}\nA * b = y\n(\\#eq:eqMtrxDot)\n\\end{equation}\\]\n\n10.2.1 Obtenção do vetor de rota metabólica para a glicólise aeróbia:\n      Supondo-se conhecer a reação líquida resumida para um conjunto de reações metabólicas, como a glicólise aeróbia (por sua vez agregando glicólise anaeróbia, ciclo do ácido cítrico e fosforilação oxidativa), pode-se facilmente obter-se o vetor de rotas. A partir desse vetor de rotas calculado, é possível obter-se o a reação líquida final do conjunto reações mais detalhado. Na prática, esse detalhamento envolve a participação de coenzimas de oxi-redução, ADP, ATP, e Pi.\n      Exemplificando, considere as reações abaixo, referentes à uma síntese da glicólise (Alberty 1996):\n\\[\\begin{equation}\nglicose \\rightleftarrows 2\\,piruvato \\\\\npiruvato + CoA \\rightleftarrows acetil \\, CoA + CO_2 \\\\\nacetil \\, CoA + 3 H_2O \\rightleftarrows 2 CO_2+CoA \\\\\n\\frac{1}{2} O_2 \\rightleftarrows H_2O \\\\\n(\\#eq:eqGlicoSimp)\n\\end{equation}\\]\n      As reações sequenciais acima possuem como reação líquida resultante:\n\\[\\begin{equation}\nglicose + 6O_2 \\rightleftarrows 6 CO_2 + 6 H_2O\n(\\#eq:eqGlicoSimpFin)\n\\end{equation}\\]\n      Para se obter o vetor de rotas então, é necessário elaborar a relação matricial, tal que:\n\\[\\begin{equation}\nA =\n\\begin{pmatrix}\n-1 & 0 & 0 & 0 \\\\\n2 & -1 & 0 & 0 \\\\\n0 & 0 & -3 & 1 \\\\\n0 & -1 & 1 & 0 \\\\\n0 & 1 & -1 & 0 \\\\\n0 & 1 & 2 & 0 \\\\\n0 & 0 & 0 & -1/2 \\\\\n\\end{pmatrix}\n(\\#eq:mtrxGlicSimp)\n\\end{equation}\\]\n\\[\\begin{equation}\ny =\n\\begin{pmatrix}\n-1 \\\\\n0 \\\\\n6 \\\\\n0 \\\\\n0 \\\\\n6 \\\\\n-6 \\\\\n\\end{pmatrix}\n(\\#eq:mtrxGlicSimp2)\n\\end{equation}\\]\n      Dessa forma, a solução para o vetor de rotas fica:\n\\[\\begin{equation}\nb = A^{-1} * y\n(\\#eq:eqMtrxGlicSimp)\n\\end{equation}\\]\n      Ocorre que o sistema linear para o conjunto de equações da via glicolítica é sobrestimado (há mais equações do que incógnitas), não permitindo a solução pela função solve de forma direta, como ilustrada no capítulo @ref(Bioenerg). Nesse caso, o vetor b pode ser obtido por solução de mínimos quadrados:\n\\[\\begin{equation}\nb = (A^{T}*A)^{-1}*A^T * y\n(\\#eq:eqMtrxGlicMinQuad)\n\\end{equation}\\]\n      Resolvendo o vetor de rotas no R:\n\nA &lt;- matrix(c(-1, 0, 0, 0, 2, -1, 0, 0, 0, 0, -3, 1, 0, -1, 1, 0, 0, 1, -1, 0, 0,\n    1, 2, 0, 0, 0, 0, -1/2), nrow = 7, byrow = TRUE)  # matriz A de estequiometria de reações\nrownames(A) &lt;- list(\"glicose\", \"piruvato\", \"H2O\", \"CoA\", \"acetil CoA\", \"CO2\", \"O2\")  # etiquetas dos reagentes\nA  # matriz A de reações\n\n           [,1] [,2] [,3] [,4]\nglicose      -1    0    0  0.0\npiruvato      2   -1    0  0.0\nH2O           0    0   -3  1.0\nCoA           0   -1    1  0.0\nacetil CoA    0    1   -1  0.0\nCO2           0    1    2  0.0\nO2            0    0    0 -0.5\n\ny &lt;- c(-1, 0, 6, 0, 0, 6, -6)  # vetor y de rotas\n\nsolve(t(A) %*% A) %*% t(A) %*% y\n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    2\n[4,]   12\n\n\n\n\n10.2.2 Obtenção do balanceamento de ATP, ADP, Pi e coenzimas de oxi-redução na glicólise\n      Com o vetor de rotas obtido ({1,2,2,12}), agora é possível aplicá-lo a um conjunto mais extenso de equações da glicólise, para dessa vez solucionar o balanceamento das reações envolvendo coenzimas de oxi-redução, ATP, ADP, e Pi:\n\\[\\begin{equation}\nglicose+2Pi+2ADP+2NAD^+ \\rightleftarrows 2 \\,piruvato+2ATP+2NADH+2H_2O \\, , \\\\\nglicólise \\, anaeróbia,\\\\\npiruvato+CoA+NAD^+ \\rightleftarrows acetil-CoA+CO_2+NADH \\\\\nacetil-CoA + 4NAD^++ADP+Pi+2H_2O \\rightleftarrows2CO_2+4NADH+ATP+CoA \\, , \\\\\ncomplexo\\, da \\, piruvato \\, desidrogenase\\\\\nNADH+ \\frac{1}{2}O_2+3Pi+3ADP \\rightleftarrows NAD^++4H_2O+3ATP \\, ,\\\\\noxidação \\, fosforilativa\n(\\#eq:eqGlicoPlus)\n\\end{equation}\\]\n      Vale ressaltar uma simplificação pela substituição de GTP e GDP por ATP e ADP (ciclo de Krebs), uma vez que são interconversíveis no metabolismo. Também se assume para simplificação a interconversão de FAD e NAD na reação líquida (Alberty 1996) :\n\\[\\begin{equation}\nFADH + NAD^+ \\rightleftarrows FAD + NADH\n(\\#eq:eqNadFad)\n\\end{equation}\\]\n      De posse das reações presentes na Eq.@ref(eq:eqGlicoPlus) e do vetor de rotas obtido anteriormente, pode-se construir a nova matriz estequiométrica e aplicar a solução de mínimos quadrados (Eq. @(eq:eqMtrxGlicMinQuad) para se obter a reação líquida da glicólise. E para isso basta aplicar a Eq. @(eq:eqMtrxDot) de produto cruzado:\n\nA &lt;- matrix(c(-1, 0, 0, 0, -2, 0, -1, -3, -2, 0, -1, -3, -2, -1, -4, 1, 2, -1, 0,\n    0, 2, 0, 1, 3, 2, 1, 4, -1, 2, 0, -2, 4, 0, -1, 1, 0, 0, 1, -1, 0, 0, 1, 2, 0,\n    0, 0, 0, -1/2), nrow = 12, byrow = TRUE)  # matriz A de estequiometria de reações\nrownames(A) &lt;- list(\"glicose\", \"Pi\", \"ADP\", \"NAD\", \"piruvato\", \"ATP\", \"NADH\", \"H2O\",\n    \"CoA\", \"acetil CoA\", \"CO2\", \"O2\")  # etiquetas dos reagentes\nA  # matriz A de reações\n\n           [,1] [,2] [,3] [,4]\nglicose      -1    0    0  0.0\nPi           -2    0   -1 -3.0\nADP          -2    0   -1 -3.0\nNAD          -2   -1   -4  1.0\npiruvato      2   -1    0  0.0\nATP           2    0    1  3.0\nNADH          2    1    4 -1.0\nH2O           2    0   -2  4.0\nCoA           0   -1    1  0.0\nacetil CoA    0    1   -1  0.0\nCO2           0    1    2  0.0\nO2            0    0    0 -0.5\n\ny &lt;- c(1, 2, 2, 12)  # vetor y de rotas\n\nA %*% y\n\n           [,1]\nglicose      -1\nPi          -40\nADP         -40\nNAD           0\npiruvato      0\nATP          40\nNADH          0\nH2O          46\nCoA           0\nacetil CoA    0\nCO2           6\nO2           -6\n\n# solve(t(A)%*%A)%*%t(A)%*%y\n\n      A partir desse resultado pode-se montar a reação líquida final da via glicolítica como:\n\\[\\begin{equation}\nglicose + 6O_2 + 40 ADP + 40 Pi \\rightleftarrows 6CO_2+ 40ATP\n(\\#eq:eqBalGlico)\n\\end{equation}\\]\n      O exemplo acima ilustra o emprego de álgebra matricial para a solução de problemas de balanceamento de reações bioquímicas. Por sua natureza trata-se de método abrangente e de natureza algorítmica (portanto, programável), embora não seja o único. Outras propostas de solução para o balanceamento e conservação de massa e carga englobam a inspeção direta por triagem e erro a partir de regras mnemônicas, o balanceamento por método de meia-equação, e o método de número de oxidação, não discutidos aqui.\n\n\n\n\nAlberty, Robert A. 1991. «Chemical equations are actually matrix equations». Journal of chemical education 68 (12): 984.\n\n\n———. 1996. «Calculation of biochemical net reactions and pathways by using matrix operations». Biophysical journal 71 (1): 507–15.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Metabolismo</span>"
    ]
  },
  {
    "objectID": "redes.html",
    "href": "redes.html",
    "title": "11  Redes Metabólicas",
    "section": "",
    "text": "11.1 Solução numérica para sistema de equações diferenciais\nk &lt;- 0.5  # constante cinética de catálise\ndt &lt;- 0.005\ntmax &lt;- 3  # intervalo de tempo & tempo máximo\nt &lt;- seq(0, tmax, dt)  # vetor de tempo\nn &lt;- tmax/dt + 1  # no. de pontos da simulação (necessário o acréscimo de 1 para que vetores fiquem de mesmo tamanho)\nx &lt;- matrix(rep(0, 2 * n), nrow = 2, ncol = n)  # construção da matriz de uma linha pra cada composto, e uma coluna pra cada tempo dt\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0  # valores iniciais de concentração\nfor (i in 2:n) {\n    dA &lt;- -k * x[1, i - 1] * dt  # dA\n    dB &lt;- k * x[1, i - 1] * dt  # dB\n    x[1, i] &lt;- x[1, i - 1] + dA  # variação em A com acrécimo dA\n    x[2, i] &lt;- x[2, i - 1] + dB  # variação em B com acréscimo dB\n    # laço que acrescenta a cada intervalo dt o valor do novo teor para cada\n    # composto\n}\nplot(t, x[1, ], type = \"l\", lty = 1, xlab = \"tempo, s\", ylab = \"[espécie], M\", ylim = c(0,\n    1.025), bty = \"l\")  # gráfico do composto 1\nlines(t, x[2, ], lty = 2, col = 2)  # adição do gráfico do composto 2\nlegend(x = 2, 5, y = 1, legend = c(\"A\", \"B\"), col = c(1, 2), cex = 1, lty = c(1,\n    2))\n\n\n\n\nSolução de sistema de equações diferenciais por método de Euler para conversão de 1a. ordem da espécie A em B, a uma taxa cinética k.\nk &lt;- 0.5\nkm &lt;- 0.5  # constantes cinéticas de catálise\ndt &lt;- 0.005\ntmax &lt;- 10  # intervalo de tempo & tempo máximo\nt &lt;- seq(0, tmax, dt)  # define vetor de tempo\nn &lt;- tmax/dt + 1  # define no. de pontos\nx &lt;- matrix(rep(0, 2 * n), nrow = 2, ncol = n)  # constroi matriz de uma linha pra cada composto, e uma coluna pra cada tempo dt\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 1  # valores iniciais de concetração\nfor (i in 2:n) {\n    dA &lt;- -k * x[1, i - 1] * dt + km * x[2, i - 1] * dt\n    dB &lt;- k * x[1, i - 1] * dt - km * x[2, i - 1] * dt\n    x[1, i] &lt;- x[1, i - 1] + dA\n    x[2, i] &lt;- x[2, i - 1] + dB\n    # laço que acrescenta a cada intervalo dt o valor de novo teor para cada\n    # composto\n}\nplot(t, x[1, ], type = \"l\", lty = 1, xlab = \"tempo, s\", ylab = \"[espécie], M\", ylim = c(0,\n    2), bty = \"l\")  # gráfico do composto 1\nlines(t, x[2, ], lty = 2, col = 2)  # adição do gráfico do composto 2\nlegend(x = 2, 5, y = 2, legend = c(\"A\", \"B\"), col = c(1, 2), cex = 1, lty = c(1,\n    2))\n\n\n\n\nSolução numérica para a conversão reversível da espécie A em B. k = km = 0,5; Ao e Bo = 1 (teores iniciais).\nk &lt;- 0.5\nkm &lt;- 0.1  # constantes cinéticas de catálise\ndt &lt;- 0.005\ntmax &lt;- 10  # intervalo de tempo & tempo máximo\nt &lt;- seq(0, tmax, dt)  # define vetor de tempo\nn &lt;- tmax/dt + 1  # define no. de pontos\nx &lt;- matrix(rep(0, 2 * n), nrow = 2, ncol = n)  # constroi matriz de uma linha pra cada composto, e uma coluna pra cada tempo dt\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0.2  # valores iniciais de concetração\nfor (i in 2:n) {\n    dA &lt;- -k * x[1, i - 1] * dt + km * x[2, i - 1] * dt\n    dB &lt;- k * x[1, i - 1] * dt - km * x[2, i - 1] * dt\n    x[1, i] &lt;- x[1, i - 1] + dA\n    x[2, i] &lt;- x[2, i - 1] + dB\n    # laço que acrescenta a cada intervalo dt o valor de novo teor para cada\n    # composto\n}\nplot(t, x[1, ], type = \"l\", lty = 1, xlab = \"tempo, s\", ylab = \"[espécie], M\", ylim = c(0,\n    2), bty = \"l\")  # gráfico do composto 1\nlines(t, x[2, ], lty = 2, col = 2)  # adição do gráfico do composto 2\nlegend(x = 2, 5, y = 2, legend = c(\"A\", \"B\"), col = c(1, 2), cex = 1, lty = c(1,\n    2))\n\n\n\n\nSolução numérica para a conversão reversível da espécie A em B. k = 0,5; km = 0,1; Ao = 1; Bo = 0,2 (teores iniciais).\nk1 &lt;- 0.5\nkm1 &lt;- 0.1\nk2 &lt;- 1  # constantes cinéticas de catálise\ndt &lt;- 0.005\ntmax &lt;- 3  # intervalo de tempo & tempo máximo\nt &lt;- seq(0, tmax, dt)  # define vetor de tempo\nn &lt;- tmax/dt + 1  # define no. de pontos\nx &lt;- matrix(rep(0, 3 * n), nrow = 3, ncol = n)  # constroi matriz de uma linha pra cada composto, e uma coluna pra cada tempo dt\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0\nx[3, 1] &lt;- 0  # valores iniciais de concentração\nfor (i in 2:n) {\n    dA &lt;- -k1 * x[1, i - 1] * dt + km1 * x[2, i - 1] * dt\n    dB &lt;- k1 * x[1, i - 1] * dt - (km1 + k2) * x[2, i - 1] * dt\n    dC &lt;- k2 * x[2, i - 1] * dt\n    x[1, i] &lt;- x[1, i - 1] + dA\n    x[2, i] &lt;- x[2, i - 1] + dB\n    x[3, i] &lt;- x[3, i - 1] + dC  # laço que acrescenta a cada intervalo dt o valor de novo teor para cada composto\n}\nplot(t, x[1, ], type = \"l\", lty = 1, xlab = \"tempo, s\", ylab = \"[espécie], M\", ylim = c(0,\n    1.025), bty = \"l\")  # gráfico do composto 1\nlines(t, x[2, ], lty = 2, col = 2)  # adição do gráfico do composto 2\nlines(t, x[3, ], lty = 3, col = 3)  # adição do gráfico do composto 3\nlegend(x = 2, 5, y = 1, legend = c(\"A\", \"B\", \"C\"), col = c(1, 2, 3), cex = 1, lty = c(1,\n    2, 3))\n\n\n\n\nSolução de Euler para uma cinética de 3 compostos. k1 = 0,5; k2 = 1; km1 = 0,1. Teores iniciais: Ao = 1; Bo = 0; Co = 0.\n# Forward and reverse rate constants\nk1 &lt;- 3\nkm1 &lt;- 1\nk2 &lt;- 4\nkm2 &lt;- 0.7\ndt &lt;- 0.005\ntmax &lt;- 10\nt &lt;- seq(0, tmax, dt)\nn &lt;- tmax/dt + 1\nx &lt;- matrix(rep(0, 3 * n), nrow = 3, ncol = n)\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0\nx[3, 1] &lt;- 0\nfor (i in 2:n) {\n    dA &lt;- -k1 * x[1, i - 1] * dt + km1 * x[2, i - 1] * dt\n    dB &lt;- k1 * x[1, i - 1] * dt - (km1 + k2) * x[2, i - 1] * dt + km2 * x[3, i -\n        1] * dt\n    dC &lt;- k2 * x[2, i - 1] * dt - km2 * x[3, i - 1] * dt\n    x[1, i] &lt;- x[1, i - 1] + dA\n    x[2, i] &lt;- x[2, i - 1] + dB\n    x[3, i] &lt;- x[3, i - 1] + dC\n}\nplot(t, x[1, ], type = \"l\", lty = 1, xlab = \"tempo, s\", ylab = \"[espécie], mol/L\",\n    ylim = c(0, 1.025), bty = \"l\")\nlines(t, x[2, ], col = 2, lty = 2)\nlines(t, x[3, ], col = 3, lty = 3)\nlegend(x = 8, y = 0.6, legend = c(\"A\", \"B\", \"C\"), col = c(1, 2, 3), cex = 1, lty = c(1,\n    2, 3))\n\n\n\n\nSolução de Euler para uma cinética reversível de 3 compostos. k1 = 1; km1 = 3; k2 = 5; km1 = 0,1. Teores iniciais: Ao = 1; Bo = 0; Co = 0.\nUm exemplo de reações bioquímicas em rota metabólica fictícia. As setas pontilhadas juntamente aos valores de ki e ka representam modulações alostéricas com respectivas constantes de inibição e ativação enzimáticas.\n# Constantes cinéticas e alostéricas\nk1 &lt;- 2\nk2 &lt;- 0.5\nk3 &lt;- 0.7\nkm3 &lt;- 0.3\nk4 &lt;- 5\nk5 &lt;- 1\nki &lt;- 0.3  # constante de inibição\nka &lt;- 0.2  # constante de ativação\ndt &lt;- 0.005\ntmax &lt;- 10\nt &lt;- seq(0, tmax, dt)\nn &lt;- tmax/dt + 1\nx &lt;- matrix(rep(0, 6 * n), nrow = 6, ncol = n)\n# Valores iniciais dos compostos\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0\nx[3, 1] &lt;- 0\nx[4, 1] &lt;- 1\nx[5, 1] &lt;- 0\nx[6, 1] &lt;- 0\nfor (i in 2:n) {\n    # sistema de equações inserido na matriz dos intervalos\n    dA &lt;- -k1 * x[1, i - 1] * dt + ka * x[6, i - 1] * dt\n    dB &lt;- k1 * x[1, i - 1] * dt + km3 * x[4, i - 1] * dt - k3 * x[2, i - 1] * dt -\n        k2 * x[2, i - 1] * dt - ki * x[1, i - 1] * dt\n    dC &lt;- k2 * x[2, i - 1] * dt\n    dD &lt;- k3 * x[2, i - 1] * dt - km3 * x[4, i - 1] * dt - k4 * x[4, i - 1] * dt\n    dE &lt;- k4 * x[4, i - 1] * dt - k5 * x[5, i - 1] * dt\n    dF &lt;- k5 * x[5, i - 1] * dt - ka * x[6, i - 1] * dt\n    # Adição dy aos valores de y\n    x[1, i] &lt;- x[1, i - 1] + dA\n    x[2, i] &lt;- x[2, i - 1] + dB\n    x[3, i] &lt;- x[3, i - 1] + dC\n    x[4, i] &lt;- x[4, i - 1] + dD\n    x[5, i] &lt;- x[5, i - 1] + dE\n    x[6, i] &lt;- x[6, i - 1] + dF\n}\n# Elaboração dos gráficos cinéticos\nplot(t, x[1, ], type = \"l\", lty = 1, xlab = \"tempo,s\", ylab = \"[espécie], mol/L\",\n    ylim = c(0, 1.025), bty = \"l\")\nlines(t, x[2, ], col = 2, lty = 2)\nlines(t, x[3, ], col = 3, lty = 3)\nlines(t, x[4, ], col = 4, lty = 4)\nlines(t, x[5, ], col = 5, lty = 5)\nlines(t, x[6, ], col = 6, lty = 6)\nlegend(x = 6.5, y = 0.65, legend = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"), col = c(1, 2,\n    3, 4, 5, 6), cex = 1, lty = c(1, 2, 3, 4, 5, 6))\n\n\n\n\nSolução para uma via metabólica fictícia apresentando inibição (ki) e ativação (ka) alostéricas. Taxas cinéticas: k1 = 2, k2 = 0,5, k3 = 0,7, km3 = 0,3, k4 = 5, k5 = 1, ki = 0,3, ka = 0.2. Valores iniciais dos compostos: A=1; B, C, D, E, F = 0",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Redes Metabólicas</span>"
    ]
  },
  {
    "objectID": "redes.html#solução-numérica-para-sistema-de-equações-diferenciais",
    "href": "redes.html#solução-numérica-para-sistema-de-equações-diferenciais",
    "title": "11  Redes Metabólicas",
    "section": "",
    "text": "Por outro lado, quando uma equação ou sistema de equações diferenciais possui certa complexidade para a solução analítica, busca-se a solução numérica. Ainda que existam diversas bibliotecas para a solução de equações diferenciais pelo R (deSolve,pracma, lsoda), alguns sistemas simples podem ser resolvidos com os pacotes básicos de instalação:\n      O procedimento mais simples emprega o método de Euler. A ideia básica do método consiste em integrar uma função diferencial de variação infinitesimal na variável independente (no caso, o tempo), para uma relação real, e a partir de valores iniciais fornecidos. Simplificando, o valor da função corresponderá ao acréscimo do incremento dy para cada intervalo dx, a partir da relação de cada reação envolvida na transformação dos compostos. Exemplificando para as reações presentes na Eq. @ref(eq:dAdB):\n\n\n      Experimente variar a constante cinética k, ou os valores iniciais para cada composto, e observe o efeito resultante. As reações metabólicas por diversas vezes apresentam interconversões entre compostos, tal que um substrato da reação também pode configurar-se como produto de catálise da mesma, e com taxas cinéticas de síntese (k) e degradação (km, ou k minus) para cada composto, como segue:\n\\[\\begin{equation}\nA \\begin{array}{c}\n_{k}\\\\\n\\rightleftharpoons\\\\\n^{km} \\end{array} B\n(\\#eq:ABrever)\n\\end{equation}\\]\n      Nesse caso, o sistema de equações diferenciais ficará:\n\\[\\begin{equation}\ndA=-k*A*dt+km*B*dt;\\\\\ndB=k*A*dt-km*B*dt\n(\\#eq:dABrev)\n\\end{equation}\\]\n      Implementando-se o trecho de código no R:\n\n      Observe que os teores de A e B permanecem constantes ao longo do intervalo. Isso decorre dos valores idênticos das constantes cinéticas para cada reação direta e reversa, bem como dos teores iniciais para cada composto. Ilustrando uma variação desses:\n\n      Agora podemos imaginar uma reação um pouco mais complexa, como a ilustrada na Eq. @ref(eq:kinMM) abaixo:\n\\[\\begin{equation}\nA \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{km1} \\end{array} B\n\\begin{array}{c}\n_{k2}\\\\\n\\rightarrow \\\\\n  ^{}\\end{array}C\n(\\#eq:kinMM)\n\\end{equation}\\]\n      Nesse caso, o sistema de equações diferenciais será:\n\\[\\begin{equation}\ndA=-k1*A*dt+km1*B*dt;\\\\\ndB=k1*A*dt-km1*B*dt-k2*B*dt;\\\\\ndC=k2*B\n(\\#eq:dMMkin)\n\\end{equation}\\]\n      Implementando-se o trecho de código:\n\n      Observe que a Eq. @ref(eq:dMMkin) acima reflete uma catálise de Michaelis-Mentem, embora considerando o teor da enzima E como constante e, portanto, independente da reação (ordem zero). E observe também que o gráfico @ref(fig:MMdiffeq) traduz, de certa forma, a condição Briggs-Haldane do estado estacionário tratada no capítulo @ref(Enzimas) sobre Enzimas. Note que a variação de B, refletida nessa condição como o complexo ES, mantém-se relativamente constante por determinado intervalo de tempo, sendo produzida pela colisão com a enzima E, e desconstruida tanto por sua conversão a E + P (no caso, C), como por sua reversão a E + S (no caso, A).\nPara uma reação um pouco mais complexa:\n\\[\\begin{equation}\nA \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{km1} \\end{array} B\n\\begin{array}{c}\n_{k2}\\\\\n\\rightleftharpoons\\\\\n  ^{km2}\\end{array}C\n(\\#eq:ABCrev)\n\\end{equation}\\]\n      O que sugere o seguinte trecho de código no R:\n\n      Agora, suponha uma cadeia mais complexa de reações bioquímicas, com moduladores alostéricos negativos (inibição, ki) e positivos (ativação, ka) para determinadas enzimas. O exemplo abaixo ilustra essa situação:\n\n      Assim, o conjunto de reações da rede metabólica acima pode ser equacionado como:\n\\[\\begin{equation}\ndA=-k1*A*dt+ka*F*dt;\\\\\ndB=k1*A*dt+km3*D*dt-k3*B*dt-k2*B*dt-ki*E*dt;\\\\\ndC=k2*B*dt;\\\\\ndD=k3*B*dt-km3*D*dt-k4*D*dt;\\\\\ndE=k4*D*dt-k5*E*dt;\\\\\ndF=k5*E*dt-ka*F*dt\n(\\#eq:drede1)\n\\end{equation}\\]\n   Pode-se elaborar o trecho de código que segue para a solução numérica de Euler que envolve as equações diferenciais elencadas acima como:\n\n      Altere as constantes cinéticas e/ou alostéricas do sistema acima e observe o efeito em cada um dos compostos. De modo geral, a solução de Euler aplicada a sistemas de complexidade crescente, como uma rede metabólica, pode apresentar desvios centrados na seleção do valor de dt, ou mesmo produzir valores inconsistentes. Para contornar essa situação utiliza-se outros algoritmos, tais como de Runge-Kutta de 2a., 3a, ou 4a. ordem, presentes nos pacotes do R, ou ainda por análise de sistemas.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Redes Metabólicas</span>"
    ]
  },
  {
    "objectID": "redes.html#algumas-reações-do-metabolismo-da-glicose",
    "href": "redes.html#algumas-reações-do-metabolismo-da-glicose",
    "title": "11  Redes Metabólicas",
    "section": "11.2 Algumas reações do metabolismo da glicose",
    "text": "11.2 Algumas reações do metabolismo da glicose\n      Para uma aplicação do método de Runge-Kutta de 4a. ordem é necessário instalar o pacote deSolve ou similar para a solução de sistema de equações diferenciais ordinárias de 1a. ordem ou diferenciais parciais. A biblioteca agrega funções que permitem um código mais enxuto e simples para a solução do sistema. Ilustrando sua aplicação, seguem algumas das muitas relações simples da rede metabólica que envolve a glicólise, gliconeogênese, e via das pentoses nas células:\n\n\n\n\n\nAlgumas relações metabólicas envolvidas na glicólise, gliconeogênese e vias das pentoses.\n\n\n\n\n      Pode-se atribuir a essas relações as seguintes reações do metabolismo:\n\\[\\begin{equation}\nG6P\n\\begin{array}{c}\n_{k1}\\\\\n\\rightarrow \\\\\n  ^{}\\end{array} R5P\\\\\nG3P+DHCP\n\\begin{array}{c}\n_{k2}\\\\\n\\rightarrow \\\\\n  ^{}\\end{array} PEP\\\\\n2G3P\n\\begin{array}{c}\n_{k3}\\\\\n\\rightarrow \\\\\n  ^{}\\end{array} 6GP\\\\\nR5P\n\\begin{array}{c}\n_{k4}\\\\\n\\rightarrow \\\\\n  ^{}\\end{array} G3P\\\\\n2PEP\n\\begin{array}{c}\n_{k5}\\\\\n\\rightarrow \\\\\n  ^{}\\end{array} G6P\n   (\\#eq:redeMetab1)\n\\end{equation}\\]\n    O trecho de código para a solução por Runge-Kutta pode ser o exemplificado a seguir, com resultados em dois gráficos; inicialmente com as curvas isoladas, e depois reunidas.\n\nlibrary(deSolve)\n# Parâmetros das reações\nk1 &lt;- 0.1\nk2 &lt;- 0.5\nk3 &lt;- 0.05\nk4 &lt;- 0.5\nk5 &lt;- 0.2\nparms &lt;- c(k1, k2, k3, k4, k5)\n\n# Valores iniciais para cada composto\nG6P0 &lt;- 1\nR5P0 &lt;- 0\nG3P0 &lt;- 0.3\nDHCP0 &lt;- 0.1\nPEP0 &lt;- 0\n# Intervalo de tempo\ntmin &lt;- 0\ntmax &lt;- 20\ndt &lt;- 0.01\ntempo &lt;- seq(tmin, tmax, dt)\n# Função para as derivadas das espécies no tempo\neq.dif &lt;- function(tempo, x, parms) {\n    # especificação dos compostos\n    G6P &lt;- x[1]\n    R5P &lt;- x[2]\n    G3P &lt;- x[3]\n    DHCP &lt;- x[4]\n    PEP &lt;- x[5]\n    # equações diferenciais\n    dG6P &lt;- -k1 * G6P + k3 * G3P^2 + k5 * PEP^2\n    dR5P &lt;- k1 * G6P - k4 * R5P\n    dG3P &lt;- -k2 * G3P * DHCP - k3 * G3P^2 + k4 * R5P\n    dDHCP &lt;- -k2 * G3P * DHCP\n    dPEP &lt;- k2 * G3P * DHCP - k5 * PEP^2\n    list(c(dG6P, dR5P, dG3P, dDHCP, dPEP))  # incrementos das espécies\n}\n# Rotina de lsoda pra solução diferencial ordinária\n\nout &lt;- lsoda(c(G6P0, R5P0, G3P0, DHCP0, PEP0), tempo, eq.dif, parms, rtol = 1e-04,\n    atol = 1e-06)\n# Saída do resultado em vetores pra cada quantidade (tempo e espécies)\nt &lt;- out[, 1]\nG6P &lt;- out[, 2]\nR5P &lt;- out[, 3]\nG3P &lt;- out[, 4]\nDHCP &lt;- out[, 5]\nPEP &lt;- out[, 6]\n# Elaboração de gráficos verticais\npar(mfrow = c(1, 5))\nplot(t, G6P, type = \"l\")\nplot(t, R5P, type = \"l\")\nplot(t, G3P, type = \"l\")\nplot(t, DHCP, type = \"l\")\nplot(t, PEP, type = \"l\")\n\n\n\n\nCinética de conversões para uma rede metabólica simples envolvendo algumas reações da glicólise, gliconeogênese e via das pentoses. Valores das constantes cinéticas: k1 = 0,1; k2 = 0,5; k3 = 0,05; k4 = 0,5; k5 = 0,2. Valores iniciais dos compostos: G6P = 1; para os demais, 0.\n\n\n\n# Elaboração de gráfico com todas as espécies\npar(mfrow = c(1, 1))\nplot(t, G6P, type = \"l\", col = 1, lty = 1, ylab = \"[espécie]\", ylim = c(0, 1))\nlines(t, R5P, type = \"l\", col = 2, lty = 2)\nlines(t, G3P, type = \"l\", col = 3, lty = 3)\nlines(t, DHCP, type = \"l\", col = 4, lty = 4)\nlines(t, PEP, type = \"l\", col = 5, lty = 5)\nlegend(x = 10, y = 1, legend = c(\"G6P\", \"R5P\", \"G3P\", \"DHCP\", \"PEP\"), col = c(1,\n    2, 3, 4, 5), cex = 1, lty = c(1, 2, 3, 4, 5))\n\n\n\n\nCinética de conversões para uma rede metabólica simples envolvendo algumas reações da glicólise, gliconeogênese e via das pentoses. Valores das constantes cinéticas: k1 = 0,1; k2 = 0,5; k3 = 0,05; k4 = 0,5; k5 = 0,2. Valores iniciais dos compostos: G6P = 1; para os demais, 0.\n\n\n\n\n      Perceba que, pelas quantidades oferecidas à simulação, ou seja, constantes cinéticas e valores iniciais, G3P e PEP registram um intervalo significativo em elevação, também coincidente por sua presença em várias das relações da Eq. @ref(eq:redeMetab1)",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Redes Metabólicas</span>"
    ]
  },
  {
    "objectID": "redes.html#cinética-do-metabolismo-de-6-mercaptopurina",
    "href": "redes.html#cinética-do-metabolismo-de-6-mercaptopurina",
    "title": "11  Redes Metabólicas",
    "section": "11.3 Cinética do metabolismo de 6-mercaptopurina",
    "text": "11.3 Cinética do metabolismo de 6-mercaptopurina\n      Elevando um pouco a complexidade de redes metabólicas, pode-se exemplificar o metabolismo celular da 6-mercaptopurina (6-MP) em função do teor de ATP celular (Lavrova et al. 2017). Como antagonista da purina, o fármaco é empregado na quimioterapia para o tratamento de leucemia linfocítica, interrompendo o crescimento celular, embora produzindo efeitos colaterais citotóxicos advindos de reações com o grupo tiol.\n      A Figura @ref(fig:6MP) representa um esquema simplificado do metabolismo de 6-MP. As concentrações das espécies e constantes cinéticas originam-se dos valores de concentração em \\(\\mu\\)mol/mL, e tempo em dias.\n\n\n\n\n\nMetabolismo esquemático simplificado para o metabolismo de 6-mercaptopurina (adaptado de Lavrova et al., 2017).\n\n\n\n\n      Para as 10 reações referentes às ODEs que compõem a representação do metabolismo de 6-MP (Lavrova et al. 2017), o trecho de código abaixo implementa a solução por Runge-Kutta de 4a. ordem pela função lsoda:\n\nlibrary(deSolve)\n# Parâmetros\nk0 &lt;- 5\nk1 &lt;- 10\nk2 &lt;- 10\nk3 &lt;- 5\nk4 &lt;- 1e-05\nk7 &lt;- 0.01\nk8 &lt;- 0.5\nkm7 &lt;- 1\nkm1 &lt;- 0.01\nkm2 &lt;- 4\nkm3 &lt;- 0.01\nkm4 &lt;- 0.1\nkm8 &lt;- 0.01\nVPUR &lt;- 0.01\nVD &lt;- 0.9\nVOUT &lt;- 1e-04\n# Lista de parâmetros\nparms &lt;- c(k0, k1, k2, k3, k4, k7, k8, km7, km1, km2, km3, km4, km8, VPUR, VD, VOUT)\n# especificação dos compostos\nMPex &lt;- x[1]\nMPin &lt;- x[2]\nTIMP &lt;- x[3]\nTXMP &lt;- x[4]\nTGMP &lt;- x[5]\nmeTGMP &lt;- x[6]\nTITP &lt;- x[7]\nATP &lt;- x[8]\nAMP &lt;- x[9]\nPP &lt;- x[10]\n# Concentrações iniciais das espécies\nreag0 &lt;- c(MPex0 = 0.68, MPin0 = 0, TIMP0 = 0, TXMP0 = 0, TGMP0 = 0, meTGMP0 = 0,\n    TITP0 = 0, ATP0 = 0.2, AMP0 = 0, PP0 = 0)\n\n# Definição do intervalo de tempo\ntmin &lt;- 0\ntmax &lt;- 2\ndt &lt;- 0.01\ntempo &lt;- seq(tmin, tmax, dt)\n# Função para as derivadas de cada espécie\neq.dif &lt;- function(tempo, x, parms) {\n    # Definição de parâmetros\n    MPex &lt;- x[1]\n    MPin &lt;- x[2]\n    TIMP &lt;- x[3]\n    TXMP &lt;- x[4]\n    TGMP &lt;- x[5]\n    meTGMP &lt;- x[6]\n    TITP &lt;- x[7]\n    ATP &lt;- x[8]\n    AMP &lt;- x[9]\n    PP &lt;- x[10]\n    # Equações diferenciais\n    dMPex &lt;- -k0 * MPex\n    dMPin &lt;- -(VPUR + k1) * MPin + k0 * MPex + km1 * TIMP\n    dTIMP &lt;- k1 * MPin + km8 * TITP - (k2 + k7 * ATP + km1 + k8 * PP) * TIMP + km2 *\n        TXMP + km7 * TITP * AMP\n    dTXMP &lt;- k2 * TIMP - k3 * TXMP * ATP - km2 * TXMP + km3 * TGMP * AMP * PP\n    dTGMP &lt;- k3 * TXMP * ATP - (k4 + VD) * TGMP - km3 * TGMP * AMP * PP + km4 * meTGMP\n    dmeTGMP &lt;- k4 * TGMP - VOUT * meTGMP - km4 * meTGMP\n    dTITP &lt;- k8 * TIMP * PP - km8 * TITP + k7 * TIMP * ATP - km7 * TITP * AMP\n    dATP &lt;- -k7 * TIMP * ATP + km3 * TGMP * AMP * PP - k3 * TXMP * ATP + km7 * TITP *\n        AMP\n    dAMP &lt;- -km3 * TGMP * AMP * PP + k3 * TXMP * ATP + k7 * TIMP * ATP - km7 * TITP *\n        AMP\n    dPP &lt;- -k8 * TIMP * PP + km8 * TITP - km3 * TGMP * AMP * PP + k3 * TXMP * ATP\n    list(c(dMPex, dMPin, dTIMP, dTXMP, dTGMP, dmeTGMP, dTITP, dATP, dAMP, dPP))  # lista de valores diferenciais para cada espécie\n}\n# Rotina de lsoda pra solução equações diferenc. ordinárias\nsol.eq &lt;- lsoda(reag0, tempo, eq.dif, parms, rtol = 1e-04, atol = 1e-06)\n# Isolamento das colunas de resultdos\nt &lt;- sol.eq[, 1]\nMPex &lt;- sol.eq[, 2]\nMPin &lt;- sol.eq[, 3]\nTIMP &lt;- sol.eq[, 4]\nTXMP &lt;- sol.eq[, 5]\nTGMP &lt;- sol.eq[, 6]\nmeTGMP &lt;- sol.eq[, 7]\nTITP &lt;- sol.eq[, 8]\nATP &lt;- sol.eq[, 9]\nAMP &lt;- sol.eq[, 10]\nPP &lt;- sol.eq[, 11]\n\n# Elaboração do gráfico\nplot(t, MPex, type = \"l\", xlab = \"tempo, dias\", ylab = \"[espécie], umol/L\")\nlines(t, MPin, type = \"l\", col = 2, lty = 2)\nlines(t, TIMP, type = \"l\", col = 3, lty = 3)\nlines(t, TXMP, type = \"l\", col = 4, lty = 4)\nlines(t, TGMP, type = \"l\", col = 5, lty = 5)\nlines(t, meTGMP, type = \"l\", col = 6, lty = 6)\nlines(t, TITP, type = \"l\", col = 7, lty = 7)\nlines(t, ATP, type = \"l\", col = 8, lty = 8)\nlines(t, AMP, type = \"l\", col = 9, lty = 9)\nlines(t, PP, type = \"l\", col = 10, lty = 10)\nlegend(x = 1.5, y = 0.65, legend = c(\"MPex\", \"MPin\", \"TIMP\", \"TXMP\", \"TGMP\", \"meTGMP\",\n    \"TITP\", \"ATP\", \"AMP\", \"PP\"), col = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), cex = 0.7,\n    lty = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n\n\n\n\nDependência da dinâmica da rede metabólica de degradação de 6-mercaptopurina em função do teor inicial de ATP a 0,2 umol/L. Os valores iniciais e parâmetros são descritos no trecho de código.\n\n\n\n\n      Como a dinâmica de variação dos compostos é dependente do teor inicial de ATP celular, experimente variar esse valor inicial (ex: ATP0=2):\n\n\n\n\n\nDependência da dinâmica da rede metabólica de degradação de 6-mercaptopurina em função do teor inicial de ATP a 2 umol/L. Os valores iniciais e parâmetros são descritos no trecho de código.\n\n\n\n\n      Observe que, com a redução de 10x no teor de ATP, TGMP e TIMP mantiveram teores mais estáveis ao longo do período.\n\n\n\n\nLavrova, Anastasia I, Eugene B Postnikov, Andrey Yu Zyubin, e Svetlana V Babak. 2017. «Ordinary differential equations and Boolean networks in application to modelling of 6-mercaptopurine metabolism». Royal Society Open Science 4 (4): 160872.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Redes Metabólicas</span>"
    ]
  },
  {
    "objectID": "referencias.html",
    "href": "referencias.html",
    "title": "Referências",
    "section": "",
    "text": "Akaike, Hirotugu. 1974. “A New Look at the Statistical Model\nIdentification.” IEEE Transactions on Automatic Control\n19 (6): 716–23.\n\n\nAlberty, Robert A. 1991. “Chemical Equations Are Actually Matrix\nEquations.” Journal of Chemical Education 68 (12): 984.\n\n\n———. 1996. “Calculation of Biochemical Net Reactions and Pathways\nby Using Matrix Operations.” Biophysical Journal 71 (1):\n507–15.\n\n\nBhatti, Haq Nawaz, M Hamid Rashid, Rakhshanda Nawaz, A Mukhtar Khalid,\nMuhammad Asgher, and A Jabbar. 2007. “Effect of Aniline Coupling\non Kinetic and Thermodynamic Properties of Fusarium Solani\nGlucoamylase.” Applied Microbiology and Biotechnology 73\n(6): 1290–98.\n\n\nBloomfield, Victor. 2009. Computer Simulation and Data Analysis in\nMolecular Biology and Biophysics: An Introduction Using r. Springer\nScience & Business Media.\n\n\nCooper, Alan. 2004. “Thermodynamics and Interactions.” In\nBiophysical Chemistry, 99–122.\n\n\nCreighton, Thomas E et al. 2010. Biophysical Chemistry of Nucleic\nAcids & Proteins. Distributed by Gardners Books.\n\n\nDahlquist, FW. 1978. “[13] the Meaning of Scatchard and Hill\nPlots.” Methods in Enzymology 48: 270–99.\n\n\nDeLean, A, PJ Munson, and Dl Rodbard. 1978. “Simultaneous Analysis\nof Families of Sigmoidal Curves: Application to Bioassay, Radioligand\nAssay, and Physiological Dose-Response Curves.” American\nJournal of Physiology-Endocrinology And Metabolism 235 (2): E97.\n\n\nDuff, DG, and CH Giles. 1972. “Spectrophotometric Determination of\nthe Critical Micelle Concentration of Surfactants.” Journal\nof Colloid and Interface Science 41 (3): 407–14.\n\n\nEdelhoch, Harold, and James C Osborne Jr. 1976. “The Thermodynamic\nBasis of the Stability of Proteins, Nucleic Acids, and\nMembranes.” Advances in Protein Chemistry 30: 183–250.\n\n\nGandrud, Christopher. 2018. Reproducible Research with r and\nRStudio. Chapman; Hall/CRC.\n\n\nJohnson, Kenneth A. 1992. “1 Transient-State Kinetic Analysis of\nEnzyme Reaction Pathways.” In The Enzymes, 20:1–61.\nElsevier.\n\n\nKhalil, Mutasim I. 2000. “Calculating Enthalpy of Reaction by a\nMatrix Method.” Journal of Chemical Education 77 (2):\n185.\n\n\nLavrova, Anastasia I, Eugene B Postnikov, Andrey Yu Zyubin, and Svetlana\nV Babak. 2017. “Ordinary Differential Equations and Boolean\nNetworks in Application to Modelling of 6-Mercaptopurine\nMetabolism.” Royal Society Open Science 4 (4): 160872.\n\n\nLeone, Francisco de Assis. 2021. Fundamentos de\nCinética Enzimática. Appris Ed.\n\n\nLiCata, Vince J, and Chin-Chi Liu. 2011. “Analysis of Free Energy\nVersus Temperature Curves in Protein Folding and Macromolecular\nInteractions.” Methods in Enzymology 488: 219–38.\n\n\nMichaelis, L., and ML Menten. 1913. “Die Kinetik Der\nInvertinwirkung.” Biochem Z 49 (4): 333–69.\n\n\nNeto, Benı́cio Barros, Ieda Spacino Scarminio, and Roy Edward Bruns.\n2010. Como Fazer Experimentos-: Pesquisa e Desenvolvimento Na\nCiência e Na Indústria. Bookman Editora.\n\n\nOtaki, Joji M, Shunsuke Ienaka, Tomonori Gotoh, and Haruhiko Yamamoto.\n2005. “Availability of Short Amino Acid Sequences in\nProteins.” Protein Science 14 (3): 617–25.\n\n\nParsons, DL, and JJ Vallner. 1978. “Theoretical Models for\nCooperative Binding—i. One-Site Creator of Binding Sites.”\nMathematical Biosciences 41 (3-4): 189–215.\n\n\nPauling, Linus. 1935. “The Oxygen Equilibrium of Hemoglobin and\nIts Structural Interpretation.” Proceedings of the National\nAcademy of Sciences of the United States of America 21 (4): 186.\n\n\nPo, Henry N, and NM Senozan. 2001. “The Henderson-Hasselbalch\nEquation: Its History and Limitations.” Journal of Chemical\nEducation 78 (11): 1499.\n\n\nRoss, Philip D, and S Subramanian. 1981. “Thermodynamics of\nProtein Association Reactions: Forces Contributing to Stability.”\nBiochemistry 20 (11): 3096–3102.\n\n\nSarkar, Deepayan. 2008. Lattice: Multivariate Data Visualization\nwith r. Springer Science & Business Media.\n\n\nScatchard, George. 1949. “The Attractions of Proteins for Small\nMolecules and Ions.” Annals of the New York Academy of\nSciences 51 (4): 660–72.\n\n\nSpiess, Andrej-Nikolai, and Natalie Neumeyer. 2010. “An Evaluation\nof R2 as an Inadequate Measure for Nonlinear Models in Pharmacological\nand Biochemical Research: A Monte Carlo Approach.” BMC\nPharmacology 10 (1): 1–11.\n\n\nTong, Jianbo, Shan Lei, Shangshang Qin, and Yang Wang. 2018. “QSAR\nStudies of TIBO Derivatives as HIV-1 Reverse Transcriptase Inhibitors\nUsing HQSAR, CoMFA and CoMSIA.” Journal of Molecular\nStructure 1168: 56–64.\n\n\nTraut, Thomas W. 2007. Allosteric Regulatory Enzymes. Springer\nScience & Business Media.\n\n\nTyuma, Itiro, Kiyohiro Imai, and Katsuhiko Shimizu. 1973.\n“Analysis of Oxygen Equilibrium of Hemoglobin and Control\nMechanism of Organic Phosphates.” Biochemistry 12 (8):\n1491–98.\n\n\nWaelbroeck, Magali, E Van Obberghen, and P De Meyts. 1979.\n“Thermodynamics of the Interaction of Insulin with Its\nReceptor.” Journal of Biological Chemistry 254 (16):\n7736–40.\n\n\nWickham, Hadley. 2011. “Ggplot2.” Wiley\nInterdisciplinary Reviews: Computational Statistics 3 (2): 180–85.\n\n\nWilkinson, GN. 1961. “Statistical Estimations in Enzyme\nKinetics.” Biochemical Journal 80 (2): 324–32.\n\n\nYung-Chi, Cheng, and William H Prusoff. 1973. “Relationship\nBetween the Inhibition Constant (KI) and the Concentration of Inhibitor\nWhich Causes 50 Per Cent Inhibition (I50) of an Enzymatic\nReaction.” Biochemical Pharmacology 22 (23): 3099–3108.",
    "crumbs": [
      "Referências"
    ]
  }
]