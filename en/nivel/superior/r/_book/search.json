[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantitative Biochemistry & R",
    "section": "",
    "text": "R is free software developed for statistical computing and graphics. R runs on several user interfaces (GUI), among which RStudio stands out, an integrated development environment (IDE) that is also free. Rstudio also has a free online version, accessible through the Posit Cloud website.\nThe R & RStudio platform can be used in a virtually unlimited way for various fields of knowledge. Among these are the Natural Sciences and, in particular, Biochemistry, Molecular Biology, Biophysics, and related areas.\n\n\n\n1 Biochemistry\nTo access the content developed with R and RStudio for Biochemistry and related topics, you can either download the ebook Quantitative Biochemistry & R, or access the individual topics below.\nThis allows you to reproduce the activities in any topic covered by simply clicking on the upper right corner of the code snippet containing a copy icon, and pasting it into an installed session of RStudio, or in its online version RStudio Cloud. This quick tutorial in video illustrates the tip.\nThere are many features that enable the use of R & RStudio for teaching and learning in Biochemistry. Some of these features reside in Reproducible Research (Gandrud, 2018), which is briefly guided by:\n\n1) Availability of original data;\n2) Existence of a code to process and analyze this data;\n3) Documentation of data and code, enabling reproducibility;\n4) Distribution and accessibility of the code.\n\nIn this sense, the production of texts, tables, graphs, data analysis, and simulations can be perfectly adjusted to teaching-learning through the use of such principles and the simultaneity of text and code, touching on Reproducible Teaching. This approach allows the reader to study the various topics covered through reading and interpretation, as well as to gain a more convergent understanding through the execution, modification, and creation of codes relevant to each topic. In this work, these concepts are applied to the quantitative content and mathematical relationships of the topics covered in Biochemistry.\n\nThese relationships are present in Biochemistry textbooks and cover, for example, titration curves of weak acids and amino acids, the study of effective charges in biomolecules, physical-chemical characteristics of proteins and nucleic acids predicted by sequence analysis, enzyme kinetics and their inhibition, thermodynamic quantities and bioenergetics, ligand-biopolymer interaction, stoichiometry of biochemical reactions, biochemical pathways and metabolic networks, among others.\nIn general, the above topics are covered in this material with the help of R & RStudio. However, its content does not intend to go beyond a superficial treatment of the use of R, RStudio, or even the proposed topics in Biochemistry. For these, traditional sources of tutorials, textbooks, and the internet are recommended. Nor does it venture into the universe of Bioinformatics, traditional or structural, such as Systems Biology, sequence alignment, structural prediction, molecular modeling, dynamics, and docking, or the various facets of omic studies.\nIn summary, the objective is only to address the quantitative content and mathematical relationships present in part of Biochemistry, as described above, using R & Rstudio. This approach touches on problem solving and simulations using linear systems of equations, linear algebra, linear, nonlinear, polynomial, and multiple linear regression, optimization, minimization, simple differential equations, and sequence analysis, among others.\nSecondarily, the objective is to allow the reader to reproduce calculations, graphs, and/or tables relevant to the listed content by repeating or modifying simple code snippets and scripts.\n\n\n2 Quantitative Biochemistry with R & RStudio\nFor the study of Biochemistry and related topics with the aid of the R & RStudio platform, you can access the individual topics below, which are also mirrored in the book Bioquímica Quantitativa & R (Portuguese).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGANDRUD, C. Reproducible research with R and RStudio. [S. l.]: Chapman; Hall/CRC, 2018.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "biomoleculas_en.html",
    "href": "biomoleculas_en.html",
    "title": "2  Biomolecules",
    "section": "",
    "text": "2.1 Dimensions\n# Some time unit conversions\nsec &lt;- 1\nmin &lt;- 60 * sec\nhr &lt;- 60 * min\nday &lt;- 24 * hr\nyears &lt;- 365 * day\n# What is the value in seconds for a whole day?\nday / sec\n\n[1] 86400\n\n# What is the value in minutes for a whole year?\nyears / min\n\n[1] 525600\n\n# And what is the age of the Earth in seconds (4.5e9 years)?\n4.5e9 * years / sec\n\n[1] 1.41912e+17\n# Molar quantity conversions\nmmol &lt;- 1 # quantity definitions\numol &lt;- 1e-3 * mmol # micromol\nnmol &lt;- 1e-3 * umol # nanomol\npmol &lt;- 1e-3 * nmol # picomol\n\n# How many picomoles are there in 6.25 mmol?\n\n6.25 * mmol / pmol\n\n[1] 6.25e+09",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biomolecules</span>"
    ]
  },
  {
    "objectID": "biomoleculas_en.html#sec-biomol",
    "href": "biomoleculas_en.html#sec-biomol",
    "title": "2  Biomolecules",
    "section": "",
    "text": "Quantities can be converted with the help of R, as long as the units involved are defined. For example, we can convert and calculate the elapsed time of an event in different units, as follows:\n\nIt is also possible to convert units between each other, as in the quantities below:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biomolecules</span>"
    ]
  },
  {
    "objectID": "biomoleculas_en.html#structural-versatility-in-biopolymers",
    "href": "biomoleculas_en.html#structural-versatility-in-biopolymers",
    "title": "2  Biomolecules",
    "section": "2.2 Structural versatility in biopolymers",
    "text": "2.2 Structural versatility in biopolymers\nBiopolymers, or biomacromolecules, can be considered polymers with monomeric units composed of biomolecules. Thus, proteins, nucleic acids or glycans (polysaccharides) are respectively formed by amino acids (20 types that can be encoded in proteins, from 64 codons of the genetic code), nitrogenous bases (4 types with cytosine in DNA replaced by uracil in RNA) and monosaccharides (fewer than 6 types).\nFrom the point of view of structural variability, taking only the combination of monomers as a basis, it is possible to predict the number of distinct structures by the simple relation (Otaki et al. 2005):\n\\[\nno. biopolymers = {monomers}^{sequence}\n\\tag{2.1}\\]\nIn ‘R’ the operation is very simple, as in the example below:\n\n# Calculation of possible peptide structures in a\n# sequence of 8 elements (e.g. angiotensin II)\n\n20^8\n\n[1] 2.56e+10\n\n\nOf course, this simulated variability does not materialize in Nature, since the calculation assumes the repetition of any monomer along the sequence, or of sets or alterations of these. In other words, peptides with only one or two types of amino acids, for example, are not physiologically viable. This becomes concrete when we observe that there are around 35 thousand proteins expressed by the human genome, and whose average size is around 476 amino acid residues. If we apply the equation \\(\\eqref{eq-variab}\\) above to this situation, we would find…\n\n# Calculation of possible human protein structures in an average sequence of\n# 476 amino acid residues.\n\n20^476\n\n[1] Inf\n\n\nIn other words, not even R is capable of calculating, since the size of the sequence is computationally limited in the program to 237 residues (20\\(^{237}\\) = 1.1x10\\(^{307}\\)). Although it may seem like a limitation, it results in a value far above Avogadro’s number (6.02x10\\(^{23}\\)), and even above the computational limit for some mathematical programs, such as those found in internet algorithms (Google) and mathematical programs (e.g. Gnu Octave). Even so, Maxima, a freely distributed mathematical program, reports that 20\\(^{476}\\) represents a value with 570 digits (something like 10\\(^{569}\\)).\nOn the other hand, these simple calculations also do not take into account that biomolecules can present different types of isomerism, such as optical (D/L), positional, geometric (cis/trans), configurational (syn/anti), or conformational (boat/chair), which considerably increases the number of possible structures in Nature.\n\n\n\n\nOtaki, Joji M, Shunsuke Ienaka, Tomonori Gotoh, e Haruhiko Yamamoto. 2005. «Availability of short amino acid sequences in proteins». Protein science 14 (3): 617–25.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Biomolecules</span>"
    ]
  },
  {
    "objectID": "tampoes_en.html",
    "href": "tampoes_en.html",
    "title": "3  Biological buffer system",
    "section": "",
    "text": "3.1 Acetate system\n\\[\\begin{equation}\npH = pKa + log\\frac{[A^-]}{[HA]}\n\\label{hender-hassel}\n\\end{equation}\\]\n\\[\\begin{equation}\nfa+fb=1\n\\label{frac-tit}\n\\end{equation}\\]\n\\[\\begin{equation}\npH = pKa + log\\frac{fb}{1-fb}\n\\label{HH-frac}\n\\end{equation}\\]\nFrom this derivation, one can easily relate that:\n\\[\\begin{equation}\nfb = \\frac{10^{(pH-pKa)}} {1+10^{(pH-pKa)}}\n\\label{HH-fb}\n\\end{equation}\\]\nAnd, similarly, one can find fa as\n\\[\\begin{equation}\nfa = 1- fb\n\\label{HH-fb2}\n\\end{equation}\\]\nResulting in\n\\[\\begin{equation}\nfa = \\frac{1}{1+10^{(pH-pKa)}}\n\\label{eq-HH-fa}\n\\end{equation}\\]\n# Arguments for a function\nargs(curve)\n\nfunction (expr, from = NULL, to = NULL, n = 101, add = FALSE, \n    type = \"l\", xname = \"x\", xlab = xname, ylab = NULL, log = NULL, \n    xlim = NULL, ...) \nNULL\nOr, in a simpler way:\n# Titration curve for the acetate/acetic acid system\npKa = 4.75\ncurve((1/(1+10^(x-pKa))),0.14)\n\n\n\n\nRelationship between pH (abscissa) and acid fraction (ordinate) for the conjugate pair acetic acid/acetate ion.\n# Titration curve for the acetate/acetic acid system\npKa = 4.75\ncurve(((10^(x-pKa))/(1+10^(x-pKa))),0.14)\n\n\n\n\nRelationship between pH (abscissa) and basic fraction (ordinate) for the conjugate pair acetic acid/acetate ion.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Biological buffer system</span>"
    ]
  },
  {
    "objectID": "tampoes_en.html#acetate-system",
    "href": "tampoes_en.html#acetate-system",
    "title": "3  Biological buffer system",
    "section": "",
    "text": "The titration of a weak acid is based on the Henderson-Hasselbach equation as follows (Po e Senozan 2001) :\n\nIt turns out that we can treat the contents of \\(A^-\\) and \\(HA\\) not in absolute terms, but as fractions, both of base (fb) and acid (fa), such that:\n\nThus, it can be defined that after a certain amount of base, the initial value of HA, in unitary fraction, will be 1-fb; thus, the Henderson-Hasselbach expression can be written as:\n\n\n\n\n\n\n\nIn this way, it is possible to simulate by R a titration curve of any weak acid based on its pKa value. Using an acetobacterial medium as an example, we can illustrate the acetate buffer, with a pKa value of 4.75. To do this, the curve function is used with its arguments (args), as follows:\n\n\n\nYou can also do the opposite, creating a graph with the fraction fb:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Biological buffer system</span>"
    ]
  },
  {
    "objectID": "tampoes_en.html#bicarbonate-system",
    "href": "tampoes_en.html#bicarbonate-system",
    "title": "3  Biological buffer system",
    "section": "3.2 Bicarbonate system",
    "text": "3.2 Bicarbonate system\nWith the above procedure, it is also possible to simulate the titration curve for the blood buffer bicarbonate system based on the pKa values ​​of the conjugate acid-base pair, simply by adding the expressions in the equation \\(\\eqref{eq-HH-fa}\\), such that:\n\\[\\begin{equation}\nfa = \\frac{1}{1+10^{(pH-pKa1)}}+ \\frac{1}{1+10^{(pH-pKa2)}}\n\\label{HHbic}\n\\end{equation}\\]\nTherefore,\n\npKa1 = 6.37\npKa2 = 10.20\ncurve((1/(1+10^(x-pKa1)))+1/(1+10^(x-pKa2)),0,14)\n\n\n\n\n\n\n\nFigura 3.1: Relationship between pH (abscissa) and acid fraction (ordinate) for the conjugate carbonic acid/bicarbonate ion pair.\n\n\n\n\n\nThe Figura 3.1 graph can be stored in formats, using, for example, the dev.copy command:\n\ndev.copy(pdf,\"titBicarb.pdf\",width=6, height=3) # alternatively, bmp,\n# jpeg, tiff, svg, png\n\nAnd of course, starting from the arguments of the curve function above, and the flexibility that the internal package Graphics of R allows, one can elaborate a more complex curve, as follows:\n\npKa1 = 6.37\npKa2 = 10.20\ncurve((1/(1+10^(x-pKa1)))+1/(1+10^(x-pKa2)),0,14,\nxlab=\"pH\",ylab=\"fa\",\nmain=\"Carbonic Acid Titration, H2CO3/HCO3-\",\ntype=\"o\", n=50,lwd=2,lty=\"dotted\",\npch=3,col=\"blue\",cex=1.2) # titration graph\n\ntext(4.7,1.3,\"pKa = 6.37\") # inserting text into the graph\ntext(9,0.3,\"pKa = 10.20\")\nabline(0.5,0, lty=\"dotted\") # dotted line at specific intercept\n# and slope\nabline(1.5,0, lty=\"dotted\")\n\n\n\n\nVariation of pH with reduction of the acid fraction in a bicarbonate system.\n\n\n\n\nFor illustration purposes, it is possible to “recover” the physiological pKa value above, that is, pKa1, using the locator() command. Since it is just one point on the graph, simply type the code locator(1) and left-click on the point on the curve corresponding to the fraction of 0.5 for fa.\n\nlocator(1) # for more points on the graph, simply increase the value in parentheses\n\nNote that as the pH value approaches that of pKa, the increasing variation in fa seems to affect the variation in pH less and less. This is the “soul” of the buffer system, which allows organisms to resist pH variations as long as they are close to the corresponding pKa value (bicarbonate, phosphate, proteins).\nWhile the bicarbonate system has two pKa values ​​1 , one of which is in the extracellular physiological buffering range, the phosphate system that acts intracellularly has three pKa values, although it also acts in only one physiological range.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Biological buffer system</span>"
    ]
  },
  {
    "objectID": "tampoes_en.html#phosphate-system",
    "href": "tampoes_en.html#phosphate-system",
    "title": "3  Biological buffer system",
    "section": "3.3 Phosphate system",
    "text": "3.3 Phosphate system\nIn the same way as simulated for the bicarbonate system, we can develop a titration curve for the phosphate buffering system, this time considering its three pKa values ​​corresponding to each dissociation of triprotic acid. As before, the expression that defines the fraction fa should be taken as an algebraic sum, as follows:\n\\[\\begin{equation}\nfa = \\frac{1}{1+10^{(pH-pKa1)}}+ \\frac{1}{1+10^{(pH-pK2)}}+\\frac{1}{1+10^{(pH-pKa3)}}\n\\label{eq-HHfosf}\n\\end{equation}\\]\nIn R this can be done as follows: \\(\\eqref{eq-HHfosf}\\)\n\npKa1=2.2\npKa2=7.2\npKa3=12.7\n\ncurve((1/(1+10^(x-pKa1)))+\n(1/(1+10^(x-pKa2)))+\n(1/(1+10^(x-pKa3))),\nxlim=c(1,14),\nxlab=\"pH\",ylab=\"fa\",\nmain=\"Phosphate buffer titration\",\nsub = \" Dotted lines cross pKa values\"\n)\nabline(v=c(2.2,7.2,12.7),col=c(\"blue\",\"red\",\"green\"),lty=\"dotted\") # adding\n# vertical lines marking pKa values\ntext(1.6,2.5,\"pKa1\")\ntext(6.5,1.5,\"pKa2\")\ntext(11.8,0.5,\"pKa3\")\n\n\n\n\nTitration curve in a phosphate system buffering.\n\n\n\n\n\n3.3.1 General system titration with R programming\nAs illustrated in the supply of arguments to the args function, ‘R’ is an object-oriented programming language, and its commands are structured as functions. Thus, it is possible to create a function in ‘R’ to operationalize or automate any computational work.\nA function can be created basically by the following instruction:\n\nfunction.X &lt;- function( arg1, arg2, arg3 )\n{\nexecution commands\nreturn(function object)\n}\n\nAs an example, a function can be created to convert the temperature from degrees Celsius (C) to absolute temperature (K), as follows:\n\n# Function to convert degrees Celsius to Kelvin\nCtoK &lt;- function (tC) {\ntK &lt;-tC + 273.15\nreturn(tK)\n}\n\nTo execute this CtoK function, simply:\n\n# Executing CtoK:\nCtoK (37)\n\n[1] 310.15\n\n\nWith this in mind, we can also create a function that helps in the elaboration of titration curves, as above. These operations can be automated not only for the phosphate buffer, but for any compound under dissociation in aqueous medium, regardless of the number of protons involved. To do this, it is necessary to:\n\nDefine a function of R that contains the parameters and the desired operation.\nInclude a loop structure in the function that allows the operation to be repeated until the compound’s proton count is exhausted.\nDefine a vector of R containing the compound’s pKa values.\nDefine the curve expression that enables the simulation.\n\nBelow is a code model that allows the simulation for the phosphate buffer.\n\n#Define titration function and plot\nfa = function(pH,pKa) {\nx=0\nfor(i in 1:length(pKa)) {\nx = x+1/(1 + 10^(pH - pKa[i]))}\nreturn(x)\n}\npKa=c(2.2,7.2,12.7)\ncurve(fa(x,pKa),1,14, xlab=\"pH\", ylab=\"fa\",\ncol=2)\n\n\n\n\nTitration curve for phosphate buffer, as obtained by programming in R.\n\n\n\n\n\n\n\n\nPo, Henry N, e NM Senozan. 2001. «The Henderson-Hasselbalch equation: its history and limitations». Journal of Chemical Education 78 (11): 1499.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Biological buffer system</span>"
    ]
  },
  {
    "objectID": "tampoes_en.html#footnotes",
    "href": "tampoes_en.html#footnotes",
    "title": "3  Biological buffer system",
    "section": "",
    "text": "Note: the pKa value of the bicarbonate system is 6.8 when considering \\(CO_2\\) as a source of carbonic acid \\(H_2CO_3\\) in its reaction with \\(H_2O\\), for example, for determining arterial parameters and from hospital analyzer (\\(CO_2\\), \\(HCO_3^-\\), \\(O_2\\)).↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Biological buffer system</span>"
    ]
  },
  {
    "objectID": "aminoacid_en.html",
    "href": "aminoacid_en.html",
    "title": "4  Amino acids",
    "section": "",
    "text": "4.1 Isoelectric point & amino acids\nFor example, glutamic acid (Glu, E) has an ionizable carboxylate in its side chain, in addition to the amine (-H\\(_2\\)N) and carboxylate groups of the carbon skeleton Figura 4.1:\nFigura 4.1: Planar structural formula for glutamic acid (Wikimedia).\n\\[\nqnet = qb + qa\n\\tag{4.1}\\]\n\\[\nqnet = qb+\\frac{1}{1+10^{pH-pKa}}\n\\tag{4.2}\\]\n\\[\nqnet = \\sum_{i=1}^{n} {(qb+\\frac{1}{1+10^{pH-pKi}})}\n\\tag{4.3}\\]\n, with pKi as the nth value of pKa. In this way, it is possible to programmatically determine the titration curve of glutamic acid as a function of its charge, and not of the acid fraction. In this line, qb represents the form of the compound in base, which for Glu will present the values ​​of -1 for the two carboxylates, and 0 for the amine group, making it necessary to compose an additional vector for qb.\n# Glu Titration\n\nqNet &lt;- function(pH, qB, pKa) {\nx &lt;- 0\nfor (i in 1:length(qB)) {\nx &lt;- x + qB[i] + 1 / (1 + 10^(pH - pKa[i]))\n}\nreturn(x)\n}\nqB &lt;- c(-1, 0, -1)\npKa &lt;- c(2.2, 9.7, 4.3)\n\ncurve(qNet(x, qB, pKa), 1, 12, xlab = \"pH\", ylab = \"qNet\")\n\nabline(0, 0, lty = \"dotted\")\n\n\n\n\nTitration curve for glutamic acid. The curve intersects the dotted line at the isoionic point of Glu.\n# Calculation of pI\nf &lt;- function(pH) {\nqNet(pH, qB, pKa)\n}\nstr(uniroot(f, c(2, 5)))\n\nList of 5\n $ root      : num 3.25\n $ f.root    : num -4.8e-06\n $ iter      : int 4\n $ init.it   : int NA\n $ estim.prec: num 6.1e-05\n\\[\npI = \\frac{pKa1+pKa2}{2}\n\\tag{4.4}\\]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Amino acids</span>"
    ]
  },
  {
    "objectID": "aminoacid_en.html#secAAcido",
    "href": "aminoacid_en.html#secAAcido",
    "title": "4  Amino acids",
    "section": "",
    "text": "In general, the isoelectric point, or pI, represents the pH value at which a molecule acquires a net zero charge under an electric field, that is, its positive charges cancel each other out with the negative charges. It is usually obtained experimentally by kinetic measurements, such as Zeta potential, electrofocusing or capillary electrophoresis. Similarly, the isoionic point refers to the same condition, however in the absence of an electric field, and can be measured by potentiometric titration, viscosity, or by the structural information of a monomeric sequence, such as in the primary sequence of proteins.\nSince all 20 amino acids that make up the protein structure have ionizable groups, both in their carbon skeleton and in their side chain, it is possible to predict the isoionic point of an amino acid based on the pKa values ​​presented in these ionizable groups. The pI is also commonly called the isoelectric point, although this definition entails a more complex theoretical scope.\n\n\nThus, its net net charge, qnet, can be determined from the sum of the acidic (qa) and basic (qb) forms of the molecule, in a similar way as that presented from the equation \\(\\eqref{eq-HHfosf}\\):\n\n\nSince this is a polyprotic acid, Equação 4.2 becomes:\n\n\n\nIt is possible to manually identify the pI value for glutamic acid using an R function, such as locator() seen previously. But it is also possible to access this value automatically, by applying a command that finds the root of this function, that is, the pH value that corresponds to a null value for qnet. For this, the use of uniroot is exemplified, in which the desired mathematical function is defined, as well as the lower and upper limits for the search by the algorithm, as follows:\n\nThis result translates to a pI of 3.25 (root), in 4 iterations, with an estimated precision of 6.1x10\\(^{-5}\\), and an associated error of -4.8x10\\(^{-6}\\).\nThis way of obtaining a value using numerical calculation is sometimes called a numerical solution. On the other hand, the pI value for Glu can be obtained by a simpler procedure, usually found in textbooks on the subject, and which takes the form below:\n\nIn our example, the pI will involve the pKas of the two carboxylates, which will result in (2.3+4.2)/2, or 3.25! Not bad for an approximation, huh? This procedure involving the solution of a mathematical problem based on system parameters is called an analytical method or solution. This solution can also be exemplified by the parameter obtained based on the observation of the graphical behavior of the titration, as in the figures above.\nNow, what use is a more complex numerical procedure if a simple analytical equation already solves the problem of finding the pI value for glutamic acid? Well, exactly for that, to solve more complex problems. A little less rhetorically, however, it can be said that the numerical solution works better for systems where the analytical solution is sometimes not enough or even becomes impossible, as in the solution of equations with dozens of parameters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Amino acids</span>"
    ]
  },
  {
    "objectID": "aminoacid_en.html#isoionic-point-biopolymers",
    "href": "aminoacid_en.html#isoionic-point-biopolymers",
    "title": "4  Amino acids",
    "section": "4.2 Isoionic point & biopolymers",
    "text": "4.2 Isoionic point & biopolymers\nA situation on this topic can be illustrated by obtaining the pI value for a protein. For example, human lysozyme , an enzyme with a tertiary structure composed of 130 amino acid residues. In this case, the analytical solution is faced with the complexity of identifying which of these residues are ionizable in aqueous solution, and which would be involved in a distribution that would result in a net zero charge for the molecule.\nFor this more complex system, it is necessary to slightly expand the function defined for glutamic acid, computing in the qb vector the base charges of the 7 amino acids with ionizable side chains, and assigning a new vector for the quantity of each ionizable residue present in lysozyme. The code below exemplifies this solution, calculates the pI of the enzyme, and plots the graph of its titration, although this order is not relevant, since the pI is calculated numerically, not graphically.\n\n# Lysozyme Titration and pI Determination\n\n# Define function for qNet\nqNet &lt;- function(pH, qB, pKa, n) {\nx &lt;- 0\nfor (i in 1:length(qB)) {\nx &lt;- x + n[i] * qB[i] + n[i] / (1 + 10^(pH - pKa[i]))\n}\nreturn(x)\n}\n\n# Define pKas of aCOOH, aNH3 and the 7 side chains of AA\npKa &lt;- c(2.2, 9.6, 3.9, 4.1, 6.0, 8.5, 10.1, 10.8, 12.5)\n\n# Define qB, the charges of each amino acid in the base form\nqB &lt;- c(-1, 0, -1, -1, 0, -1, -1, 0, 0)\n\nionizable &lt;- c(\n\"aCOOH\", \"aNH3\", \"Asp\", \"Glu\", \"His\", \"Cys\", \"Tyr\",\n\"Lys\", \"Arg\"\n)\nn &lt;- c(1, 1, 7, 3, 1, 8, 6, 5, 14) # List of amounts of residues\n# ionizable in lysozyme (each element represents the amount\n# of aCOOH, aNH3, and certain AA in the enzyme)\n\n# Calculation of pI\nf &lt;- function(pH) {\nqNet(pH, qB, pKa, n)\n}\nstr(uniroot(f, c(1, 13))) # estimation of pI between 10 and 12\n\nList of 5\n $ root      : num 9.46\n $ f.root    : num 3.3e-07\n $ iter      : int 7\n $ init.it   : int NA\n $ estim.prec: num 6.1e-05\n\n# Titration graph\ncurve(qNet(x, qB, pKa, n), 1, 12, xlab = \"pH\", ylab = \"qNet\")\nabline(0, 0, lty = 3)\n\n\n\n\nTitration curve for lysozyme.\n\n\n\n\nNote that the value found for pI of lysozyme was 9.46; that is, at pH 9.46 the enzyme presents a net net charge of zero, as can also be seen in the graphical representation.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Amino acids</span>"
    ]
  },
  {
    "objectID": "aminoacid_en.html#isoionic-point-r-libraries",
    "href": "aminoacid_en.html#isoionic-point-r-libraries",
    "title": "4  Amino acids",
    "section": "4.3 Isoionic point & R libraries",
    "text": "4.3 Isoionic point & R libraries\nDespite the precision of the pI calculation by the numerical solution performed for lysozyme, one of the most fascinating features of the program lies in the use of libraries (packages), which is no different for determining biopolymer properties, such as pI.\nAmong the existing libraries for physicochemical properties of proteins and nucleic acids, the seqinr package, Biological Sequences Retrieval and Analysis 1, for exploratory analysis and visualization of biopolymers, is an example. To use this package, however, it is necessary to obtain the primary sequence of the protein, represented in a one-letter code. The primary sequence of lysozyme can be obtained from the website of the National Center for Biotechnology Information, NCBI 2. A quick trick involves:\n\ntype the name of the protein;\nselect from the resulting options;\nclick on FASTA to obtain the 1-letter primary sequence.\ncopy the presented protein sequence to seqinr.\n\nAssuming that the seqinr library is installed, and that the sequence has been obtained for lysozyme (search for CAA32175 or lysozyme [Homo sapiens]), the pI value for it can be found using the following code:\n\nlibrary(seqinr)\nlysozyme &lt;- s2c(\"KVFERCELARTLKRLGMDGYRGISLANWMCLAKWESGYNTRATNYNAGDR\nSTDYGIFQINSRYWCNDGKTPGAVNACHLSCSALLQDNIADAVACAKRVV\nRDPQGIRAWVAWRNRCQNRDVRQYVQGCGV\")\n# convert string sequence to character vector\ncomputePI(lysozyme)\n\n[1] 9.2778\n\n\nNote that the pI value for the package, 9.28, was very close to that found by the numerical solution above. This is due to the use of different algorithms for both, as well as the computation of different pKa values ​​for seqinr. As an example of this variation, seqinr itself presents different pKa values, depending on the database searched. To verify this, type the command below and view the resulting pK variable.\n\nlibrary(seqinr)\ndata(pK)\n\nAdditionally, you can also compare the pI value of lysozyme with the algorithm used by the database on the 3 website. To do this, simply paste the residue sequence into the available field and click on the pI computation. Note that the resulting value of 9.28 matches that of the algorithm used by the R seqinr package.\n\nlibrary(knitr)\nknitr::kable(pK, \"pipe\", caption = \"Table of pKa values ​​for amino acids\nfrom various sources, extracted from the seqinr package.\")\n\n\nTable of pKa values ​​for amino acids from various sources, extracted from the seqinr package.\n\n\n\nBjellqvist\nEMBOSS\nMurray\nSillero\nSolomon\nStryer\n\n\n\n\nC\n9.00\n8.5\n8.33\n9.0\n8.3\n8.5\n\n\nD\n4.05\n3.9\n3.68\n4.0\n3.9\n4.4\n\n\nE\n4.45\n4.1\n4.25\n4.5\n4.3\n4.4\n\n\nH\n5.98\n6.5\n6.00\n6.4\n6.0\n6.5\n\n\nK\n10.00\n10.8\n11.50\n10.4\n10.5\n10.0\n\n\nR\n12.00\n12.5\n11.50\n12.0\n12.5\n12.0\n\n\nY\n10.00\n10.1\n10.07\n10.0\n10.1\n10.0\n\n\n\n\n\nThere are other R packages that analyze amino acid and nucleotide sequences, including the calculation of pI, among which it is worth mentioning Peptides 4.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Amino acids</span>"
    ]
  },
  {
    "objectID": "aminoacid_en.html#footnotes",
    "href": "aminoacid_en.html#footnotes",
    "title": "4  Amino acids",
    "section": "",
    "text": "seqinr package: https://cran.r-project.org/web/packages/seqinr/index.html↩︎\nNCBI. https://www.ncbi.nlm.nih.gov/protein↩︎\nExpasy. https://web.expasy.org/compute_pi/↩︎\nPeptides package. https://cran.r-project.org/web/packages/Peptides/index.html↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Amino acids</span>"
    ]
  },
  {
    "objectID": "proteinas_en.html",
    "href": "proteinas_en.html",
    "title": "5  Proteins",
    "section": "",
    "text": "5.1 Amino acid composition\nseq &lt;- \"MKWVTFISLLFLFSSAYSRGVFRRDAHKSEVAHRFKDLGEENFKALVLIAFAQYLQQCPFEDHVKLVNEV\nTEFAKTCVADESAENCDKSLHTLFGDKLCTVATLRETYGEMADCCAKQEPERNECFLQHKDDNPNLPRLV\nRPEVDVMCTAFHDNEETFLKKYLYEIARRHPYFYAPELLFFAKRYKAAFTECCQAADKAACLLPKLDELR\nDEGKASSAKQRLKCASLQKFGERAFKAWAVARLSQRFPKAEFAEVSKLVTDLTKVHTECCHGDLLECADD\nRADLAKYICENQDSISSKLKECCEKPLL EKSHCIAEVENDEMPADLPSLAADFVESKDVCKNYAEAKDVF\nLGMFLYEYARRHPDYSVVLLLRLAKTYETTLEKCCAAADPHECYAKVFDEFKPLVEEPQNLIKQNCELFE\nQLGEYKFQNALLVRYTKKVPQVSTPTLVEVSRNLGKVGSKCCKHPEAKRMPCAEDYLSVVLNQLCVLHEK\nTPVSDRVTKCCTESLVNRRPCFSALEVDETYVPKEFNAETFTFHADICTLSEKERQIKKQTALVELVKHK\nPKATKEQLKAVMDDFAAFVEKCCKADDKETCFAEEGKKLVAASQAALGL\"\nseq &lt;- seq[seq != \"\\n\"]\nseq # boolean operation != means \"no\"\nNext, you get the quantity of a specific letter in the sequence.\nlibrary(stringr)\naa &lt;- str_count(seq, pattern = \"A\")\naa\n\n[1] 63\nlibrary(stringr)\nala &lt;- str_count(seq, pattern = \"A\")\narg &lt;- str_count(seq, pattern = \"R\")\nasn &lt;- str_count(seq, pattern = \"N\")\nasp &lt;- str_count(seq, pattern = \"D\")\ncys &lt;- str_count(seq, pattern = \"C\")\nglu &lt;- str_count(seq, pattern = \"E\")\ngln &lt;- str_count(seq, pattern = \"Q\")\ngly &lt;- str_count(seq, pattern = \"G\")\nhis &lt;- str_count(seq, pattern = \"H\")\nile &lt;- str_count(seq, pattern = \"I\")\nleu &lt;- str_count(seq, pattern = \"L\")\nlys &lt;- str_count(seq, pattern = \"K\")\nmet &lt;- str_count(seq, pattern = \"M\")\nphe &lt;- str_count(seq, pattern = \"F\")\npro &lt;- str_count(seq, pattern = \"P\")\nser &lt;- str_count(seq, pattern = \"S\")\nthr &lt;- str_count(seq, pattern = \"T\")\ntrp &lt;- str_count(seq, pattern = \"W\")\ntyr &lt;- str_count(seq, pattern = \"Y\")\nval &lt;- str_count(seq, pattern = \"V\")\nAnd, to visualize the result in a table:\naa_3abrev &lt;- c(\"Ala\", \"Arg\", \"Asn\", \"Asp\", \"Cys\", \"Glu\",\n    \"Gln\", \"Gly\", \"His\", \"Ile\", \"Leu\", \"Lys\", \"Met\",\n    \"Phe\", \"Pro\", \"Ser\", \"Thr\", \"Trp\", \"Tyr\", \"Val\")\naa_quant &lt;- c(ala, arg, asn, asp, cys, glu, gln, gly,\n    his, ile, leu, lys, met, phe, pro, ser, thr, trp,\n    tyr, val)  # vector with the quantity of amino acids in the protein\naa_seq &lt;- data.frame(aa_3abrev, aa_quant)  # dataframe with the results\ncolnames(aa_seq) &lt;- c(\"Tipo\", \"Qtde\")  # rename the columns\n\n# Amino acid composition in human serum albumin\naa_seq  # displays the table\n\n   Tipo Qtde\n1   Ala   63\n2   Arg   27\n3   Asn   17\n4   Asp   36\n5   Cys   35\n6   Glu   62\n7   Gln   20\n8   Gly   13\n9   His   16\n10  Ile    9\n11  Leu   64\n12  Lys   60\n13  Met    7\n14  Phe   35\n15  Pro   24\n16  Ser   28\n17  Thr   29\n18  Trp    2\n19  Tyr   19\n20  Val   43\nlibrary(knitr) # to generate the table\n\nknitr::kable(aa_seq, caption = \"Composition of amino acids in human serum albumin.\", \"pipe\") # table\n\n\nComposition of amino acids in human serum albumin.\n\n\nTipo\nQtde\n\n\n\n\nAla\n63\n\n\nArg\n27\n\n\nAsn\n17\n\n\nAsp\n36\n\n\nCys\n35\n\n\nGlu\n62\n\n\nGln\n20\n\n\nGly\n13\n\n\nHis\n16\n\n\nIle\n9\n\n\nLeu\n64\n\n\nLys\n60\n\n\nMet\n7\n\n\nPhe\n35\n\n\nPro\n24\n\n\nSer\n28\n\n\nThr\n29\n\n\nTrp\n2\n\n\nTyr\n19\n\n\nVal\n43\naa_1abrev &lt;- c(\"A\", \"R\", \"N\", \"D\", \"C\", \"E\", \"Q\", \"G\", \"H\", \"I\", \"L\", \"K\", \"M\",\n\"F\", \"P\", \"S\", \"T\", \"W\", \"Y\", \"V\")\nfor (i in aa_1abrev) {\naa_quant2 &lt;- str_count(seq, pattern = aa_1abrev)\nreturn(aa_quant2) # optional syntax for function with only one output\n}\naa_seq &lt;- data.frame(aa_3abrev, aa_quant2) # dataframe with results\ncolnames(aa_seq) &lt;- c(\"Type\", \"Quantity\") # rename columns\nknitr::kable(aa_seq, caption = \"Amino acid composition in human serum albumin\n(using loop).\", \"pipe\") # table\n\n\nAmino acid composition in human serum albumin (using loop).\n\n\nType\nQuantity\n\n\n\n\nAla\n63\n\n\nArg\n27\n\n\nAsn\n17\n\n\nAsp\n36\n\n\nCys\n35\n\n\nGlu\n62\n\n\nGln\n20\n\n\nGly\n13\n\n\nHis\n16\n\n\nIle\n9\n\n\nLeu\n64\n\n\nLys\n60\n\n\nMet\n7\n\n\nPhe\n35\n\n\nPro\n24\n\n\nSer\n28\n\n\nThr\n29\n\n\nTrp\n2\n\n\nTyr\n19\n\n\nVal\n43\nstr_count(seq, pattern = aa_1abrev)\n\n [1] 63 27 17 36 35 62 20 13 16  9 64 60  7 35 24 28 29  2 19 43\ny &lt;- c(1, 2, 4, 8, 16, 32)\nmean(y)\n\n[1] 10.5\n\nsum(y)\n\n[1] 63\n# Estimated average size of a protein from the number of\n# amino acid residues\nprot.size &lt;- function(x) {\nMM &lt;- x * 110 # 'x' represents the number of amino acids in the protein\nreturn(MM)\n}\nprot.size(575) # number of amino acid residues in human albumin\n\n[1] 63250\naa_ac &lt;- aa_seq[4, 2] + aa_seq[6, 2] # AA acids\naa_bas &lt;- aa_seq[2, 2] + aa_seq[9, 2] + aa_seq[12, 2] # AA basics\naa_arom &lt;- aa_seq[14, 2] + aa_seq[18, 2] + aa_seq[19, 2] # AA aromatics\naa_alif &lt;- aa_seq[10, 2] + aa_seq[11, 2] + aa_seq[15, 2] + aa_seq[1, 2] +\n aa_seq[20, 2] # Aliphatic AA\naa_pol &lt;- aa_seq[3, 2] + aa_seq[5, 2] + aa_seq[7, 2] + aa_seq[8, 2] +\naa_seq[13, 2] + aa_seq[16, 2] + aa_seq[17, 2] ## Neutral polar AA\naa_tot &lt;- str_count(seq, pattern = \"\") # length of the sequence\nclass_perc &lt;- round(c(aa_ac, aa_bas, aa_arom, aa_alif, aa_pol) / aa_tot * 100)\nAnd now, yes, we build the table.\naa_class &lt;- c(\"acidic\", \"basic\", \"aromatic\", \"aliphatic\", \"polar\")\naa_perc &lt;- data.frame(aa_class, class_perc) # dataframe with results\ncolnames(aa_perc) &lt;- c(\"Class\", \"%\") # rename columns\nknitr::kable(aa_perc, caption = \"Distribution of amino acid classes\nin human albumin.\", \"pipe\") # table\n\n\nDistribution of amino acid classes in human albumin.\n\n\nClass\n%\n\n\n\n\nacidic\n16\n\n\nbasic\n17\n\n\naromatic\n9\n\n\naliphatic\n33\n\n\npolar\n24",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Proteins</span>"
    ]
  },
  {
    "objectID": "proteinas_en.html#sec-Proteins",
    "href": "proteinas_en.html#sec-Proteins",
    "title": "5  Proteins",
    "section": "",
    "text": "Proteins are biopolymers formed by 20 amino acids. In this way, it is possible to easily evaluate the composition of any protein available in a database, such as the PDB seen in the Amino Acids chapter. Taking human serum albumin as an example, code AAA98797 from the National Center for Biotechnology Information, it is possible to count the 20 types of amino acids that make up its sequence. To do this, simply consider the FASTA sequence as a string and extract the quantity of each letter, using the stringr library, as follows.\nFirst, obtain the FASTA sequence of serum albumin.\n\nYou can see that there are empty spaces, which can be omitted for aesthetic reasons or not, since the stringr package will not count them, unlike more specific packages for biological sequences, such as seqinr seen previously. But if you want to omit these spaces, just run the code below.\n\n\n\nNote that the str_count command only counts the letter “A” in the sequence. This way, you can get all 20 amino acids by repeating this command.\n\n\n\n‘R’ has some commands for the aesthetic generation of tables, including those included in the ‘knitr’ package, as follows:\n\nNote that, despite the result obtained, there was some work to obtain the composition of the albumin, from the 20 modified lines for each amino acid. A more practical alternative is to consider a loop that performs the extraction of the desired information for a vector containing the abbreviation of a letter for each amino acid.\n\nThis way you get the same result, but with less memory consumption and higher processing speed, characteristics in any programming logic. Although the loop exemplifies automation, the str_count function retains an internal loop, since an element counting function is applied to a sequence, based on a predefined pattern (the vector aa_1abrev, in this case). This way, the script can be further simplified, without the need for the external loop.\n\nSeveral R functions exhibit this internal loop, which can be applied to vectors, lists, matrices and dataframes (datasheets). The simplest involve the application of a preprogrammed R function to a vector, for example:\n\nAnother common vectorization is the application of a user function to a vector, reducing the need for repeated commands, as in the example below:\n\nAnother form of vectorization involves the apply family of functions, consisting of the apply, sapply, tapply, lapply, and mapply commands. Although they have faster processing than external loop functions for using very complex matrices, each one is aimed at a distinct object or specific R situation (returning a list, vector or matrix), allows the use of subset (data subsets), uses R functions or functions previously defined by the user, and runs in just one command line. These advantages contrast with the use of for loops applied to vectors. However, vectorization works very well when you want to apply or map a function to a vector/matrix/list. When, on the other hand, you want to apply a function whose result depends on more than one vector/matrix/list, the for loop becomes indispensable, as in the titration of weak acids in the Amino Acids chapter.\nRegardless of the method used (and here it is worth highlighting the so-called good programming practices in the construction of scripts 1), it is possible to build a more general composition for the set of residues of the protein. Thus, we can obtain any quantitative relationship from the sequence, since we are treating it as a string. For example, a table containing the class of each amino acid that makes up the sequence.\n\nNow, instead of building a table with the count of these groups, let’s calculate their percentage, for a more general view of the sequence.\n\n\n\nIt can be seen from the table above that the distribution of amino acid residue classes in albumin is reasonably homogeneous, which contributes to its amphoteric function of transporting polar (e.g. calcium) and nonpolar (e.g. cholesterol, fatty acids) compounds.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Proteins</span>"
    ]
  },
  {
    "objectID": "proteinas_en.html#protein-purification-table-r-as-a-spreadsheet",
    "href": "proteinas_en.html#protein-purification-table-r-as-a-spreadsheet",
    "title": "5  Proteins",
    "section": "5.2 Protein Purification Table & R as a spreadsheet",
    "text": "5.2 Protein Purification Table & R as a spreadsheet\nDespite the ease with which we can create/edit conventional spreadsheets (spreadsheet; e.g. MS Excel, Libreoffice Calc, Gnumeric, etc.), ‘R’ also allows us to work with spreadsheets. Although less intuitive than those mentioned, scripting in R allows the creation/editing of highly complex spreadsheets, given the nature of the statistical programming of the suite.\nTo illustrate the construction of a simple spreadsheet, let us take as an example a Protein Purification Table, commonly used in Biotechnology and related areas. The simplest way to construct a spreadsheet involves 1) the individual preparation of vectors, and 2) the union of the vectors in a spreadsheet.\nThe procedures for protein purification (or isolation, fractionation) involve techniques such as chemical treatment (ammonium sulfate precipitation, acetone), acid treatment, thermal treatment, dialysis, chromatography (molecular filtration, ion exchange, affinity, reverse phase), among others. To measure the degree of purity of the sample obtained, simple electrophoresis, isoelectric focusing, 2D electrophoresis, use of monoclonal antibodies, and specific activity assays, among others, are normally used.\nFor the purification table, only the sample mass and sample enzymatic activity vectors obtained at each purification step are required. A simple spreadsheet could be constructed as:\n\n# Preparation of a simple enzyme purification spreadsheet\n# (each element of the vector represents a purification step)\n\n# 1. Definition of the main vectors:\nprot.total &lt;- c(6344, 302, 145, 34, 10, 3.8) # protein, mg\nativ.tot &lt;- c(200, 122, 106, 70, 53, 24) * 1000 # activity, U\n\n# 2. Construction of the spreadsheet:\npurif.plan &lt;- data.frame(prot.total, ativ.tot)\npurif.plan\n\n  prot.total ativ.tot\n1     6344.0   200000\n2      302.0   122000\n3      145.0   106000\n4       34.0    70000\n5       10.0    53000\n6        3.8    24000\n\n\nThe spreadsheet now forms an R dataset. There are other simple ways to create a dataset, such as using the ‘cbind’ function (to join columns) or ‘rbind’ (to join rows):\n\npurif.plan2 &lt;- cbind(prot.total, ativ.tot)\npurif.plan2\n\n     prot.total ativ.tot\n[1,]     6344.0   200000\n[2,]      302.0   122000\n[3,]      145.0   106000\n[4,]       34.0    70000\n[5,]       10.0    53000\n[6,]        3.8    24000\n\n\nRegardless of the procedure, you can change the column names, as follows:\n\n# Editing column names\ncolnames(purif.plan2) &lt;- c(\"totalProt\", \"enzAtiv\")\npurif.plan2\n\n     totalProt enzAtiv\n[1,]    6344.0  200000\n[2,]     302.0  122000\n[3,]     145.0  106000\n[4,]      34.0   70000\n[5,]      10.0   53000\n[6,]       3.8   24000\n\n\nAs in a conventional spreadsheet, it is also possible to create new vectors calculated from the initial ones:\n\npurif.plan3 &lt;- data.frame(prot.total, ativ.tot, ativ.tot / prot.total)\noptions(digits = 1) # option for no. of decimal places\ncolnames(purif.plan3) &lt;- c(\"prot.total\", \"ativ.tot\", \"ativ.specif\")\nrownames(purif.plan3) &lt;- c(\"extr.bruto\", \"NH4SO2\", \"acetone\",\n\"Sephadex G-100\", \"DEAE-cellulose\", \"C8-phase rev\")\npurif.plan3\n\n               prot.total ativ.tot ativ.specif\nextr.bruto           6344    2e+05          32\nNH4SO2                302    1e+05         404\nacetone               145    1e+05         731\nSephadex G-100         34    7e+04        2059\nDEAE-cellulose         10    5e+04        5300\nC8-phase rev            4    2e+04        6316\n\n\nThe spreadsheet can also be edited in its values, simply by assigning a new name so that the changes are saved:\n\n# Simple spreadsheet editing (changes in values ​​and column names)\n\npurif.plan4 &lt;- edit(purif.plan3) # or data.entry( )\n\nOf course, you can also import data from a spreadsheet already created in another program. Example for a spreadsheet saved as CSV:\n\n# Importing data from another spreadsheet (CSV):\n\n# 1. Import with the name of the desired spreadsheet:\npurif.plan5 &lt;- read.table(\"planilha.csv\", header = T, sep = \",\")\n\n# 2. Import with the search screen for the desired spreadsheet:\npurif.plan5 &lt;- frame &lt;- read.csv(file.choose())\n\nA large number of operations can be performed on spreadsheets in ‘R’, such as insertion, deletion, modification, aggregation (merge), filtering, subset extraction, mathematical operations and statistical calculations (mean, standard deviation, etc.). You can also convert the spreadsheet into a more visual table using the ‘tibble’ library, part of a set of packages used in data science called Tidyverse:\n\nlibrary(tibble)\npurif.plan6 &lt;- as_tibble(purif.plan3)\npurif.plan6\n\n# A tibble: 6 × 3\n  prot.total ativ.tot ativ.specif\n       &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;\n1     6344     200000        31.5\n2      302     122000       404. \n3      145     106000       731. \n4       34      70000      2059. \n5       10      53000      5300  \n6        3.8    24000      6316. \n\n\nThe Tidyverse comprises an ecosystem of ‘R’ packages that share the same philosophy, grammar and data structure. These packages include ‘tibble’ (tables), ‘ggplot2’ (high-quality visual graphics), and ‘dplyr’ (data manipulation). As for ‘dplyr’, it is quite flexible to create and edit spreadsheets, which are converted to tables, as follows for the purification example above:\n\n# Enzyme purification table with 'dplyr' package:\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\npurif.plan7 &lt;- mutate(purif.plan, ativ.esp = ativ.tot / prot.total)\npurif.plan7\n\n  prot.total ativ.tot ativ.esp\n1       6344    2e+05       32\n2        302    1e+05      404\n3        145    1e+05      731\n4         34    7e+04     2059\n5         10    5e+04     5300\n6          4    2e+04     6316\n\n\nNote that with the ‘dplyr’ package, inserting a new column did not require a new array for column names (‘colnames’). In addition, the final spreadsheet was created using the grammar of the ‘tibble’ package from the Tidyverse. This facility also extends to the spreadsheet editing and filtering processes, such as the extraction of a modified column:\n\nativ.tot.kU &lt;- transmute(purif.plan7, ativ.tot = ativ.tot / 1e3)\nativ.tot.kU # specific activity vector in U x 10^3\n\n  ativ.tot\n1      200\n2      122\n3      106\n4       70\n5       53\n6       24\n\n\nThis way you can build a complete purification table, listing, in addition to the specific activity, the purification level (how many times the specific activity increased in relation to the initial sample) and the yield obtained (how many times the target enzyme content decreased in relation to the initial sample - remaining activity):\n\npurif.plan8 &lt;- mutate(purif.plan7,\npurif = ativ.esp / ativ.esp[1], # purification level\nrend.perc = 100 * ativ.tot / ativ.tot[1]\n) # percentage yield\n\n# Converting to the table...\nlibrary(knitr)\nknitr::kable(purif.plan8, caption = \"Purification table for an enzyme\", \"pipe\")\n\n\nPurification table for an enzyme\n\n\nprot.total\nativ.tot\nativ.esp\npurif\nrend.perc\n\n\n\n\n6344\n2e+05\n32\n1\n100\n\n\n302\n1e+05\n404\n13\n61\n\n\n145\n1e+05\n731\n23\n53\n\n\n34\n7e+04\n2059\n65\n35\n\n\n10\n5e+04\n5300\n168\n26\n\n\n4\n2e+04\n6316\n200\n12\n\n\n\n\n\nAdditionally, ‘R’ has some packages that speed up the creation/editing of spreadsheets in an interactive way, closer to a conventional spreadsheet, among which the ‘DT’ package stands out, a library written in JavaScript that produces an editable spreadsheet in HTML:\n\nlibrary(DT)\npurif.plan9 &lt;- as.data.frame(purif.plan8)\nrownames(purif.plan9) &lt;- c(\"extr.bruto\", \"NH4SO2\", \"acetone\",\n\"Sephadex G-100\", \"DEAE-cellulose\",\n\"C8-phase rev\") # converts the purification table\n# into a spreadsheet for use by the DT package\ndatatable(purif.plan9) %&gt;% formatRound(1:5, 1) # columns with 1 decimal place\n\nSince this is an interactive HTML output, the result of the code snippet must be omitted for correct compilation by ‘R’ (eval=FALSE, include=TRUE).\nThe ‘DT’ library allows, among other things, reordering, filtering, and even editing of values, interactively (just click on the desired cell):\n\nDT::datatable(purif.plan9, editable = \"cell\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Proteins</span>"
    ]
  },
  {
    "objectID": "proteinas_en.html#interaction-of-oxygen-with-myoglobin-and-hemoglobin",
    "href": "proteinas_en.html#interaction-of-oxygen-with-myoglobin-and-hemoglobin",
    "title": "5  Proteins",
    "section": "5.3 Interaction of oxygen with myoglobin and hemoglobin",
    "text": "5.3 Interaction of oxygen with myoglobin and hemoglobin\nBoth human myoglobin (PD 1MBO) and hemoglobin (PDB 6BB5) are proteins that transport molecular oxygen. Hemoglobin, with a quaternary structure, transports it from the lungs to the tissues, while myoglobin, tertiary, distributes it between them. Its oxygen saturation curves are well known in textbooks, and learning about them can add value when simulated.\nThus, the binding of O\\(_{2}\\) to myoglobin can be considered as a saturation fraction y given as a function of its half-saturation at 50% O\\(_{2}\\) pressure (dissociation constant \\(K_{50}\\) of 2.8 mmHg).\n\\[\ny=\\frac{pO_2}{K_{50}+pO_2}\n\\tag{5.1}\\]\nOn the other hand, the value of \\(K_{50}\\) for hemoglobin is 26 mmHg, but its function is expressed differently from that of myoglobin:\n\\[\ny=\\frac{pO_2^{nH}} {K_{50}^{nH}+pO_2^{nH}}\n\\tag{5.2}\\]\nIn this Equação 5.2, nH represents the Hill cooperativity coefficient, which summarizes the energy distributed among the four microscopic dissociation constants of O\\(_{2}\\) to the four porphyrin centers of hemoglobin (heme groups). Simulating both curves:\n\nK50 &lt;- 2.8\ncurve(x / (K50 + x),\nxlim = c(0, 100),\nxlab = \"pO2 (mmHg)\", ylab = \"y\", lty = \"dotted\"\n)\n\nK50 &lt;- 26\nnH &lt;- 2.8\ncurve(x^nH / (K50^nH + x^nH),\nxlim = c(0, 100),\nxlab = \"pO2 (mmHg)\", ylab = \"y\", col = \"red\",\nadd = TRUE\n) # \"add\" allows you to add curves to the graph\nabline(0.5, 0, lty = 2) # add baseline at half saturation\n\n\n\n\nOxygen saturation isotherm for myoglobin (solid line) and hemoglobin (dotted line), indicating the intercept at 50% pO2 (half saturation).\n\n\n\n\nAs mentioned in the previous paragraph, the four binding centers with molecular oxygen are related to four microscopic dissociation equilibrium constants, from K1 to K4. Simplifying the value of pO\\(_{2}\\) to L, ligand, it is also possible to represent the binding of O\\(_{2}\\) to hemoglobin by the Adair equation (Pauling 1935):\n\\[\ny=\\frac{K1*L+2*K2*K1*L^2+3*K3*K2*K1*L^3+4*K4*K3*K2*K1*L^4} {4*(1+K1*L+2*K2*K1*L^2+3*K3*K2*K1*L^3+4*K4*K3*K2*K1*L^4)}\n\\tag{5.3}\\]\nIt turns out that there is a statistical effect associated with the interaction under study, since O\\(_{2}\\) has 4 initial sites of interaction with hemoglobin (Tyuma, Imai, e Shimizu 1973), values ​​that reduce until the saturation of the 4 sites. Thus, it is necessary to account for the microscopic constants Ki due to this statistical compromise:\n\\[\nKi_{corr} = \\frac{i}{N-1+i}*Ki\n\\tag{5.4}\\]\nIn R, this can be aided by a for loop:\n\nK &lt;- c(0.011, 0.016, 0.118, 0.400) # vector of microscopic constants for\n# dissociation of Hb to O2\nL &lt;- seq(1, 201, 2) # vector of O2 contents\n\nKcorr &lt;- c() # initialize an empty vector to output the corrected Ki vector\nN &lt;- 4 # declare the number of sites in Hb\nfor (i in 1:N) Kcorr[i] &lt;- i / (N - i + 1) * K[i]\nKcorr # returns the vector of Ki values corrected for the statistical effect\n\n[1] 0.003 0.011 0.177 1.600\n\n\nNote that the corrected Ki values are in a proportion that follows the availability of sites, from 4 times lower for the 1st site (highest binding), up to 4 times greater than for the 4th site (lowest binding). It is now possible to apply Equação 5.3 using the constants calculated as follows:\n\nnumer &lt;- K[1] * L + 2 * K[2] * K[1] * L^2 + 3 * K[3] * K[2] * K[1] * L^3 +\n4 * K[4] * K[3] * K[2] * K[1] * L^4\ndenom &lt;- 1 + numer\ny &lt;- numer / denom\nplot(L, y, xlab = \"pO2\", type = \"l\", col = 2)\n\n\n\n\nHemoglobin oxygen saturation isotherm by the Adair equation.\n\n\n\n\nFinally, it is also possible to obtain the binding curve using a variation of for loop in which the Equação 5.3 is produced by iteration, as follows (Bloomfield 2009):\n\n# Calculation of y in each L\nYi &lt;- function(L, Kcorr) {\nN &lt;- length(Kcorr)\nconc &lt;- c()\nconc[1] &lt;- L * Kcorr[1]\nfor (i in 2:N) conc[i] &lt;- conc[i - 1] * L * Kcorr[i]\nnumer2 &lt;- sum((1:N) * conc) / N\ndenom2 &lt;- 1 + sum(conc)\nreturn(numer2 / denom2)\n}\n# Calculation of y to vector L\nY &lt;- function(L, Kcorr) {\nYY &lt;- c()\nfor (j in 1:length(L)) YY[j] &lt;- Yi(L[j], Kcorr)\nreturn(YY)\n}\n# Application of the function of y to L and graph\nYfinal &lt;- Y(L, Kcorr)\nplot(L, Yfinal, type = \"l\", col = 2, xlab = \"pO2\", ylab = \"y\")\n\n\n\n\nHemoglobin oxygen saturation curve obtained by iteration of the Adair equation, as corrected for statistical effect.\n\n\n\n\nNote that there are minimal differences between the curves obtained by the different procedures, due to the different algorithms used.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Proteins</span>"
    ]
  },
  {
    "objectID": "proteinas_en.html#some-r-packages-for-studying-proteins",
    "href": "proteinas_en.html#some-r-packages-for-studying-proteins",
    "title": "5  Proteins",
    "section": "5.4 Some R packages for studying proteins",
    "text": "5.4 Some R packages for studying proteins\nSome R packages are quite useful in studying proteins, especially the seqinr library seen in the Amino Acids chapter, which computes various values ​​and information for protein sequences, such as pI, hydroxypathy index, residue distribution, among others. The project website [^seqinrSitio-1] contains detailed information for its use. Using the same procedure to obtain the FASTA sequence for lysozyme from the Amino Acids chapter (code CAA32175 on the NCBI site), one can obtain an extensive set of protein information, as exemplified below:\n\nlibrary(seqinr)\n\n\nAttaching package: 'seqinr'\n\n\nThe following object is masked from 'package:dplyr':\n\n    count\n\nlysozyme &lt;- c(\"KVFERCELARTLKRLGMDGYRGISLANWMCLAKWESGYNTRATNYNAGDRSTDYGIFQ\nINSRYWCNDGKTPGAVNACHLSCSALLQDNIADAVACAKRVVRDPQGIRAWVAWRNRCQNRDVRQYVQGCGV\")\nseq_liso &lt;- s2c(lysozyme) # convert amino acid string sequence to\n# the seqinr pattern (character vector)\nseq_liso2 &lt;- seq_liso[seq_liso != \"\\n\"] # elimination of spaces required by\n# seqinr from copy/paste procedure.\nseq_liso2\n\n  [1] \"K\" \"V\" \"F\" \"E\" \"R\" \"C\" \"E\" \"L\" \"A\" \"R\" \"T\" \"L\" \"K\" \"R\" \"L\" \"G\" \"M\" \"D\"\n [19] \"G\" \"Y\" \"R\" \"G\" \"I\" \"S\" \"L\" \"A\" \"N\" \"W\" \"M\" \"C\" \"L\" \"A\" \"K\" \"W\" \"E\" \"S\"\n [37] \"G\" \"Y\" \"N\" \"T\" \"R\" \"A\" \"T\" \"N\" \"Y\" \"N\" \"A\" \"G\" \"D\" \"R\" \"S\" \"T\" \"D\" \"Y\"\n [55] \"G\" \"I\" \"F\" \"Q\" \"I\" \"N\" \"S\" \"R\" \"Y\" \"W\" \"C\" \"N\" \"D\" \"G\" \"K\" \"T\" \"P\" \"G\"\n [73] \"A\" \"V\" \"N\" \"A\" \"C\" \"H\" \"L\" \"S\" \"C\" \"S\" \"A\" \"L\" \"L\" \"Q\" \"D\" \"N\" \"I\" \"A\"\n [91] \"D\" \"A\" \"V\" \"A\" \"C\" \"A\" \"K\" \"R\" \"V\" \"V\" \"R\" \"D\" \"P\" \"Q\" \"G\" \"I\" \"R\" \"A\"\n[109] \"W\" \"V\" \"A\" \"W\" \"R\" \"N\" \"R\" \"C\" \"Q\" \"N\" \"R\" \"D\" \"V\" \"R\" \"Q\" \"Y\" \"V\" \"Q\"\n[127] \"G\" \"C\" \"G\" \"V\"\n\npmw(seq_liso2) # molecular weight of the protein\n\n[1] 14701\n\naaa(seq_liso2) # residue distribution\n\n  [1] \"Lys\" \"Val\" \"Phe\" \"Glu\" \"Arg\" \"Cys\" \"Glu\" \"Leu\" \"Ala\" \"Arg\" \"Thr\" \"Leu\"\n [13] \"Lys\" \"Arg\" \"Leu\" \"Gly\" \"Met\" \"Asp\" \"Gly\" \"Tyr\" \"Arg\" \"Gly\" \"Ile\" \"Ser\"\n [25] \"Leu\" \"Ala\" \"Asn\" \"Trp\" \"Met\" \"Cys\" \"Leu\" \"Ala\" \"Lys\" \"Trp\" \"Glu\" \"Ser\"\n [37] \"Gly\" \"Tyr\" \"Asn\" \"Thr\" \"Arg\" \"Ala\" \"Thr\" \"Asn\" \"Tyr\" \"Asn\" \"Ala\" \"Gly\"\n [49] \"Asp\" \"Arg\" \"Ser\" \"Thr\" \"Asp\" \"Tyr\" \"Gly\" \"Ile\" \"Phe\" \"Gln\" \"Ile\" \"Asn\"\n [61] \"Ser\" \"Arg\" \"Tyr\" \"Trp\" \"Cys\" \"Asn\" \"Asp\" \"Gly\" \"Lys\" \"Thr\" \"Pro\" \"Gly\"\n [73] \"Ala\" \"Val\" \"Asn\" \"Ala\" \"Cys\" \"His\" \"Leu\" \"Ser\" \"Cys\" \"Ser\" \"Ala\" \"Leu\"\n [85] \"Leu\" \"Gln\" \"Asp\" \"Asn\" \"Ile\" \"Ala\" \"Asp\" \"Ala\" \"Val\" \"Ala\" \"Cys\" \"Ala\"\n [97] \"Lys\" \"Arg\" \"Val\" \"Val\" \"Arg\" \"Asp\" \"Pro\" \"Gln\" \"Gly\" \"Ile\" \"Arg\" \"Ala\"\n[109] \"Trp\" \"Val\" \"Ala\" \"Trp\" \"Arg\" \"Asn\" \"Arg\" \"Cys\" \"Gln\" \"Asn\" \"Arg\" \"Asp\"\n[121] \"Val\" \"Arg\" \"Gln\" \"Tyr\" \"Val\" \"Gln\" \"Gly\" \"Cys\" \"Gly\" \"Val\"\n\nAAstat(seq_liso2, plot = TRUE) # distribution graph, composition\n\n\n\n\n\n\n\n\n$Compo\n\n *  A  C  D  E  F  G  H  I  K  L  M  N  P  Q  R  S  T  V  W  Y \n 0 14  8  8  3  2 11  1  5  5  8  2 10  2  6 14  6  5  9  5  6 \n\n$Prop\n$Prop$Tiny\n[1] 0.3\n\n$Prop$Small\n[1] 0.6\n\n$Prop$Aliphatic\n[1] 0.2\n\n$Prop$Aromatic\n[1] 0.1\n\n$Prop$Non.polar\n[1] 0.6\n\n$Prop$Polar\n[1] 0.4\n\n$Prop$Charged\n[1] 0.2\n\n$Prop$Basic\n[1] 0.2\n\n$Prop$Acidic\n[1] 0.08\n\n\n$Pi\n[1] 9\n\n# and proportion of residues, pI value\n\nOther functions of seqinr include conversion of amino acids to 1- and 3-letter abbreviations (a and aaa, respectively), listing of 544 physicochemical properties of the 20 protein amino acids (aaindex), pK (self-explanatory, and seen previously), and isolated computation of pI (computePI) and molecular mass (pmw), in addition to several others, both for proteomics and genomics.\nAnother interesting R package for studying proteins is Peptides 2, which also computes several physicochemical properties for amino acid sequences, in addition to enabling plotting integration with the GROMACS molecular dynamics package. As for seqinr, Peptides requires conversion of the sequence into string for the recognized vector pattern. The package’s functions include the computation of 66 descriptors for each amino acid in a sequence (aaDescriptors), the composition of the sequence by residue classification (aaComp), the computation of the aliphatic index (aIndex), the hydrophobicity index (hydrophobicity), the instability index (instalIndex), the mass/charge ratio (mz), molecular mass (mw), and pI (pI), among others.\nAmong the packages more focused on comparative studies and visualization of structures, as well as for bioinformatics and chemogenomics descriptors, it is worth mentioning Bio3d, Autoplotprotein, protr, BioMedR, and UniprotR, among many others.\n\n\n\n\nBloomfield, Victor. 2009. Computer simulation and data analysis in molecular biology and biophysics: an introduction using R. Springer Science & Business Media.\n\n\nPauling, Linus. 1935. «The oxygen equilibrium of hemoglobin and its structural interpretation». Proceedings of the National Academy of Sciences of the United States of America 21 (4): 186.\n\n\nTyuma, Itiro, Kiyohiro Imai, e Katsuhiko Shimizu. 1973. «Analysis of oxygen equilibrium of hemoglobin and control mechanism of organic phosphates». Biochemistry 12 (8): 1491–98.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Proteins</span>"
    ]
  },
  {
    "objectID": "proteinas_en.html#footnotes",
    "href": "proteinas_en.html#footnotes",
    "title": "5  Proteins",
    "section": "",
    "text": "Some programming practices (Best Codes): 1) organize a project into folders (e.g.: data, figures, scripts) or create an R package as an option; 2) create sections in a code to make it easier to find; 3) name the code chunks (pieces of code); 4) place the libraries used, sources, and data calls at the beginning of the code (avoids searching for something necessary for the script to run throughout the code); 5) indent, preferably with 1 or 2 commands per line; 6) always use function parameters inside the function; 7) avoid global parameters; 8) do not use ‘attach’; 8) use parameters with intuitive names (and not x and y; e.g.: function_name); 9) assign names to objects with one of the three naming conventions (e.g.: KiCompet, ki_compet, ki.compet).↩︎\nPeptides package: https://cran.r-project.org/web/packages/Peptides/index.html↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Proteins</span>"
    ]
  },
  {
    "objectID": "enzimas_en.html",
    "href": "enzimas_en.html",
    "title": "6  Enzymes",
    "section": "",
    "text": "6.1 Enzyme Kinetics\n\\[\nE+S \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{k2} \\end{array} ES\n\\begin{array}{c}\n_{k3}\\\\\n\\rightarrow \\\\\n^{}\\end{array}E+P\n\\tag{6.1}\\]\nWhere P represents the product of the reaction, ES the activated complex in the transition state, and k1, k2 and k3 the reaction rate constants.\n\\[\nv=\\frac{Vm*S}{Km+S}\n\\tag{6.2}\\]\nWhere Km represents the Michaelis-Menten constant, and Vm the limiting rate of the reaction (sometimes erroneously called maximum rate, although the quadratic hyperbola described by the function does not exhibit a maximum value because it does not reach an asymptote). In turn, Km can be defined from the rate constants of Equação 6.1 as:\n\\[\nKm=\\frac{k1+k3}{k2}\n\\tag{6.3}\\]\n# Michaelis-Menten kinetic curve\n\nVm &lt;- 10\nKm &lt;- 0.5\ncurve(Vm * x / (Km + x),\nxlim = c(0, 10),\nxlab = \"[S]\", ylab = \"v\"\n)\nabline(h = 5, lty = 2, col = \"blue\")\nabline(v = 0.5, lty = 2, col = \"blue\")\ntext(x = 1, y = 0.2, \"Km\", col = \"blue\")\ntext(1, 5.3, \"Vm/2\", col = \"blue\")\n\n\n\n\n\n\n\nFigura 6.1: Michaelis-Menten curve for an enzyme exhibiting Vm=10 and Km=0.5 (50 curves).\nVm &lt;- 10\nKm &lt;- seq(from = 0.1, to = 10, by = 0.2) # sequence for 50 values ​​of Km\nfor (i in 1:length(Km)) { # loop to add Michaelis-Menten curve\n#for each value of Km\nadd &lt;- if (i == 1) FALSE else TRUE # flow control that allows addition\n#of curve from the second iteration (i.e. when i &gt; 1)\ncurve(Vm * x / (Km[i] + x),\ncol = i, lwd = 0.8, from = 0, to = 10, n = 100,\nxlab = \"[S}\", ylab = \"v\", add = add\n)\n}\narrows(0.5, 9, 3, 6, length = 0.1, angle = 45, col = \"blue\") # arrow for Km\ntext(0.2, 9, \"Km\", col = \"blue\") # indexer for Km\n\n\n\n\n\n\n\nFigura 6.2: Michaelis-Menten curves with iterative variation for Km from 0.1 to 10.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Enzymes</span>"
    ]
  },
  {
    "objectID": "enzimas_en.html#sec-Enzyme",
    "href": "enzimas_en.html#sec-Enzyme",
    "title": "6  Enzymes",
    "section": "",
    "text": "In general, enzymes are studied from different points of view, such as their structure, mechanism of action, and kinetic behavior. This chapter aims to work on the latter, with the help of R.\nIn general, the simplified equation that describes the activity of an enzyme E on a substrate S can be written as:\n\n\nUsing the Briggs-Haldane approximation for steady state, and the Henri-Michaelis-Menten treatment, the equation that defines the rate curve of the enzymatic reaction as a function of the substrate content can be described below:\n\n\n\nTherefore, given the values ​​of Vm and Km, we can describe a Michaelis-Menten behavior for an enzyme as:\n\nBy this relationship, the value of Km is represented by the substrate content that gives half the value of Vm to the reaction. Note that by Equação 6.2 the value of Km in the denominator inversely influences the speed v of the reaction; that is, the higher the value of Km, the lower the rate of the enzymatic reaction. This can be illustrated iteratively with a loop, as follows:\n\nThe curves represented in figures Figura 6.1 and Figura 6.2) were produced with Equação 6.2, and it is possible to extract the kinetic parameters Vm and Km easily, since there are no computed deviations for the initial velocity of the reaction. If, on the other hand, we are faced with experimental values ​​of a catalysis with Michaelinan behavior and we wish to extract the kinetic parameters, it would be better to fit the nonlinear Michaelis-Menten equation directly (algorithms such as Gauss-Newton, Simplex, Levenberg-Marquadt) or, more simply, transform the variables S and v in such a way that they allow a linear fit by least squares.\nHowever, the function that describes the Michaelis-Menten equation constitutes a quadratic hyperbola and, as such, does not have a mathematical asymptote, only a visual one. In fact, the authors of the original work, Leonor Michaelis and Maud Mentem, reported their data with the representation of S on the logarithmic axis, allowing better visualization of the asymptotic region of the graph (Michaelis e Menten 1913).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Enzymes</span>"
    ]
  },
  {
    "objectID": "enzimas_en.html#obtaining-kinetic-parameters-from-simulated-experimental-data",
    "href": "enzimas_en.html#obtaining-kinetic-parameters-from-simulated-experimental-data",
    "title": "6  Enzymes",
    "section": "6.2 Obtaining kinetic parameters from simulated experimental data",
    "text": "6.2 Obtaining kinetic parameters from simulated experimental data\nTo determine the kinetic parameters Vm and Km obtained from an experimental simulation of S and v data, it is first necessary to obtain the experimental points, as follows:\n\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500) # sets the seed for generating reproducible random data\nerror &lt;- runif(20, 0, 1) # command for uniform error (no. of points, min, max)\ncurve(Vm * x / (Km + x) + error,\ntype = \"p\", from = 0, to = 1, n = 20,\nxlab = \"[S}\", ylab = \"v\"\n) # curve creation with uniform error computation\n\n\n\n\n\n\n\nFigura 6.3: Simulation of experimental points (n=20) obtained from the Michaelis-Menten equation.\n\n\n\n\n\nNote that by Figura 6.3, it is no longer possible to define an asymptotic region that allows the determination of Vm and, consequently, of Km. In this case, the kinetic parameters can be obtained by transforming the Michaelis-Mentem hyperbolic function into a correlated linear function, followed by linear adjustment of the transformed data to obtain the catalysis parameters.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Enzymes</span>"
    ]
  },
  {
    "objectID": "enzimas_en.html#linearizations-and-adjustments",
    "href": "enzimas_en.html#linearizations-and-adjustments",
    "title": "6  Enzymes",
    "section": "6.3 Linearizations and adjustments",
    "text": "6.3 Linearizations and adjustments\nThere are several linearizations found in the literature for the Michaelis-Mentem equation. To illustrate them, below is a code excerpt containing the four most commonly used. For this purpose, a pair of R functions were used to, respectively, establish the graphic area and its subdivision for plotting in 4 panels (par and mfrow or mfcol):\n\nS &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) # creates a vector for substrate\nKm &lt;- 0.5\nVm &lt;- 10 # establishes the enzymatic parameters\nv &lt;- Vm * S / (Km + S) # applies the MM equation to the S vector\npar(mfrow = c(2, 2)) # establishes plot area for 4 graphs\nplot(S, v, type = \"o\", main = \"Michaelis-Mentem\")\nplot(1 / S, 1 / v, type = \"o\", main = \"Lineweaver-Burk\")\nplot(v, v / S, type = \"o\", main = \"Eadie-Hofstee\")\nplot(S, S / v, type = \"o\", main = \"Hanes-Woolf\")\nlayout(1) # return to normal graphics window\n\n\n\n\n\n\n\nFigura 6.4: Main linearizations of the Michaelis-Menten equation.\n\n\n\n\n\nAmong these linear transformations for enzyme kinetics, the most frequently found are Lineweaver-Burk (or double-reciprocal), and Eadie-Hofstee, the first being the most common in the literature. However, the application of the Eadie-Hofstee formalism for ligand-protein interactions is also the most reported in this area, although it is treated as a Scatchard representation (Scatchard 1949).\n\n6.3.1 Linearization by Lineweaver-Burk transformation\nThe linear form for the Lineweaver-Burk equation is obtained from the transformation of the Michaelis-Menten equation as follows:\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km}{Vm}*\\frac{1}{S}\n\\tag{6.4}\\]\nIn this way, the data obtained by Figura 6.3 are transformed to their double reciprocal, resulting in:\n\nS &lt;- seq(0.1, 1, length.out = 20) # generate a sequence with 20 points between\n# 0 and 1 for substrate values\nVm &lt;- 10\nKm &lt;- 0.5 # kinetic parameters\nset.seed(1500) # establish the same random seed as the direct\n# Michaelis-Menten plot, for reproducibility of points\nerror &lt;- runif(20, 0, 1) # command for uniform error (no. of points, min, max)\nv &lt;- Vm * S / (Km + S) + error # Michaelis-Menten equation\n\ninv.S &lt;- 1 / S # create variables for the double reciprocal\ninv.v &lt;- 1 / v\nplot(inv.v ~ inv.S, xlab = \"1/S\", ylab = \"1/v\") # plot the\n# Lineweaver-Burk plot\n\n\n\n\n\n\n\nFigura 6.5: Lineweaver-Burk representation for the simulated data of the Michaelis-Menten curve.\n\n\n\n\n\nNote that Figura 6.5 now presents a distribution of values ​​that allows its linear fit by least squares (linear regression). In R, this can be easily done by the following code snippet (chunk):\n\nreg.LB &lt;- lm(inv.v ~ inv.S) # expression for linear fit\nsummary(reg.LB) # results of the fit\n\n\nCall:\nlm(formula = inv.v ~ inv.S)\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-0.028198 -0.009858 -0.003496  0.007482  0.028416 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 0.113634   0.005147   22.08 1.74e-14 ***\ninv.S       0.032772   0.001461   22.42 1.33e-14 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.01459 on 18 degrees of freedom\nMultiple R-squared:  0.9654,    Adjusted R-squared:  0.9635 \nF-statistic: 502.8 on 1 and 18 DF,  p-value: 1.325e-14\n\nplot(inv.v ~ inv.S, xlab = \"1/S\", ylab = \"1/v\") # Lineweaver-Burk plot\nabline(reg.LB, col = \"blue\") # overlay of the fit on the plot\n\n\n\n\n\n\n\nFigura 6.6: Linear fit for Lineweaver-Burk data.\n\n\n\n\n\nThe table produced by R for the lm function of linear least squares fit has several pieces of information that allow us to evaluate the quality of the regression. Briefly, this table provides us with the value of each parameter of the adjustment according to the following equation:\n\\[\ny = a + b *x\n\\tag{6.5}\\]\nIn this case, a refers to the intercept in the table ((intercept), or 1/Vm) and b to the slope (inv.S, or Km/Vm). In addition, the table also provides several complementary results, listed below:\n\nstandard error value of the parameters (Std. Error);\nvalue of the Student’s t distribution (t value);\nthe respective probability level (Pr) with indication of significance (asterisks);\nresidual standard error (Residual standard error);\nvalue of the gross coefficients of determination (Multiple R-squared) and adjusted for the degrees of freedom (Adjusted R-squared);\nvalue of the Snedocor F distribution (F-statistic) of the variance of the adjustment;\ndegrees of freedom (DF) and the significance value of the regression to the linear model obtained by the analysis of variance (p-value).\n\nNevertheless, the quality of the linear adjustment can also be verified by producing statistical diagnostic graphs, simply by applying the simple excerpt below:\n\nplot(reg.LB) # command to generate diagnostic graphs of linear adjustment\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThese diagnostic graphs can also be allocated to panels, as illustrated for the Michaelis-Mentem linearizations above.\n{r, echo =TRUE, label=\"fig-figLinDiag\", fig.cap=\"Graph the linear adjustment diagnostics.\"} reg.LB &lt;- lm(inv.v ~ inv.S) par(mfrow = c(2, 2)) plot(reg.LB) layout(1)\nThe four graphs generated above refer, respectively, to 1) the variation of residuals with the adjusted values, 2) a test of normal distribution of residuals, 3) the variation of standardized residuals as a function of the adjusted values, and 4) the observation of influenceable values ​​identifiable by the Cook’s distance for each observation. Regarding the latter, one can optionally define its appearance to identify those values ​​by selection (which, 4 or 6, for example), as in:\n\nplot(reg.LB, which = 4)\n\n\n\n\n\n\n\n\nThrough these two procedures, table and diagnostic graphs, it is possible to assess the quality of a linear adjustment by R. In parallel, there are several associated functions to the lm function itself for linear models (objects), which reinforces the object-oriented language character of R. Among these, it is worth mentioning, with intuitive meaning, coef, fitted, predict, residuals, confint, and deviance.\nTo access the parameters contained in the lm function, as well as others of the same nature in R, simply type args:\n\nargs(lm)\n\nfunction (formula, data, subset, weights, na.action, method = \"qr\", \n    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n    contrasts = NULL, offset, ...) \nNULL\n\n\nIn addition, it is worth mentioning the existence of numerous R packages for various situations and statistical treatments of data for linear models, and which are beyond the scope of this manuscript, such as those that allow analysis of outliers (extreme values), Generalized Linear Models, Mixed Effects Models, Non-parametric Regression, among others. Among the R packages that are complementary to linear regression, it is worth mentioning car, MASS, caret, glmnet, sgd, BLR, and Lars.\n\n6.3.1.1 Considerations on Lineweaver-Burk linearization.\nReturning to the study of steady-state kinetics of enzymatic catalysis, we mentioned above the possibility of linearizing the Michaelis-Menten equation by two of the most common treatments, Lineweaver-Burk and Eadie-Hofstee. In general, any treatment that results in the transformation of an original model (Michaelis-Menten equation, in this case) by linearization will result in statistical deviations.\nAnalyzing the Lineweaver-Burk equation, for example, it can be seen that, since the values ​​of S and v are represented by their reciprocals, a small variation in v will result in a large variation in 1/v. On the other hand, the choice of the S content range is also extremely important for the extraction of kinetic parameters. This can be illustrated in the following example:\n\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500) # fixed seed for random error\nerror &lt;- runif(length(S), 0, 0.1)\nS &lt;- seq(1, 10, 0.1)\nv &lt;- Vm * S / (Km + S) + error\n\nWarning in Vm * S/(Km + S) + error: longer object length is not a multiple of\nshorter object length\n\nplot(v ~ S, xlab = \"S\", ylab = \"v\")\n\n\n\n\n\n\n\nFigura 6.7: Michaelis-Mentem curve simulated with random experimental error. Vm=10; Km=0.5.\n\n\n\n\n\nNote that Figura 6.7 starts at a speed close to zero, and ends at a speed close to Vm, with a content of S &gt;&gt; Km (50 times, in fact). This condition allows a safe extraction of the kinetic parameters, which can be obtained from the linear fit of the double-reciprocal plot.\n\n# Chunk for Lineweaver-Burk\nset.seed(1500) # fixed seed for random error\nerror &lt;- runif(length(S), 0, 0.2)\nVm &lt;- 10\nKm &lt;- 0.5 # kinetic parameters\ninv.S &lt;- 1 / seq(1, 10, 0.1) # 1/S\ninv.v &lt;- 1 / (Vm * S / (Km + S) + error) # 1/v\nplot(inv.S, inv.v)\nlm.LB2 &lt;- lm(inv.v ~ inv.S) # linear fit\nsummary(lm.LB2) # fit results\n\n\nCall:\nlm(formula = inv.v ~ inv.S)\n\nResiduals:\n       Min         1Q     Median         3Q        Max \n-0.0015050 -0.0005613 -0.0001463  0.0007522  0.0014122 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 0.0991811  0.0001356   731.3   &lt;2e-16 ***\ninv.S       0.0481555  0.0004193   114.9   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.0007741 on 89 degrees of freedom\nMultiple R-squared:  0.9933,    Adjusted R-squared:  0.9932 \nF-statistic: 1.319e+04 on 1 and 89 DF,  p-value: &lt; 2.2e-16\n\nabline(lm.LB2, col = \"blue\")\n\n\n\n\n\n\n\nFigura 6.8: Lineweaver-Burk from previous plot data.\n\n\n\n\n\nNotice how the adjusted Vm and Km values ​​came close to the predicted values, since for the double-reciprocal plot:\n\\[\nVm=\\frac{1}{intercept} ;\n\\\\\nKm = intercept * Vm\n\\tag{6.6}\\]\nNow, what would happen if the experimental points were in different S content ranges? For example, if the points were collected in three different S regions: 10-100, 30-100, and 50-100?\nThis can be illustrated by varying the S value range iteratively, and inspecting the resulting double-reciprocal plot as in the code snippet that follows, and for the same values ​​as in Figura 6.8.\n\n# Chunk for double-reciprocals of simulated data with variation in [S]\n\nset.seed(1500) # same random seed for error reproducibility\nVm &lt;- 10\nKm &lt;- 0.5 # sets the MM parameters\nS &lt;- seq(10, 100, 10) # creates an initial sequence for S\nv &lt;- Vm * S / (Km + S) # applies the MM equation to S\nplot(1 / S, 1 / v, type = \"n\", ylim = c(0.098, 0.106)) # builds the\n# double-reciprocal without points\nfor (i in 1:3) { # starts iteration for Lineweaver-Burk graphs\nS &lt;- seq(10 * i, 100, length.out = 100) # generates a sequence S with\n# 100 points, producing 5 vectors that start at different values\n# for S (10, 30 and 50)\nerror &lt;- runif(length(S), 0, 0.1) # error for addition to the initial\n# velocity vector, with no. of points as a function of the vector S\nadd &lt;- if (i == 1) FALSE else TRUE # control flow for plotting\n# of points in the empty graph\ninv.S &lt;- 1 / S\ninv.v &lt;- 1 / ((Vm * S / (Km + S)) + error) # new values ​​for the\n# double-reciprocal as a function of iteration\npoints(inv.v ~ inv.S, xlab = \"1/S\", ylab = \"1/v\", col = i, add = add)\n# addition of points to the Lineweaver-Burk plot, with identification\n# by colors (1, 2, 3, 4 and 5)\nlm.LB &lt;- lm(inv.v ~ inv.S) # perform the linear fit\nabline(lm.LB, col = i, lty = i) # overlay the fit lines\n}\n\n\n\n\n\n\n\nFigura 6.9: Double-reciprocal plots for the simulated Michaelis-Menten curve, for different initial S values.\n\n\n\n\n\nNow notice that from the resulting Figura 6.9, both the intercept and slope obtained from the fits were dependent on the selection range of S, which results in different values ​​for Vm and Km. This shows how the selection of the range of S for the calculation of Km and Vm is crucial.\n\n\n\n6.3.2 Linearization by Eadie-Hofstee transformation\nAs already mentioned, the two most common linearizations of the Michaelis-Menten equation refer to the one in the subtitle above. The Eadie-Hofstee linearization equation is given below:\n\\[\nv = \\frac{1}{Km} * \\frac{v}{S} + Vm\n\\tag{6.7}\\]\nFrom the Figura 6.3 data, the kinetic parameters are obtained directly from the intercept (Vm) and the linear slope (1/Km) by:\n\n# Eadie-Hofstee linearization\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500) # fixed seed for random error\nerror &lt;- runif(length(S), 0, 0.1)\nS &lt;- seq(1, 10, 0.1)\nv &lt;- Vm * S / (Km + S) + error\nv.S &lt;- v / S\nplot(v.S ~ v, xlab = \"v\", ylab = \"v/S\")\n\nlm_EH &lt;- lm(v.S ~ v)\nsummary(lm_EH)\n\n\nCall:\nlm(formula = v.S ~ v)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.11602 -0.06496  0.01172  0.05466  0.12483 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 20.31073    0.07906   256.9   &lt;2e-16 ***\nv           -2.02191    0.00893  -226.4   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.07036 on 98 degrees of freedom\nMultiple R-squared:  0.9981,    Adjusted R-squared:  0.9981 \nF-statistic: 5.126e+04 on 1 and 98 DF,  p-value: &lt; 2.2e-16\n\nabline(lm_EH, col = \"blue\")\n\n\n\n\n\n\n\n\n\n\n6.3.3 Error distribution in Michaelis-Mentem linearizations\nAlthough both representations, Lineweaver-Burk and Eadie-Hofstee, are the most widely used and present similarities in obtaining kinetic parameters, their residual distribution is quite different, as is the case with other Michaelis-Mentem linear transformations (Figura 6.4).\nThe code below illustrates the error distribution of these transformations, introducing an important R function for constructing graphs with error bars: arrows.\n\n# Random errors in eq. MM and linearizations\n\nVm &lt;- 10\nKm &lt;- 0.5 # fix MM parameters\nset.seed(1500) # fix seed for random error\nerror &lt;- runif(length(S), 0, 0.5) # uniform error vector\nS &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) # substrate vector\nv &lt;- Vm * S / (Km + S) # MM equation\npar(mfrow = c(2, 2)) # plot area for 4 graphs\nplot(S, v, type = \"o\", main = \"Michaelis-Mentem\")\narrows(S, v, S, v - error, length = .05, angle = 90) # lower error bar\narrows(S, v, S, v + error, length = .05, angle = 90) # upper error bar error\n\nplot(1 / S, 1 / v, type = \"o\", main = \"Lineweaver-Burk\")\narrows(1 / S, 1 / v, 1 / S, 1 / (v - error), length = .05, angle = 90)\narrows(1 / S, 1 / v, 1 / S, 1 / (v + error), length = .05, angle = 90)\n\nplot(v, v/S, type = \"o\", main = \"Eadie-Hofstee\")\narrows(v, v / S, v, (v - error) / S, length = .05, angle = 90)\narrows(v, v / S, v, (v + error) / S, length = .05, angle = 90)\n\nplot(S, S / v, type = \"o\", main = \"Hanes-Woolf\")\narrows(S, S / v, S, S / (v - error), length = .05, angle = 90)\narrows(S, S / v, S, S / (v + error), length = .05, angle = 90)\n\npar(mfrow = c(1, 1)) # return to normal graphics window\n\n\n\n\n\n\n\nFigura 6.10: Distribution of random errors for the Michaelis-Mentem equation and its linear transformations.\n\n\n\n\n\nFrom the graph in Figura 6.10 it is clear that the Lineweaver-Burk and Eadie-Hofstee transformations, although prevalent in the literature, are those that present the greatest error variability based on experimental data, which leads to lower precision in determining kinetic parameters. Furthermore, it is observed that the Hanes-Woolf transformation is the one that presents the smallest residual dispersion among the others, equaling the experimental errors of the Michaelis-Mentem hyperbolic equation. Despite this, the Hanes-Woolf linearization is rarely reported in the literature.\nAlthough the double-reciprocal representation has some disadvantages, such as the dispersion of errors, especially at low values ​​of S, it is the only one among those mentioned that allows a linear adjustment by least squares, if we consider the statistical premises of this.\nIn order to obtain intercept and slope parameters from a linear regression, it is necessary to comply with the statistical premises of 1) normal distribution of residuals, 2) homogeneity of variances , and 3) independence of the variables. If we observe the three linearizations, both the Eadie-Hofstee and the Hanes-Woolf do not fulfill the premise of independence, since the dependent variable (y) is a function of the independent variable (x).\nIn order for a double-reciprocal transformation to be used more faithfully to obtain kinetic parameters, however, the weight calculation in the linear adjustment formula can be adopted, as suggested by Wilkinson (Wilkinson 1961), considering it as the reciprocal of the estimated variances. In this case, the linear fit considering the square of the random error vector as variance and the weight as its reciprocal (1/s²), can be sketched as:\n\n# Lineweaver-Burk weighted linear regression\n\nS &lt;- seq(0.1, 1, length.out = 20)\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500)\nerror &lt;- runif(20, 0, 1)\nv &lt;- Vm * S / (Km + S) + error\ninv.S &lt;- 1 / S\ninv.v &lt;- 1 / v\nreg.LB.weight &lt;- lm(inv.v ~ inv.S, weights = 1 / error^2) # expression for\n# fit linear\nsummary(reg.LB.weight) # fitting results\n\n\nCall:\nlm(formula = inv.v ~ inv.S, weights = 1/error^2)\n\nWeighted Residuals:\n     Min       1Q   Median       3Q      Max \n-0.04779 -0.02231 -0.01849  0.00162  0.04830 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 0.117327   0.002545   46.11  &lt; 2e-16 ***\ninv.S       0.034906   0.001452   24.04 3.93e-15 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.02967 on 18 degrees of freedom\nMultiple R-squared:  0.9698,    Adjusted R-squared:  0.9681 \nF-statistic:   578 on 1 and 18 DF,  p-value: 3.932e-15\n\n\nAlthough the adjustments were made for values ​​with low uniform error variability, a comparison between this result and that of Figura 6.6 reveals a slight superiority for the former, with a higher value for the coefficient of determination R², a lower value for p-value, and lower values ​​for the standard error of the estimates.\nIn addition, a statistical comparison can be obtained between the simple linear model and the one that adopted the statistical weight by:\n\nanova(reg.LB, reg.LB.weight)\n\nAnalysis of Variance Table\n\nModel 1: inv.v ~ inv.S\nModel 2: inv.v ~ inv.S\n  Res.Df       RSS Df Sum of Sq F Pr(&gt;F)\n1     18 0.0038295                      \n2     18 0.0158493  0  -0.01202",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Enzymes</span>"
    ]
  },
  {
    "objectID": "enzimas_en.html#nonlinear-adjustment",
    "href": "enzimas_en.html#nonlinear-adjustment",
    "title": "6  Enzymes",
    "section": "6.4 Nonlinear adjustment",
    "text": "6.4 Nonlinear adjustment\nAlthough linearizations are often used even today, mainly to distinguish between different kinetic models, the precise determination of catalysis parameters is nevertheless better conducted by nonlinear adjustment or regression. This adjustment aims to determine the parameters of an equation (Vm and Km, in this case) without the need for any data transformation, thereby eliminating associated errors.\nNonlinear adjustment differs from linear adjustment in some characteristics, such as:\n\nThe iterative search for a minimum value (local or global) for the sum of the squares of the estimation errors;\nThe need for an initial value for the parameters (seeds);\nLinearity in the errors and in the gradient of the function over the parameters.\nThe need for a more sophisticated algorithm for symbolic and matrix solutions to minimize the derivative of the function over each parameter;\nThe need for a program that works with matrix algebra (computer, mobile device or calculator);\nThe use of more sophisticated algorithms (Gauss, Newton-Raphson, Levenberg-Marquadt, Simplex).\nThe use of the original equation of the model, which is sometimes difficult to linearize.\n\n\n6.4.1 Nonlinear Fitting of the Michaelis-Mentem Equation\nFor a nonlinear regression of the Michaelis-Mentem equation reproducing the simulation exemplified in Figura 6.3:\n\n# Nonlinear regression for simulation of eq. of MM\n\nVm &lt;- 10\nKm &lt;- 0.5\nset.seed(1500)\nerror &lt;- runif(20, 0, 1)\nS &lt;- seq(0, 1, length.out = 20)\nv &lt;- Vm * S / (Km + S) + error\ndat.Sv &lt;- data.frame(S, v) # creating spreadsheet with S and v\nplot(v ~ S,\ntype = \"p\", from = 0, to = 1, n = 20,\nxlab = \"[S}\", ylab = \"v\"\n) # building MM graph\n\nnl.MM &lt;- nls(v ~ Vm * S / (Km + S), start = list(Vm = 7, Km = 0.2),\ndata = dat.Sv) # line of code for non-linear fit\nlines(S, fitted(nl.MM), col = \"red\") # line overlap\n\n\n\n\nNonlinear fit for the experimental simulation of the Michaelis-Mentem equation.\n\n\n\n# adjusted\nsummary(nl.MM) # summary of results\n\n\nFormula: v ~ Vm * S/(Km + S)\n\nParameters:\n   Estimate Std. Error t value Pr(&gt;|t|)    \nVm  9.75490    0.52114  18.718 3.01e-13 ***\nKm  0.36979    0.05015   7.373 7.68e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.3514 on 18 degrees of freedom\n\nNumber of iterations to convergence: 5 \nAchieved convergence tolerance: 1.64e-06\n\n\nNow, notice from the adjustment summary table that the parameters are provided directly, without the need for transformation, as in the linear adjustment. The table differs from the linear adjustment summary by presenting the number of iterations for convergence, and the convergence value for tolerance. However, it does not present the coefficient of determination R², but only the residual standard error. Although the discussion is far from the proposal of this work, some authors decline the use of R² in nonlinear regression because it is due to linear relationships between the parameters, which is not the case in this case.\nAs with linear adjustment, the parameters that comprise the nls function involve:\n\nargs(nls)\n\nfunction (formula, data = parent.frame(), start, control = nls.control(), \n    algorithm = c(\"default\", \"plinear\", \"port\"), trace = FALSE, \n    subset, weights, na.action, model = FALSE, lower = -Inf, \n    upper = Inf, ...) \nNULL\n\n\nIn addition to the package included in the basic R distribution that allows non-linear fits (stats), there are several others that allow fits with various algorithms, evaluations and plots, such as nlme (mixed-effects), nlrwr, nlstools, nls2, nls.multstart, minpack.lm (Levenberg-Marquadt algorithm), nlshelper, and nlsLM.\n\n\n6.4.2 Some advantages of the linear model over the non-linear model\nAlthough the parameterization of nonlinear models is more precise using nonlinear adjustments, the linear algorithm offers some advantages, including:\n\nIt is easier, with a simplified algorithm, and even by using sums of some quantities involving x and y, being solved with a simple scientific calculator, or even by hand;\nIt is more visually intuitive, since the final model will always be a straight line;\nIt has only two parameters in the equation, intercept and slope;\nIt requires few measurements, since a straight line is constructed with only two points;\nIt does not require seeds for initial estimates, which, depending on the nonlinear model, can be quite abstract, culminating in local minima or even in the lack of a solution for the adjustment;\nIt allows experimental interpretation when there is a departure from linearity;\nIt is independent of a specific physical model; 8. sometimes does not require the need for constraints, for example by instructing the algorithm to search for an estimate of a positive value for the parameter.\nlinear relationships and transformations are found in numerous physical models in the Natural Sciences.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Enzymes</span>"
    ]
  },
  {
    "objectID": "enzimas_en.html#allosteric-enzymes",
    "href": "enzimas_en.html#allosteric-enzymes",
    "title": "6  Enzymes",
    "section": "6.5 Allosteric enzymes",
    "text": "6.5 Allosteric enzymes\nAllostery is one of the main resources of metabolism for regulating the levels of cellular compounds. Of Greek origin (allos = other, stereos = structure), an allosteric enzyme is one that alters its catalytic profile as a function of conformational transitions mediated by molecules that interact outside its active site, whether they are substrates, coenzymes, or other compounds (Traut 2007). The resulting effect is a modulation of enzymatic activity, either by activating or inhibiting it. Allosteric enzymes therefore behave as regulatory enzymes in a metabolic pathway, and whose activity can be modulated as a function of retroinhibition or feedback inhibition, as well as by activation by the precursor (Leone 2021).\nThe equation that defines an allosteric enzyme as a function of its substrate content is given below:\n\\[\nv=\\frac{Vm*S^n}{(Km^n+S^n)}\n\\tag{6.8}\\]\nWhere nH represents the coefficient of cooperativity or Hill constant for binding with S molecules (similar to the binding of \\(O_{2}\\) to hemoglobin). In general, the value of nH can be less than unity (negative cooperativity) or greater than it (positive cooperativity). To illustrate the kinetic behavior of an allosteric enzyme, the excerpt below follows, which also introduces another format to represent curves in R by naming the independent variable (x).\n\n# Graph for enzyme allosteric\n\nv &lt;- function(S, Vm = 10, Km = 3, nH = 2) {\nVm * S^nH / (Km^nH + S^nH)\n}\ncurve(v,\nfrom = 0, to = 10, n = 100, xlab = \"S\", ylab = \"v\",\nbty = \"L\"\n) # axes in L\n\n\n\n\nMichaelis-Mentem graph for an allosteric enzyme\n\n\n\n\nIt is also interesting to observe how the allosteric enzymatic profile is defined in relation to the variation of the coefficient nH.\n\n# Influence of the Hill constant (nH) on an allosteric enzyme\n\nnH &lt;- seq(from = 0.1, to = 3, length.out = 7) # sequence for 7 values ​​of nH\nfor (i in 1:length(nH)) { # loop to add allosteric curve for each value of nH\nadd &lt;- if (i == 1) FALSE else TRUE # flow control\nv &lt;- function(S, Vm = 10, Km = 3, a = nH[i]) {\nVm * S^a / (Km^a + S^a)\n}\ncurve(v,\nfrom = 0, to = 4, n = 500, col = i, xlab = \"S\", ylab = \"v\", \nbty = \"L\", add = add\n )\n}\narrows(0, 5, 3, 2, length = 0.1, angle = 45, col = \"blue\") # arrow for nH\ntext(0.5, 5.2, \"nH\", col = \"blue\") # indexer for nH\n\n\n\n\nAllosteric profile of an enzyme under variation of the cooperativity coefficient nH.\n\n\n\n\n\n\n\n\nLeone, Francisco de Assis. 2021. Fundamentos de Cinética Enzimática. Appris Ed.\n\n\nMichaelis, L., e ML Menten. 1913. «Die Kinetik der Invertinwirkung». Biochem Z 49 (4): 333–69.\n\n\nScatchard, George. 1949. «The attractions of proteins for small molecules and ions». Annals of the New York Academy of Sciences 51 (4): 660–72.\n\n\nTraut, Thomas W. 2007. Allosteric regulatory enzymes. Springer Science & Business Media.\n\n\nWilkinson, GN. 1961. «Statistical estimations in enzyme kinetics». Biochemical Journal 80 (2): 324–32.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Enzymes</span>"
    ]
  },
  {
    "objectID": "enzInib_en.html",
    "href": "enzInib_en.html",
    "title": "7  Enzyme inhibition",
    "section": "",
    "text": "7.1 Types of inhibition",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Enzyme inhibition</span>"
    ]
  },
  {
    "objectID": "enzInib_en.html#types-of-inhibition",
    "href": "enzInib_en.html#types-of-inhibition",
    "title": "7  Enzyme inhibition",
    "section": "",
    "text": "A vast chapter in enzymology and with direct application in Chemistry, Pharmacology, Biotechnology, Biomedicine and related areas, enzyme inhibition is at the heart of drugs, medicines and biosensors. From a simplified point of view, enzyme activity can be reduced in the presence of several effectors, among endogenous or exogenous molecules of cellular metabolism, including the substrate itself. Generically, enzyme inhibition is classified as irreversible when the activity decreases due to the covalent binding of an inhibitor, or reversible, when there is an equilibrium of association/dissociation with the macromolecule. Reversible inhibitions will be illustrated below.\n\n7.1.1 Inhibition by the substrate\nA common enzyme inhibition in metabolism is caused by the substrate itself in excess in the medium, defined by:\n\\[\nv=\\frac{Vm*S}{S(1+\\frac{S}{Ks})+Km}\n\\tag{7.1}\\]\nThus, the graph resulting from an inhibition due to excess substrate can be reproduced by:\n\n# Inhibition due to excess S\n\nS &lt;- seq(0, 10, 0.1)\nv_alos &lt;- function(S, Vm = 10, Km = 0.5, Ks = 2) {\nVm * S / (S * (1 + S / Ks) + Km)\n}\ncurve(v_alos, xlim = c(0, 10), xlab = \"S\", ylab = \"v\")\n\n\n\n\n\n\n\nFigura 7.1: Kinetic behavior of an enzyme inhibited by excess substrate.\n\n\n\n\n\nIt can be seen from Figura 7.1 that the enzyme activity reaches a limit and is reduced with increasing substrate content.\n\n\n7.1.2 Enzyme inhibition models\nAssuming the simplified relation below:\n\\[\\begin{equation}\nE+S \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{k2} \\end{array} ES\n\\begin{array}{c}\n_{k3}\\\\\n\\rightarrow \\\\\n^{}\\end{array}E+P\n(\\#eq:diagMM)\n\\end{equation}\\]\nEnzyme inhibition by molecules other than the substrate itself can be represented by a diagram in which the effector alters one of the elements represented in the above equation, as follows.\n\n\n\n\n\n\n\nDiagram representing the types of enzyme inhibition. kcat: catalytic constant; Ki: equilibrium constant for dissociation of the inhibitor, with indices for competitive (Ki), uncompetitive (Kiu) and non-competitive (Kic and Kiu) inhibition.\n\n\n\n\nIn this case, the three main types of reversible enzyme inhibition can be defined as competitive, uncompetitive and non-competitive (pure or mixed) inhibition. In summary, competitive inhibition occurs when the inhibitor complexes with the enzyme’s active site; uncompetitive inhibition, when the inhibitor interacts with the enzyme-substrate complex; and non-competitive inhibition, when the inhibitor binds to a site other than the enzyme’s active site, and can also be pure (Kiu = Kic) or mixed (Kiu &gt; or &lt; Kic).\nA mathematical model that encompasses these three types of enzyme inhibition is described in the equation below:\n\\[\nv=\\frac{Vm*S}{Km(1+\\frac{I}{Kic})+S(1+\\frac{I}{Kiu})}\n\\tag{7.2}\\]\nThus, Equação 7.2 is reduced in its multiplying terms in the denominator, depending on the type of enzyme inhibition present, up to the primitive Michaelis-Mentem model, when there is no inhibitor.\n\n\n7.1.2.1 Michaelis-Mentem curve for enzyme inhibition models\nWe can simulate in R the Michaelian curves for classical inhibition models, considering values ​​for the inhibitor dissociation equilibrium constants such as Kic = 0.2, and Kiu = 1, as in the code snippet below.\n\n# Classical inhibition & Michaelis-Mentem\n\npar(mfrow = c(2, 2)) # divide the plot area\nS &lt;- seq(0, 10, 0.1) # generation of S contents\ncontr &lt;- function(S, Vm = 10, Km = 0.5) {\nVm * S / (Km + S)\n} # MM function, without inhibition\ncurve(contr, xlim = c(0, 10), xlab = \"S\", ylab = \"v\", main = \"Competitive\")\n# control curve; note that the title has to be added for the 1a. of pair\n# of curves, control and inhibition\n\n# Inhibition models:\n\n# Competitive\ncomp.i &lt;- function(S, Vm = 10, Km = 0.5, I = 2, Kic = 0.2) {\nVm * S / (Km * (1 + I / Kic) + S)\n}\ncurve(comp.i, add = TRUE, col = \"red\", lty = 2) # competitive\n\n# Pure noncompetitive\npura.i &lt;- function(S, Vm = 10, Km = 0.5, I = 2, Ki = 1) {\nVm * S / (Km * (1 + I / Ki) + S * (1 + I / Ki))\n}\ncurve(contr, xlim = c(0, 10), xlab = \"S\", ylab = \"v\", main = \"Pure Noncompet.\")\ncurve(pura.i, add = TRUE, col = \"red\", lty = 2) # pure non-competitive (Kiu=Kic=Ki)\n\n# Mixed non-competitive\nmista.i &lt;- function(S, Vm = 10, Km = 0.5, I = 2, Kic = 0.2, Kiu = 1) {\n Vm * S / (Km * (1 + I / Kic) + S * (1 + I / Kiu))\n}\ncurve(contr, xlim = c(0, 10), xlab = \"S\", ylab = \"v\", main = \"Non-Compet. Mixed\")\ncurve(mista.i, add = TRUE, col = \"red\", lty = 2) # mixed non-competitive\n\n# Uncompetitive\nuncomp.i &lt;- function(S, Vm = 10, Km = 0.5, I = 2, Kiu = 1) {\nVm * S / (Km + S * (1 + I / Kiu))\n}\ncurve(contr, xlim = c(0, 10), xlab = \"S\", ylab = \"v\", main = \"Uncompetitive\")\ncurve(uncomp.i, add = TRUE, col = \"red\", lty = 2) # uncompetitive\nlayout(1) # returns to the original graphic window\n\n\n\n\n\n\n\nFigura 7.2: Michaelis-Mentem curve in the presence of classical inhibitors.\n\n\n\n\n\nNote that for the competitive model the limiting reaction rate Vm tends to be reached, since the occupation of the enzyme’s active site is mutually exclusive between substrate and inhibitor, favoring the former when in high concentration. On the other hand, the Vm value is not tangible for the other inhibition models, since the inhibitor binds to another site on the enzyme (non-competitive) or to the substrate itself (uncompetitive). To see changes in the graphs, try modifying the simulation parameters (Vm, Km, Ki, Kic, Kiu, I).\nAlthough it is possible to distinguish the competitive model from the others, also note that this was only possible for a simulation that used an S content 20 times greater than the Km value of the reaction. This is not always possible in practice, as listed below, since the use of high S contents:\n\nAdds greater financial cost to the test.\nMay result in inhibition due to excess substrate.\nMay increase the viscosity of the medium, reducing the catalytic rate.\n\nIt can be seen from Figura 7.2 and the observations above that it is difficult to classify the type of enzyme inhibition based on direct observation of a Michaelis-Mentem curve.\n\n\n7.1.2.2 Diagnosis of enzyme inhibition models by Lineweaver-Burk\nLinear transformations of the Michaelis-Mentem equation are very useful in the visual diagnosis of inhibition models. In this sense, the use of double-reciprocal linearization for these models will result in the following inhibition equations:\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km(1+\\frac{I}{Kic})}{Vm}*\\frac{1}{S} \\quad ;\\, competitive\n\\tag{7.3}\\]\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km(1+\\frac{I}{Ki})}{Vm}*\\frac{1}{S(1+\\frac{I}{Ki})} \\quad ;\\, pure\n\\tag{7.4}\\]\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km(1+\\frac{I}{Kic})}{Vm}*\\frac{1}{S(1+\\frac{I}{Kiu})} \\quad ;\\, mixed\n\\tag{7.5}\\]\n\\[\n\\frac{1}{v}=\\frac{1}{Vm}+\\frac{Km}{Vm}*\\frac{1}{S(1+\\frac{I}{Kiu})} \\quad ;\\, uncompetitive\n\\tag{7.6}\\]\nNote that the multiplier terms inserted in S and Km in the double-reciprocal equation only change its formalism presented in the Lineweaver-Burk equation of the previous chapter. Thus, enzyme inhibition models can be illustrated by R together with the Lineweaver-Burk transformation (or any other), as below.\n\n# Diagnosis of inhibition by Lineweaver-Burk\n\n# Substrate and Inhibitor\nS &lt;- seq(0.1, 10, length = 10) # create a vector for substrate\nI &lt;- 2 # inhibitor concentration\n\n# Kinetic parameters:\nKm &lt;- 0.5\nVm &lt;- 10\nKic &lt;- 0.2\nKi &lt;- 0.2\nKiu &lt;- 1\n\n# Equations\nv &lt;- Vm * S / (Km + S) # MM equation\nv.comp &lt;- Vm * S / (Km * (1 + I / Kic) + S) # competitive\nv.pure &lt;- Vm * S / (Km * (1 + I / Ki) + S * (1 + I / Ki))\n # pure non-competitive\nv.mixed &lt;- Vm * S / (Km * (1 + I / Kic) + S * (1 + I / Kiu))\n # mixed non-competitive\nv.incomp &lt;- Vm * S / (Km + S * (1 + I / Kiu))\n\n# Graphics\npar(mfrow = c(2, 2)) # plot area for 4 graphs\n\nplot(1 / S, 1 / v, type = \"l\", main = \"Competitive\", ylim = c(0, 2))\npoints(1 / S, 1 / v.comp, type = \"l\", col = \"red\")\nplot(1 / S, 1 / v, type = \"l\", main = \"Pure\", ylim = c(0, 5))\npoints(1 / S, 1 / v, type = \"l\", col = \"red\")\nplot(1 / S, 1 / v, type = \"l\", main = \"Mixed\", ylim = c(0, 2))\npoints(1 / S, 1 / v.mixed, type = \"l\", col = \"red\")\nplot(1 / S, 1 / v, type = \"l\", main = \"Uncompetitive\", ylim = c(0, 1))\npoints(1 / S, 1 / v.incomp, type = \"l\", col = \"red\")\n\n\n\n\nDiagnosis of enzyme inhibition models by Lineweaver-Burk.\n\n\n\nlayout(1) # return to normal graphics window\n\nNow the distinction of inhibition models becomes more evident by linearization. As mentioned for the models represented in the direct Michaelis-Mentem equation, one can vary the kinetic parameters and experiment with the visualization of double reciprocals.\nAgain, although linearization allows a better diagnosis of the type of inhibition present, nonlinear adjustment is more appropriate for determining inhibition constants (Ki’s), since it does not include errors arising from linear transformations (although the insertion of statistical weights can alleviate the imprecision of the results).\n\n\n7.1.2.3 Ki & IC\\(_{50}\\)\nThe inhibitory concentration at 50% of the inhibitor content, defined as IC\\(_{50}\\), can be determined empirically without knowledge of the enzyme catalysis parameters involved. To do so, it is enough to obtain a relative inhibition value in a test at a fixed concentration of S, varying the inhibitor content. In fact, analogues to IC\\(_{50}\\) exist in a wide range in the Natural Sciences, not involving necessarily any kinetic or thermodynamic information of the compounds involved, but only the empirical information of the result. For example, the parameters DE\\(_{50}\\) (effective dose) or DL\\(_{50}\\) (lethal dose), and even projections of X\\(_{50}\\), such as Tm (denaturation temperature at 50%), and the value of pKa in buffers (pH at which the species are 50% ionized/protonated in solution).\nHowever, there is a useful relationship between the inhibitor dissociation equilibrium constant Ki and the value of IC\\(_{50}\\) that allows their exchange, as long as the inhibition model is known (Yung-Chi e Prusoff 1973). Generalizing to inhibition models, a general equation for the Cheng-Prusoff relation can be defined as:\n\\[\nIC_{50} = \\frac{(1+\\frac{S}{Km})}{(\\frac{1}{Kic})+(\\frac{1}{Km*Kiu})}\n\\tag{7.7}\\]\nFor example, for a competitive inhibition model, where Kiu is zero:\n\\[\nIC_{50} = Kic(1+\\frac{S}{Km})\n\\tag{7.8}\\]\nAs mentioned above, the value of IC\\(_{50}\\) can be obtained from experimental data of relative inhibition (v/Vm, for example) at different inhibitor concentrations by setting a value of S. In this case, we can illustrate in R the obtaining of IC\\(_{50}\\), using a non-linear fit to the following four-parameter equation (Rodbard curve, DeLean, Munson, e Rodbard (1978)).\n\\[\nresidual act. \\, \\% =\\frac{v}{Vm} = inf+\\frac{sup-inf}{1+log(\\frac{I}{IC_{50}})^{nH}})\n\\] {#eq:eqRodb}\n\n# Non-linear fit to IC50 curve\n\nlogI.nM &lt;- c(5.5, 5.2, 4.9, 4.6, 4.3, 3.7, 3.3, 3, 2.8)\n# conc. of I, in log10 units\nativ.res &lt;- c(0.02, 0.07, 0.12, 0.22, 0.36, 0.53, 0.67, 0.83, 0.85)\n# ativ. residual, v/Vm\ndata &lt;- data.frame(logI.nM, ativ.res) # create dataframe\nplot(ativ.res ~ logI.nM, data) # plot data\nic50.fit &lt;- nls(formula(ativ.res ~ inf + (sup - inf) /\n(1 + (logI.nM / logIC50)^nH)),\nalgorithm = \"port\", data = data,\nstart = list(inf = 0, sup = 0.80, logIC50 = 4, nH = 10),\nlower = c(inf = -Inf, sup = -Inf,\nlogIC50 = 0, nH = -Inf)) # nonlinear fit\nsummary(ic50.fit) # fit summary\n\n\nFormula: ativ.res ~ inf + (sup - inf)/(1 + (logI.nM/logIC50)^nH)\n\nParameters:\n        Estimate Std. Error t value Pr(&gt;|t|)    \ninf      -0.3211     0.2932  -1.095  0.32348    \nsup       1.1200     0.2311   4.847  0.00469 ** \nlogIC50   4.0807     0.2309  17.675 1.06e-05 ***\nnH        4.0540     1.7462   2.322  0.06792 .  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.02769 on 5 degrees of freedom\n\nAlgorithm \"port\", convergence message: relative convergence (4)\n\nlines(logI.nM, fitted(ic50.fit), col = \"blue\") # fitted line\n\n\n\n\n\n\n\n# And to extract the value of IC50...\nIC50 &lt;- 10^(coef(ic50.fit)[3]) # extraction of the 3rd parameter from the\n# fitting table, that is: logIC50:\nIC50\n\n logIC50 \n12042.04 \n\n\nNote that the logIC50 parameter was extracted from the nonlinear fitting table by the coef command. This is very useful when we want to use a coefficient obtained in automatic (programmable) calculations, as we will see later. For now, it is interesting to present the IC50 parameter obtained in a more elegant way.\nTo do this, we can use two R functions to express quantitative results together with characters (words, sentences): print() and cat. The code snippet below illustrates this output, and some differences.\n\ncat(\"IC50 Value (nM):\", IC50, \"\\n\")\n\nIC50 Value (nM): 12042.04 \n\nprint(paste(\"IC50 Value (nM):\", IC50))\n\n[1] \"IC50 Value (nM): 12042.0403466162\"\n\n\nBasically, print displays quotes and indexes the column name, while cat omits them. In addition, another variation in the printing format between the two commands can be seen in the example below:\n\nprint(paste(\"teores:\", c(10, 25, 50)))\n\n[1] \"teores: 10\" \"teores: 25\" \"teores: 50\"\n\ncat(\"teores:\", c(10, 25, 50))\n\nteores: 10 25 50\n\n\nAnother possibility in R is to reduce the number of decimal places displayed. In this case, the round command can be used.\n\nIC50 &lt;- 10^(coef(ic50.fit)[3])\nprint(paste(\"IC50 value (nM):\", round(IC50, digits = 2)))\n\n[1] \"IC50 value (nM): 12042.04\"\n\n# rounding to two decimal places\n\nOnce again, it is worth highlighting the existence of some useful R packages for calculating IC50, including the drc package (dose-response curve).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Enzyme inhibition</span>"
    ]
  },
  {
    "objectID": "enzInib_en.html#statistical-diagnosis-of-enzyme-inhibition",
    "href": "enzInib_en.html#statistical-diagnosis-of-enzyme-inhibition",
    "title": "7  Enzyme inhibition",
    "section": "7.2 Statistical diagnosis of enzyme inhibition",
    "text": "7.2 Statistical diagnosis of enzyme inhibition\nIn parallel with the visual inspection of linearization graphs for enzyme inhibition, it is possible to validate one model over another by analyzing the dispersion of model errors. But it is also possible to use the BIC function or the AIC function of R, which respectively calculate values ​​for the Baysean Information Criterion (Spiess e Neumeyer 2010) or the Akaike Information Criterion (Akaike 1974). In common, these parameters calculate a relative value of information not computed by an evaluated model. The lowest value found for both reflects the solution of the best fitting model.\nMathematically, BIC and AIC can be expressed as:\n\\[\nBIC = p*ln(n)-2*ln(RSE)\\\\\n\\\\\nAIC = n*ln(\\frac{RSE}{n})+2k+[\\frac{2k(k+1)}{n-k-1}])\\\\\n\\tag{7.9}\\]\nWhere p represents the no. of model parameters, n the total number of experimental points, k the factor p+1, and RSE the value of the sum of squares of the residuals (residual sum squares).\nTo exemplify the use of these quality parameters of the statistical model, one can use a dataset contained in the nlstools package, providing the fitting, plotting, inspection of residuals, and application of BIC and AIC:\n\n# Application of information criteria for fitting kinetic curves\n\nlibrary(nlstools)\n\n\n'nlstools' has been loaded.\n\n\nIMPORTANT NOTICE: Most nonlinear regression models and data set examples\n\n\nrelated to predictive microbiolgy have been moved to the package 'nlsMicrobio'\n\ncomp &lt;- nls(compet_mich, vmkmki, list(Km = 1, Vmax = 20, Ki = 0.5))\n# competitive fitting, with data, equation and seeds provided\n# by the nlstools package\nplotfit(comp, variable = 1) # plotting command of the package\n\n\n\n\n\n\n\nsummary(comp)\n\n\nFormula: v ~ S/(S + Km * (1 + I/Ki)) * Vmax\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \nKm    15.2145     2.5005   6.085 5.79e-08 ***\nVmax  18.0557     0.6288  28.713  &lt; 2e-16 ***\nKi    22.2822     4.9060   4.542 2.30e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.603 on 69 degrees of freedom\n\nNumber of iterations to convergence: 11 \nAchieved convergence tolerance: 5.116e-06\n\nres_comp &lt;- nlsResiduals(comp) # residuals of the fit\nplot(res_comp, which = 1) # plotting of residuals\n\n\n\n\n\n\n\nnoncomp &lt;- nls(non_compet_mich, vmkmki, list(Km = 1, Vmax = 20, Ki = 0.5))\n# same as above, but for the non-competitive model\nplotfit(noncomp, variable = 1)\n\n\n\n\n\n\n\nsummary(noncomp)\n\n\nFormula: v ~ S/((S + Km) * (1 + I/Ki)) * Vmax\n\nParameters:\n     Estimate Std. Error t value Pr(&gt;|t|)    \nKm    22.7787     1.4738   15.46   &lt;2e-16 ***\nVmax  20.5867     0.4306   47.80   &lt;2e-16 ***\nKi   101.3563     7.3303   13.83   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.8925 on 69 degrees of freedom\n\nNumber of iterations to convergence: 7 \nAchieved convergence tolerance: 8.27e-06\n\nres_noncomp &lt;- nlsResiduals(noncomp)\nplot(res_noncomp, which = 1)\n\n\n\n\n\n\n\nBIC(comp, noncomp) # Bayesian information criterion\n\n        df      BIC\ncomp     4 286.2994\nnoncomp  4 201.9981\n\nAIC(comp, noncomp) # Akaike information criterion\n\n        df      AIC\ncomp     4 277.1928\nnoncomp  4 192.8915\n\n\nIt can be seen in the comparison of the non-linear fits that the non-competitive model fitted better than the competitive model (lower values ​​for BIC and AIC)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Enzyme inhibition</span>"
    ]
  },
  {
    "objectID": "enzInib_en.html#pre-steady-state-kinetics",
    "href": "enzInib_en.html#pre-steady-state-kinetics",
    "title": "7  Enzyme inhibition",
    "section": "7.3 Pre-steady state kinetics",
    "text": "7.3 Pre-steady state kinetics\nThere are basically three types of kinetic behavior for enzymes: Henry-Michaelis-Mentem-Briggs-Haldane behavior, succinctly called Michaelian or steady-state behavior, lag-phase behavior (when the substrate takes some time to be converted to product), and burst, transient, or pre-steady-state behavior (when a phase with rapid product release precedes the steady state). Some enzymes work following burst kinetics, including some nucleosidases and glycosidases, and dehalogenases Tang et al. (2003).\nPre-steady-state kinetics follows a slightly different formalism, which depends on the number of reaction steps. Example below for a 3-step reaction (Johnson 1992):\n\\[\nE+S \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{km1} \\end{array}\nE*S\n\\begin{array}{c}\n_{k2}\\\\\n\\rightleftharpoons\\\\\n^{km2} \\end{array}\nE*P\n\\begin{array}{c}\n_{k3}\\\\\n\\rightarrow \\\\\n^{}\\end{array}\nE+P\n\\tag{7.10}\\]\nIn this case, the equations derived from the experimental observations, and which lead to the determination of the rate constants are:\n\\[\nkobs=k2+km2+k3\n\\tag{7.11}\\]\n\\[\nAo=\\frac{k2*(k2+km2)}{kobs^2}\n\\tag{7.12}\\]\n\\[\nkcat=\\frac{k2*k3}{kobs}\n\\tag{7.13}\\]\nWhere kobs and Ao represent experimental parameters of observed rate constant and amplitude, respectively. These parameters can be obtained from the nonlinear fit of the equation below to the experimental data:\n\\[\nP=Ao(1-e^ {-kobs} + kcat * t)\n\\tag{7.14}\\]\nThe following code snippet simulates a pre-stationary behavior curve, when the rate constants that determine the experimental parameters are known.\n\n# MM curve in pre-steady state enzyme\n\n# Parameters\nk2 &lt;- 387\nkm2 &lt;- 3\nk3 &lt;- 22\nxmin &lt;- 0\nxmax &lt;- 0.075 # definition of limits for function\n\n# Variables of the simulation equation (function of parameters)\nkobs &lt;- k2 + km2 + k3\nAo &lt;- k2 * (k2 + km2) / kobs^2\nkcat &lt;- k2 * k3 / kobs\n\n# Definition of the simulation function\nsim &lt;- function(x, kobs, Ao, kcat) {\nAo * (1 - exp(-kobs * x)) + kcat * x\n}\n\n# Simulation curve\ncurve(sim(x, kobs = kobs, Ao = Ao, kcat = kcat),\ncol = \"blue\",\ntype = \"o\", xlim = c(xmin, xmax), cex = 0.5,\nxlab = \"time\", ylab = \"[P]\"\n)\n\n\n\n\n\n\n\nFigura 7.3: Product formation in a pre-steady state kinetic model.\n\n\n\n\n\nNote from Figura 7.3 that in transient state kinetics, there is an initial pre-stationary phase that rapidly increases the product content P, and that precedes the stationary phase of constant release of P.\nOn the other hand, sometimes the opposite is necessary, that is, to determine the rate constants from knowledge of the experimental parameters kobs and Ao. In this case (and in many other transdisciplinary cases) R has minimization functions that allow finding the root of linear or nonlinear equations.\nThe procedure involves iteratively minimizing a vector of equations given the seeds for each parameter. To do this, we seek to obtain f(x) = 0 by the difference between a reference value; that is, when the solution finds x when f(x)-y = 0. For example, suppose that f(x) is a+b/x, and that y is 3. Then the search is to find a and b in a+b/x-3.\nTo determine the rate constants represented in transient kinetics, it is worth mentioning the optim function in stats or the rootSolve package, which seek to minimize linear and nonlinear equations to find the values ​​of their parameters.\nIn the solution of the parameters for pre-steady state, the use of R with rootSolve is illustrated below, also adding the search for Km as follows.\n\\[\nKm = \\frac{k3}{k2+k3}\n\\] {#eq:burstKm}\n\n# Calculation of kinetic constants by solving a system of nonlinear\n# equations applied to burst kinetics.\n\nlibrary(rootSolve)\nkobs &lt;- 0.06\nAo &lt;- 50\nkcat &lt;- 300\nKs &lt;- 15\n# defines the nonlinear fitting parameters obtained by progressive curve\n# experimental, t x P; # Note: Ks obtained experimentally from the S x kobs curve\n\n# Parameters\n# x[1]=k2\n# x[2]= k3\n# x[3] = Km\n\n# Model\nmodel &lt;- function(x) c(x[1] / kobs^2 - Ao, (x[1] * x[2]) / kobs - kcat,\nKs * x[2] / (x[1] + x[2]) - x[3])\n# the model above must contain a list of equations whose equality is zero,\n# that is, f(x)=0\n(ss &lt;- multiroot(model, c(1, 1, 1))) # rootSolve execution command\n\n$root\n[1]   0.18000 100.00000  14.97305\n\n$f.root\n[1]  0.000000e+00  1.136868e-13 -1.243054e-09\n\n$iter\n[1] 4\n\n$estim.precis\n[1] 4.143891e-10\n\n# (seeds for the algorithm)\n\nThe results of the minimization can be interpreted as:\n\nroot = values of xi for f(xi)=0 ; that is, k2, k3, and Km; 2. f.root = value of each function for each xi (must be close to zero for each);\niter = no. iterations;\nesti.precis = precision estimate.\n\nConsidering an extensive chapter on enzyme kinetics, there are numerous topics left out, given the main focus of using R in solving quantitative problems in biophysical chemistry. Thus, we omit several concepts, such as slow kinetics of substrate interaction (slow binding), kinetics of multiple substrates (sequential and ping-pong reactions), integrated Michaelis-Menten equation and progressive curves, activation of modulators, influence of pH and temperature on catalysis, and multisite enzymes, among others.\n\n\n\n\nAkaike, Hirotugu. 1974. «A new look at the statistical model identification». IEEE transactions on automatic control 19 (6): 716–23.\n\n\nDeLean, A, PJ Munson, e Dl Rodbard. 1978. «Simultaneous analysis of families of sigmoidal curves: application to bioassay, radioligand assay, and physiological dose-response curves.» American Journal of Physiology-Endocrinology And Metabolism 235 (2): E97.\n\n\nJohnson, Kenneth A. 1992. «1 transient-state kinetic analysis of enzyme reaction pathways». Em The enzymes, 20:1–61. Elsevier.\n\n\nSpiess, Andrej-Nikolai, e Natalie Neumeyer. 2010. «An evaluation of R2 as an inadequate measure for nonlinear models in pharmacological and biochemical research: a Monte Carlo approach». BMC pharmacology 10 (1): 1–11.\n\n\nTang, Lixia, Jeffrey H Lutje Spelberg, Marco W Fraaije, e Dick B Janssen. 2003. «Kinetic mechanism and enantioselectivity of halohydrin dehalogenase from Agrobacterium radiobacter». Biochemistry 42 (18): 5378–86.\n\n\nYung-Chi, Cheng, e William H Prusoff. 1973. «Relationship between the inhibition constant (KI) and the concentration of inhibitor which causes 50 per cent inhibition (I50) of an enzymatic reaction». Biochemical pharmacology 22 (23): 3099–3108.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Enzyme inhibition</span>"
    ]
  },
  {
    "objectID": "binding_en.html",
    "href": "binding_en.html",
    "title": "8  Molecular interaction",
    "section": "",
    "text": "8.1 Ligand-biopolymer interaction\n\\[\nP+L \\begin{array}{c}\n_{k_{on}}\\\\\n\\rightleftharpoons\\\\\n^{k_{off}} \\end{array} PL\n\\tag{8.1}\\]\nWhere P represents the free protein content, L the free ligand, and PL the formed complex. The reaction rates are defined for the formation (k\\(_{on}\\); M\\(^{-1}\\)s\\(^{-1}\\)) and dissociation (k\\(_{off}\\); s\\(^{-1}\\)) of the complex.\n\\[\nKd=\\frac{[P]*[L]}{[P]+[L]}\n\\tag{8.2}\\]\nWhere Kd represents the equilibrium dissociation constant for the formed PL complex, as conditioned on the formation/dissociation equilibrium of the complex (v\\(_{assoc}\\) = v\\(_{dissoc}\\)), and also defined as:\n\\[\nKd=\\frac{k_{off}}{k_{on}}\n\\tag{8.3}\\]\n\\[\n\\nu=\\frac{n * [L]}{Kd + [L]}\n\\tag{8.4}\\]",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Molecular interaction</span>"
    ]
  },
  {
    "objectID": "binding_en.html#Binding",
    "href": "binding_en.html#Binding",
    "title": "8  Molecular interaction",
    "section": "",
    "text": "When mentioning interaction between biomolecules, one usually refers to adsorptive processes involving a biopolymer (protein, nucleic acid, glycan) and a low molecular weight ligand, although the formalism also applies with some restriction to interactions between biopolymers, and even whole cells.\nThe most common formalism for biomolecular interaction is that which involves the formation of an adsorptive complex between a protein and a ligand (ligand binding), exemplified for ions (Ca\\(^{2+}\\), Mg\\(^{2+}\\), etc.), drugs and candidates, natural products, and antigens, among others.\nSimple questions about ligand-protein interaction can elucidate several characteristics of the formation of such complexes, such as:\n\nHow much protein/ligand is present?\nHow much of the complex is formed?\nHow fast does the complex associate/dissociate?\nWhat are the mechanisms involved?\n\nIn general, the ligand-protein interaction can be represented as follows:\n\n\nThus, the equation for the interaction isotherm of the ligand with the protein is deduced as follows:\n\n\n\nFrom Equação 8.2 one can easily deduce the final expression for the interaction of a ligand to a set of sites of the same affinity on the protein:",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Molecular interaction</span>"
    ]
  },
  {
    "objectID": "binding_en.html#interaction-models-and-linear-representations",
    "href": "binding_en.html#interaction-models-and-linear-representations",
    "title": "8  Molecular interaction",
    "section": "8.2 Interaction Models and Linear Representations",
    "text": "8.2 Interaction Models and Linear Representations\nNote that Equação 8.4 practically repeats the formalism already seen with the formation of the activated enzyme-substrate complex from the Enzymes chapter, as well as its resulting representation as a quadratic hyperbola. In fact, it essentially replaces the kinetic parameter v of the reaction by the thermodynamic parameter \\(\\nu\\) (“nu”, from the Greek) for the binding isotherm. The other quantities involved remain analogous (P in place of E; L in place of S;Kd in place of Km; and n in place of Vmax).\nMaintaining this similarity with the formalism of the Michaelis-Menten equation, the linearizations for the Equação 8.4) follow in the same way, as well as non-linear adjustments to it, in the search for an analytical solution for the thermodynamic parameters Kd and n. Here is an example of a code snippet for the most common linearizations in the treatment of ligand-protein interaction data:\n\n# Linearizations in bimolecular interactions\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd &lt;- 1e-6\nn &lt;- 1\nv &lt;- n * L / (Kd + L)\npar(mfrow = c(2, 3)) # establishes plot area for 6 graphs\nplot(L, v, type = \"o\", main = \"Direct\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\")\n\n\n\n\nMain linearizations of the ligand-protein binding isotherm.\n\n\n\npar(mfrow = c(1, 1)) # return to normal graphics window\n\nDeviations from linearity, on the other hand, are often used as diagnostics for models other than the binding site homogeneity model as above (site heterogeneity, site creation, cooperativity). The equations below describe these models, and consider K, ligand-protein equilibrium association constant, as the inverse of Kd, in order to make the expressions more readable:\n\\[\nK = \\frac{1}{Kd}\n\\tag{8.5}\\]\nThe binding site heterogeneity model assumes that there is one more site in the protein with distinct affinities for the ligand (Dahlquist 1978). Formally, this model can be exemplified for 2 sets of binding sites, as follows:\n\\[\n\\nu=\\frac{K1*[L]}{1+K1*[L]} + \\frac{K2*[L]}{1+K2*[L]}\n\\tag{8.6}\\]\nThe code snippet below exemplifies the model in R, as well as its main diagnostic linearizations.\n\n# Binding site heterogeneity\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd1 &lt;- 2e-6\nn1 &lt;- 1\nKd2 &lt;- 2e-8\nn2 &lt;- 1\nv &lt;- (n1 * L / (Kd1 + L)) + (n2 * L / (Kd2 + L))\n\npar(mfrow = c(2, 3)) # set plot area for 6 graphs\nplot(L, v, type = \"o\", main = \"Direct\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n1 + n2 - v)), type = \"o\", main = \"Hill\")\n\n\n\n\nModel and linearizations for heterogeneity of 2 sets of binding sites\n\n\n\n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # return to normal graph window\n\nThe one-site creator model (Parsons e Vallner 1978) establishes a positive cooperativity resulting from the production of new sites for the ligand in the protein. The following is the exemplified model and its resulting linearizations.\n\n# New site creation under ligand interaction\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd1 &lt;- 2e-6\nn1 &lt;- 1\nKd2 &lt;- 2e-5\nn2 &lt;- 1\nnH &lt;- 0.5\nv &lt;- (n1 * L * 1 / Kd1) / (1 + 1 / Kd1 * L) +\n((n2 * 1 / Kd1 * 1 / Kd2 * L^2) / (1 + 1 / Kd1 * L) * (1 + 1 / Kd2 * L))\npar(mfrow = c(2, 3)) # set plot area for 6 graphs\nplot(L, v, type = \"o\", main = \"Direct\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\")\n\nWarning in xy.coords(x, y, xlabel, ylabel, log): NaNs produced\n\n\n\n\n\nModel and linearizations for new site creation: 1-site creator.\n\n\n\n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # return to normal graph window\n\nThe cooperativity models (negative and positive) follow a similar formalism described for oxygen binding to hemoglobin in the Proteins chapters. In negative cooperativity a second ligand molecule interacts with the protein with lower affinity:\n\n# Negative cooperativity in ligand-binding\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd &lt;- 2e-6\nn &lt;- 1\nnH &lt;- 0.5\nv &lt;- (n * L^nH / (Kd + L^nH))\npar(mfrow = c(2, 3)) # set plot area for 6 graphs\nplot(L, v, type = \"o\", main = \"Direct\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\")\n\n\n\n\nModel and linearizations for negative cooperativity of binding sites.\n\n\n\n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # return to normal graphics window\n\nIn positive cooperativity, a second ligand molecule interacts with the protein with greater affinity than the first molecule (Parsons e Vallner 1978):\n\n# Positive cooperativity in ligand binding\n\nL &lt;- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd &lt;- 2e-6\nn &lt;- 1\nnH &lt;- 1.5\nv &lt;- (n * L^nH / (Kd + L^nH))\npar(mfrow = c(2, 3)) # establish plot area for 6 graphs\nplot(L, v, type = \"o\", main = \"Direct\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\")\n\n\n\n\nModel and linearizations for positive cooperativity of binding sites.\n\n\n\n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # return to normal graphing window\n\nNote that the slope of the Hill plot is less than unity for negative cooperativity and greater than unity for positive cooperativity, and represents the same nH parameter seen in the Proteins chapter.\nAlthough subject to criticism for its statistical inconsistency (dependent variable on both axes), the Scatchard representation has been favored for decades as a diagnostic for ligand-protein interaction models. Among its advantages is the ability to easily distinguish the positive cooperativity model (uphill) from the heterogeneity of binding sites (steep slope) or negative cooperativity (gentle slope).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Molecular interaction</span>"
    ]
  },
  {
    "objectID": "binding_en.html#nonlinear-fitting-in-ligand-protein-interaction",
    "href": "binding_en.html#nonlinear-fitting-in-ligand-protein-interaction",
    "title": "8  Molecular interaction",
    "section": "8.3 Nonlinear Fitting in Ligand-Protein Interaction",
    "text": "8.3 Nonlinear Fitting in Ligand-Protein Interaction\nDirect fits of the nonlinear equation of interaction models can also be performed as was done for the Michaelis-Menten equation in the Enzymes chapter. For example, one can simulate obtaining experimental binding data by the following excerpt, using the ‘runif’ (random uniform) command to generate a random sequence (as was done in the Enzymes chapter). To illustrate, see Figura 8.1.\n\n# Ligand-Protein Interaction Isotherm\nn &lt;- 1\nKd &lt;- 10\nL &lt;- 120\ni &lt;- 3\nL &lt;- seq(0, L, i)\nv &lt;- (L * n) / (Kd + L) + rnorm(40, 0, 0.1)\n\nWarning in (L * n)/(Kd + L) + rnorm(40, 0, 0.1): longer object length is not a\nmultiple of shorter object length\n\nplot(L, v)\n\n\n\n\n\n\n\nFigura 8.1\n\n\n\n\n\nNote that the ‘rnorm’ command adds a normal distribution error to the data. Another way to simulate these is given below by introducing the ‘runif’ random number generation command.\n\n# Simulation of bimolecular interaction data (1 site)\n\n# Simulation of data\nset.seed(20160227) # sets seed for random number generation\nL &lt;- seq(0, 50, 1)\nPL &lt;- ((runif(1, 10, 20) * L) / (runif(1, 0, 10) + L)) + rnorm(51, 0, 1)\n# 1. runif(n,min,max); when without attributes, min=0 and max=1 are considered\n# 2. rnorm(no. points,mean,deviation) - random error of normal distribution\nplot(L, PL, xlab = \"L\", ylab = \"PL\")\n\n\n\n\nSimulated data for bimolecular interaction isotherm.\n\n\n\n\nNow we need to use the ‘nls’ command for nonlinear fitting, superimposition of the theoretical curve, and statistical table of results:\n\n# Nonlinear fitting in ligand binding\nm &lt;- nls(PL ~ n * L / (Kd + L), start = list(n = 1, Kd = 1))\n\n# Correlation coefficient\ncor(PL, predict(m)) # Pearson correlation coefficient\n\n[1] 0.9496598\n\n# Data plot and simulation\nplot(L, PL)\nlines(L, predict(m), lty = 2, col = \"red\", lwd = 3)\n\n\n\n\n\n\n\nsummary(m)\n\n\nFormula: PL ~ n * L/(Kd + L)\n\nParameters:\n   Estimate Std. Error t value Pr(&gt;|t|)    \nn   11.8478     0.2620  45.216  &lt; 2e-16 ***\nKd   4.2778     0.5113   8.366  5.3e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.7826 on 49 degrees of freedom\n\nNumber of iterations to convergence: 6 \nAchieved convergence tolerance: 1.554e-06",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Molecular interaction</span>"
    ]
  },
  {
    "objectID": "binding_en.html#graphics-systems-in-r",
    "href": "binding_en.html#graphics-systems-in-r",
    "title": "8  Molecular interaction",
    "section": "8.4 Graphics Systems in R",
    "text": "8.4 Graphics Systems in R\nThe last simulation curve obtained was from the standard library for manipulating graphics in the ‘R’ installation, Graphics. This is a broad set of functions also used by several other packages in the environment. However, there are several other libraries in ‘R’ for creating graphs, among which it is worth highlighting Lattice, also included in the standard installation, and ggplot2. Both systems generate results with better aesthetics and graphic flexibility than the standard Graphics library, and have different uses and semantics.\nThe Lattice system (Sarkar 2008) is based on the Trellis system for graphical representation of multivariate data. Its strength lies in the representation of data in panels containing subgroups and, although it has a less intuitive and sometimes more elaborate syntax than the Graphics package, it produces a superior graph with just a few keyboard clicks. In general, Lattice produces the graph within the algorithm itself, in a different way to the Graphics systems (successive lines of modification to the graph can be accumulated) or ggplot2.\nOn the other hand, the ggplot2 library is based on the graphics grammar (Wickham 2011), and produces the graph using a single command line that combines overlapping layers, similar to image manipulation applications (e.g. Inkscape, Gimp, Corel Draw, Photoshop). This way, it is possible to change each item of the graph in its specific layers (theme, coordinates, facets, statistics, geometry, aesthetics, data). Exemplifying the graphical result of the simulation curve above binding for Lattice and ggplot2:\n\n# The lattice and ggplot2 systems\n\n# Data simulation\n\nset.seed(20160227) # establishes seed for random number generation\nL &lt;- seq(0, 50, 1)\nPL &lt;- ((runif(1, 10, 20) * L) / (runif(1, 0, 10) + L)) + rnorm(51, 0, 1)\n# 1. runif(n,min,max); when without attributes, min=0 and max=1 are considered\n# 2. rnorm(no. points, mean, deviation) - random error of normal distribution\n\n# Graph production with Lattice system\nlibrary(lattice)\nxyplot(PL ~ L)\n\n\n\n\n\n\n\n# Graph production with ggplot2 system\nlibrary(ggplot2)\nqplot(L, PL)\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\n\n\n\n\nSince the perception of peculiarities of graphic systems is better revealed with more elaborate data, the following illustrations will use the ‘Puromycin’ data set, which is part of the ‘R’ ‘datasets’ library. The data show the speed of enzymatic reaction on a substrate in cells treated and not treated with puromycin.\nThe code below returns the plot, non-linear adjustment and results obtained with the standard Graphics library, and was extracted from the dataset documentation itself.\n\nlibrary(datasets)\n\n# The base system `graphics`\n\nplot(rate ~ conc,\n data = Puromycin, las = 1,\n xlab = \"[S], mM\",\n ylab = \"v(count/min/min)\",\n pch = as.integer(Puromycin$state),\n col = as.integer(Puromycin$state),\n main = \"Adjustment Illustration With Graphics\"\n)\n\n## Adjustment of the Michaelis-Mentem equation\nfm1 &lt;- nls(rate ~ Vm * conc / (K + conc),\n data = Puromycin,\n subset = state == \"treated\",\n start = c(Vm = 200, K = 0.05)\n)\nfm2 &lt;- nls(rate ~ Vm * conc / (K + conc),\n data = Puromycin,\n subset = state == \"untreated\",\n start = c(Vm = 160, K = 0.05)\n)\nsummary(fm1)\n\n\nFormula: rate ~ Vm * conc/(K + conc)\n\nParameters:\n    Estimate Std. Error t value Pr(&gt;|t|)    \nVm 2.127e+02  6.947e+00  30.615 3.24e-11 ***\nK  6.412e-02  8.281e-03   7.743 1.57e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 10.93 on 10 degrees of freedom\n\nNumber of iterations to convergence: 5 \nAchieved convergence tolerance: 8.768e-06\n\nsummary(fm2)\n\n\nFormula: rate ~ Vm * conc/(K + conc)\n\nParameters:\n    Estimate Std. Error t value Pr(&gt;|t|)    \nVm 1.603e+02  6.480e+00  24.734 1.38e-09 ***\nK  4.771e-02  7.782e-03   6.131 0.000173 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 9.773 on 9 degrees of freedom\n\nNumber of iterations to convergence: 5 \nAchieved convergence tolerance: 4.473e-06\n\n## Adding adjustment lines to the plot\nconc &lt;- seq(0, 1.2, length.out = 101)\nlines(conc, predict(fm1, list(conc = conc)), lty = 1, col = 1)\nlines(conc, predict(fm2, list(conc = conc)), lty = 2, col = 2)\nlegend(0.8, 120, levels(Puromycin$state),\n col = 1:2, lty = 1:2, pch = 1:2\n)\n\n\n\n\nPlotting and analysis with graphics.\n\n\n\n\nThe ggplot2 system, in turn, requires that the commands be listed in juxtaposed layers interspersed with the “+” sign, as follows:\n\n# Plot and analysis with ggplot2\nlibrary(datasets)\np &lt;- ggplot(data = Puromycin, aes(conc, rate, color = state)) +\ngeom_point() +\ngeom_smooth(\nmethod = \"nls\",\nformula = y ~ Vm * x / (Km + x),\nmethod.args = list(start = list(Vm = 200, Km = 0.1)),\nse = FALSE\n) # expression that defines the plot\np # variable that displays the plot\n\n\n\n\nPlotting and analysis with ggplot2.\n\n\n\n\nNote the fewer instructions in the script to produce the graph. In addition, and unlike Graphics, ggplot2 allows you to add layers to the main command line, and display multivariate data in panels (‘facet_grid’ and ‘facet_wrap’ functions), without the need to use the ‘mfrow’ or ‘mfcol’ command seen in the chapter, as follows:\n\np + facet_grid(rows = vars(state))\n\n\n\n\nPlotting and analysis with ggplot2 - panels (faceting).\n\n\n\n\nLattice also has a savings in instructions compared to Graphics. By disregarding the statistical adjustment, the groups can be displayed simply using the formula:\n\\[\nxyplot(y \\sim x~|~ groups = z)\n\\tag{8.7}\\]\n\nlibrary(lattice)\nxyplot(rate ~ conc, data = Puromycin, groups = state)\n\n\n\n\n\n\n\n\nAnd for the representation of non-linear fits:\n\n# A graph with dataset for lattice\n\nlibrary(nlme)\nn1 &lt;- nlsList(rate ~ Vmax * conc / (Km + conc) | state,\ndata = Puromycin, start = list(Vmax = 200, Km = 0.1))\nsummary(n1)\nxyplot(rate ~ conc,\ngroups = state, data =\nPuromycin\n) +\nlayer(panel.curve(Vmax[1] * x / (Km[1] + x), col = 1),\ndata = as.list(coef(n1))\n) +\nlayer(panel.curve(Vmax[2] * x / (Km[2] + x), col = 2),\ndata = as.list(coef(n1))\n)\n\nThe Lattice library also allows panel presentation; Unlike ggplot2, however, the graph is generated algorithmically, without the need for overlapping commands:\n\n# Nonlinear plotting and analysis with lattice\n\nlibrary(nlme) # package that allows nonlinear regression with subgroups\nnonlinLatt &lt;- nlsList(rate ~ Vmax * conc /\n(Km + conc) | state,\nstart = list(Vmax = 200, Km = 0.1), data = Puromycin)\nsummary(nonlinLatt)\n\nCall:\n  Model: rate ~ Vmax * conc/(Km + conc) | state \n   Data: Puromycin \n\nCoefficients:\n   Vmax \n          Estimate Std. Error  t value     Pr(&gt;|t|)\ntreated   212.6836   6.608088 32.18535 3.241151e-11\nuntreated 160.2800   6.896011 23.24242 1.384612e-09\n   Km \n            Estimate  Std. Error  t value     Pr(&gt;|t|)\ntreated   0.06412110 0.007876774 8.140529 0.0000156514\nuntreated 0.04770812 0.008281147 5.761052 0.0001727056\n\nResidual standard error: 10.40003 on 19 degrees of freedom\n\nxyplot(rate + fitted(nonlinLatt) ~ conc | state,\ndata = Puromycin,\ntype = c(\"p\", \"l\"), distribute.type = TRUE, col.line = \"red\",\nylab = \"rate\"\n)\n\n\n\n\nPlotting and analysis with Lattice - external fitting and panels.\n\n\n\n\nOf the many differences between the ggplot2 and Lattice packages, there is one that is worth highlighting. As seen above, ggplot2 performs the non-linear fit within the graph generation command line, while Lattice allows it to be done offline. This is inherent to ggplot2, a library designed for producing graphs, and not for computational analysis. Thus, the algorithm that allows the non-linear fit by ggplot2, although it is the same ‘nls’ already used, does not express its results explicitly (although there are ways to “fish” for them using other packages).\nIn a way, although Lattice requires a less intuitive learning curve, it allows the use of previously obtained statistical results for inclusion in the plotting algorithm. This is advantageous when other statistical algorithms are desired for fit, as above, or even their flexibility, in addition to the ‘nls’ included in ggplot2. However, Lattice also allows you to include the adjustment line within the algorithm itself, as follows:\n\n# Nonlinear fitting in panels (Lattice)\n\nxyplot(rate ~ conc | state,\ndata = Puromycin,\npanel = function(x, y, ...) {\npanel.xyplot(x, y, ...)\nn3 &lt;- nls(y ~ Vmax * x / (Km + x), data = Puromycin,\nstart = list(Vmax = 200, Km = 0.1))\npanel.lines(seq(0.02, 1.1, 0.02),\npredict(n3, newdata = data.frame(x = seq(0.02, 1.1, 0.02))),\ncol.line = 2)\n},\nxlab = \"conc\", ylab = \"rate\"\n)\n\n\n\n\nPlotting and analysis with Lattice - internal adjustment and panels.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Molecular interaction</span>"
    ]
  },
  {
    "objectID": "binding_en.html#numerical-solution-for-the-equilibrium-of-ligand-protein-complexes",
    "href": "binding_en.html#numerical-solution-for-the-equilibrium-of-ligand-protein-complexes",
    "title": "8  Molecular interaction",
    "section": "8.5 Numerical Solution for the Equilibrium of Ligand-Protein Complexes",
    "text": "8.5 Numerical Solution for the Equilibrium of Ligand-Protein Complexes\nAs seen in the Amino Acids chapter, sometimes a numerical solution can be used when the analytical solution does not converge, or when we are faced with a more complex equation. In this sense, the formation of complexes discussed in this subtitle can also be treated by a numerical solution.\nUsually the treatment given to the numerical solution involves finding the roots of an equation or system of equations, that is:\n\\[\nF(x) = 0\n\\tag{8.8}\\]\n\\[\nP+L \\rightleftarrows PL\n\\\\\nKd = \\frac{[P][L]}{[PL]}\n\\\\\nSo,\\ [PL]=\\frac{[P][L]}{Kd}\n\\tag{8.9}\\]\n\\[\n\\begin{cases}\n[Pt] = [P]+[PL] = [P]+\\frac{[P][L]}{Kd}\\\\\n[Lt] = [L]+[PL] = [L]+\\frac{[P][L]}{Kd}\n\\end{cases}\\\n\\tag{8.10}\\]\nThus, we have a system of linear equations in the parameters ([P] free, [L] free, and complex [PL]) that can be solved by R in several ways, one of which is by the minimization function rootSolve:\n\n# Calculation of L, P, and PL in biomolecular interaction for 1 set of sites\n# with the same affinity\nlibrary(rootSolve)\nPt &lt;- 1\nLt &lt;- 10\nKd &lt;- 4\n\n# Model\nmodel &lt;- function(x) c(x[1] + (x[1] * x[2]) / Kd - Pt, x[2] +\n(x[1] * x[2]) / Kd - Lt, Pt - x[1] - x[3])\n# the model above must contain a list of equations whose equality is zero,\n# that is, f(x)=0\n(ss &lt;- multiroot(model, c(1, 1, 1))) # command to execute\n\n$root\n[1] 0.3007353 9.3007353 0.6992647\n\n$f.root\n[1] 5.466137e-08 5.463051e-08 5.191070e-12\n\n$iter\n[1] 5\n\n$estim.precis\n[1] 3.643236e-08\n\n# rootSolve (seeds for the algorithm)\n\nThus, the resulting values ​​(f.root) when [Lt] = 10 are presented as [P] = 0.3, [L] = 9.3 and [PL] = 0.7.\nOther numerical solutions allow greater control over the algorithm used, such as the optim function of R (solution search limits, use of vectors, for example). For this, the same situation above will be exemplified, although presenting a variation of the formalism that relates P, L and PL :\n\\[\n\\begin{cases}\n[PL] = [Pt]-[L]\\\\\n[PL] = [Lt]-[L]\\\\\n[P]*[L]=Kd*[PL]\n\\end{cases}\\\n\\tag{8.11}\\]\nIn this way, a quadratic relation can be constructed involving the three unknowns:\n\\[\n([Pt]-[L]-[PL])^2 + ([Lt]-[L]-[PL])^2 + ([P]*[L]-Kd*[PL])^2\n\\tag{8.12}\\]\nApplying the optim minimization algorithm of R:\n\n# Calculation of L, P, PL in interaction for 1 site\n\nmodel2 &lt;- function(x, Pt, Lt, K) {\nL &lt;- x[1]\nP &lt;- x[2]\nPL &lt;- x[3]\n(Pt - P - PL)^2 + (Lt - L - PL)^2 + (P * L - Kd * PL)^2\n} # function declaration\nPt &lt;- 1\nLt &lt;- 10\nKd &lt;- 4 # function parameters\nsol2num &lt;- optim(c(0.5, 1, .5), model2, method = \"L-BFGS-B\",\nlower = c(0, 0, 0), upper = c(Lt, Pt, Pt), Pt = Pt, Lt = Lt)\n# BFGS method allows bounds (lower, upper)\nsol2num$par # LF, PF, PL calculated\n\n[1] 9.3007349 0.3007355 0.6992652\n\n\nNote that these are the same results as before, although with greater control over the solution. Now we can use this minimization to create a vector of solutions for the three quantities, as follows:\n\n# Function declaration\nbind1 &lt;- function(x, Pt, Lt, Kd) {\nL &lt;- x[1]\nP &lt;- x[2]\nPL &lt;- x[3]\n(Pt - P - PL)^2 + (Lt - L - PL)^2 + (P * L - Kd * PL)^2\n}\n\n# Function parameters\nPt &lt;- 1\nLt &lt;- c(5, 10, 20)\nKd &lt;- 4\n\n# Minimization (parameters for the above function to return zero)\ny &lt;- function(i) {\noptim(c(1, 1, 1), bind1,\nmethod =\n\"L-BFGS-B\", lower = c(0, 0, 0), upper = c(\nLt[i], Pt,\n Pt\n ), Lt = Lt[i], Pt = Pt, Kd = Kd\n )\n}\n\n# Results in array\nypar &lt;- function(i) y(i)$par\nyp &lt;- matrix(\n nrow = length(Lt), ncol = 2 + length(Kd),\n byrow = T\n)\nfor (i in 1:length(Lt)) yp[i, ] &lt;- y(i)$par\ncolnames(yp) &lt;- c(\"L\", \"P\", \"PL\")\nrownames(yp) &lt;- c(\"5\", \"10\", \"20\")\nyp\n\n           L         P        PL\n5   4.472136 0.4721359 0.5278640\n10  9.300736 0.3007344 0.6992634\n20 19.172624 0.1726180 0.8273844",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Molecular interaction</span>"
    ]
  },
  {
    "objectID": "binding_en.html#ligand-protein-interaction-kinetics-and-numerical-solution",
    "href": "binding_en.html#ligand-protein-interaction-kinetics-and-numerical-solution",
    "title": "8  Molecular interaction",
    "section": "8.6 Ligand-Protein Interaction Kinetics and Numerical Solution",
    "text": "8.6 Ligand-Protein Interaction Kinetics and Numerical Solution\nUnder the same principle of the numerical solution presented in the previous item for the equilibrium of the ligand-protein interaction, R allows a solution of the same nature for the kinetics of the formation of the complexes, that is, the levels of P, L and PL observed in time. In this case, other relations can be developed from Equação 8.1. Assuming that in equilibrium the kinetic rates of k\\(_{on}\\) and k\\(_{off}\\) are equal (steady-state), one can relate some differential equations for the association, as well as for the dissociation of the complexes:\n\\[\nFor \\, a\\, association:\n\\begin{cases}\n\\frac{d[PL]}{dt} = k_{on}*[L]*[P]\\\\\n\\frac{d[L]}{dt} = -k_{on}*[L]*[P]\\\\\n\\frac{d[P]}{dt} = -k_{on}*[L]*[P]\n\\end{cases}\n\\tag{8.13}\\]\n\\[\nFor \\, a\\, dissociation:\n\\begin{cases}\n\\frac{d[PL]}{dt} = -k_{off}*[PL]\\\\\n\\frac{d[L]}{dt} = k_{off}*[PL]\\\\\n\\frac{d[P]}{dt} = k_{off}*[PL]\n\\end{cases}\n\\tag{8.14}\\]\nThus, the resulting overall rates for each quantity (net rate) will involve the sum of the association and dissociation rates of each:\n\\[\nNet \\, rates:\n\\begin{cases}\n\\frac{d[PL]}{dt} = k_{on}*[L]*[P]-k_{off}*[PL]\\\\\n\\frac{d[L]}{dt} = -k_{on}*[L]*[P]+k_{off}*[PL]\\\\\n\\frac{d[P]}{dt} = -k_{on}*[L]*[P]+k_{off}*[PL]\n\\end{cases}\n\\tag{8.15}\\]\nThe solution to this final system of differential equations (net rates) involves solving for the variation of each quantity (\\(\\Delta\\)x) in a given time interval (\\(\\Delta\\)t), such that:\n\\[\n\\Delta x=f(x)*\\Delta t\n\\tag{8.16}\\]\nTo do this, it is necessary to use an R library that allows the solution of a system of differential equations. Among the many solutions (odeintr, pracma, rODE), the use of the deSolve library, which uses a function for system integration by the Runge-Kutta 4th-order algorithm, is recommended. order:\n\n# Kinetics of ligand-protein interactions for 1 set of sites\nlibrary(deSolve)\n\n# Experimental conditions\ntime &lt;- seq(0, 100) # time interval\nparms &lt;- c(kon = 0.02, koff = 0.001) # steady state parameters\n# of the interaction (uM^-1*s^-1 and s^-1, respectively)\nval.inic &lt;- c(L = 0.8, P = 1, PL = 0) # initial values, uM\n\n# System integration by Runge-Kutta of 4th order\nsolNumKin &lt;- function(t, x, parms) {\n# parameter list definition\nL &lt;- x[1] # ligand\nP &lt;- x[2] # protein\nPL &lt;- x[3] # complex\n\nwith(as.list(parms), {\n# differential equation list definition\ndL &lt;- -kon * L * P + koff * PL\ndP &lt;- -kon * L * P + koff * PL\ndPL &lt;- kon * L * P - koff * PL\nres &lt;- c(dL, dP, dPL)\nlist(res)\n})\n}\n\nsol.rk4 &lt;- as.data.frame(rk4(\nval.inic, time, solNumKin,\nparms\n)) # routine for Runge-Kutta 4a. order\n\n# Chart\nplot(sol.rk4$time, sol.rk4$L, type = \"l\", xlab = \"time\",\n ylab = \"[compound], uM\")\nlegend(\"topright\", c(\"L\", \"P\", \"PL\"),\n text.col = c(\"black\", \"red\", \"blue\"), bty = \"n\", lty = c(1, 2, 3))\nlines(sol.rk4$time, sol.rk4$P, type = \"l\", lty = 2, col = 2, lwd = 1.5)\nlines(sol.rk4$time, sol.rk4$PL, type = \"l\", lty = 3, col = 3, lwd = 1.5)\n\n\n\n\nFree ligand and protein (L and P) as well as PL complex contents plotted over time according to the 4th order Runge-Kutta method for solving differential equations.\n\n\n\n\n\n\n\n\nDahlquist, FW. 1978. «[13] The meaning of scatchard and hill plots». Methods in enzymology 48: 270–99.\n\n\nParsons, DL, e JJ Vallner. 1978. «Theoretical models for cooperative binding—I. one-site creator of binding sites». Mathematical Biosciences 41 (3-4): 189–215.\n\n\nSarkar, Deepayan. 2008. Lattice: multivariate data visualization with R. Springer Science & Business Media.\n\n\nWickham, Hadley. 2011. «ggplot2». Wiley interdisciplinary reviews: computational statistics 3 (2): 180–85.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Molecular interaction</span>"
    ]
  },
  {
    "objectID": "acnucleic_en.html",
    "href": "acnucleic_en.html",
    "title": "9  Nucleic Acids",
    "section": "",
    "text": "9.1 Sequence Analysis\n# Conversion of alphabetic sequence to base vector\n\nlibrary(stringr)\nliso.nucl &lt;- \"GCAGTCCCGCTGTGTGTACGACACTGGCAACATGAGGTCTTTGCTAATCTTGGTGC\nTTTGCTTCCTGCCCCTGGCTGCTCTGGGGAAAGTCTTTGGACGATGTGAGCTGGCAGCGGCTATGAAGCG\nTCACGGACTTGATAACTATCGGGGATACAGCCTGGGAAACTGGGTGTGTGCCGCAAAATTCGAGAGTAAC\nTTCAACACCCAGGCTACAAACCGTAACACCGATGGGAGTACCGACTACGGAATCCTACAGATCAACAGCC\nGCTGGTGGTGCAACGATGGCAGGACCCCAGGCT CCAGGAACCTTGTGCAACATCCCGTGCTCAGCCCTGCT\nGAGCTCAGACATAACAGCGAGCGTGAACTGCGCGAAGAAGATCGTCAGCGATGGAAACGGCATGAACGCG\nTGGGTCGCCTGGCGCAACCGCTGCAAGGGCACCGACGTCCAGGCGTGGATCAGAGGCTGCCGGCTGTGAG\nGAGCTGCCGCGCCCGGCCCGCCCGCTGCACAGCCGGCCGCTTTGCGAGCGCGACGCTACCCGCTTGGCAG\nTTTTAAACGCATCCCTCATTAAAACGACTATACGCAAACGCC\"\n\nliso.nucl &lt;- unlist(strsplit(liso.nucl, \"\"))\n# converts a single-word gene sequence into separate nucleotides\nliso.nucl[1:100] # a sample of the result\n\n  [1] \"G\"  \"C\"  \"A\"  \"G\"  \"T\"  \"C\"  \"C\"  \"C\"  \"G\"  \"C\"  \"T\"  \"G\"  \"T\"  \"G\"  \"T\" \n [16] \"G\"  \"T\"  \"A\"  \"C\"  \"G\"  \"A\"  \"C\"  \"A\"  \"C\"  \"T\"  \"G\"  \"G\"  \"C\"  \"A\"  \"A\" \n [31] \"C\"  \"A\"  \"T\"  \"G\"  \"A\"  \"G\"  \"G\"  \"T\"  \"C\"  \"T\"  \"T\"  \"T\"  \"G\"  \"C\"  \"T\" \n [46] \"A\"  \"A\"  \"T\"  \"C\"  \"T\"  \"T\"  \"G\"  \"G\"  \"T\"  \"G\"  \"C\"  \"\\n\" \"T\"  \"T\"  \"T\" \n [61] \"G\"  \"C\"  \"T\"  \"T\"  \"C\"  \"C\"  \"T\"  \"G\"  \"C\"  \"C\"  \"C\"  \"C\"  \"T\"  \"G\"  \"G\" \n [76] \"C\"  \"T\"  \"G\"  \"C\"  \"T\"  \"C\"  \"T\"  \"G\"  \"G\"  \"G\"  \"G\"  \"A\"  \"A\"  \"A\"  \"G\" \n [91] \"T\"  \"C\"  \"T\"  \"T\"  \"T\"  \"G\"  \"G\"  \"A\"  \"C\"  \"G\" \n\nliso.nucl &lt;- liso.nucl[liso.nucl != \"\\n\"]\n# removes the line breaks from the previous result\nliso.nucl[1:100] # a sample of the result without the \"\\n\"\n\n  [1] \"G\" \"C\" \"A\" \"G\" \"T\" \"C\" \"C\" \"C\" \"G\" \"C\" \"T\" \"G\" \"T\" \"G\" \"T\" \"G\" \"T\" \"A\"\n [19] \"C\" \"G\" \"A\" \"C\" \"A\" \"C\" \"T\" \"G\" \"G\" \"C\" \"A\" \"A\" \"C\" \"A\" \"T\" \"G\" \"A\" \"G\"\n [37] \"G\" \"T\" \"C\" \"T\" \"T\" \"T\" \"G\" \"C\" \"T\" \"A\" \"A\" \"T\" \"C\" \"T\" \"T\" \"G\" \"G\" \"T\"\n [55] \"G\" \"C\" \"T\" \"T\" \"T\" \"G\" \"C\" \"T\" \"T\" \"C\" \"C\" \"T\" \"G\" \"C\" \"C\" \"C\" \"C\" \"T\"\n [73] \"G\" \"G\" \"C\" \"T\" \"G\" \"C\" \"T\" \"C\" \"T\" \"G\" \"G\" \"G\" \"G\" \"A\" \"A\" \"A\" \"G\" \"T\"\n [91] \"C\" \"T\" \"T\" \"T\" \"G\" \"G\" \"A\" \"C\" \"G\" \"A\"\n# Some manual calculations with the base sequence\n\nlength(liso.nucl[liso.nucl == \"A\"])\n\n[1] 133\n\n# quantifies the purine bases in the sequence\n\ntable(liso.nucl) # count of each nucleotide\n\nliso.nucl\n      A   C   G   T \n  1 133 173 174 109 \n\nlibrary(seqinr)\nliso.nucl2 &lt;- tolower(liso.nucl) # the seqinr library operates with\n\n# lowercase letters, requiring conversion of uppercase letters\n# obtained by FASTA\n# seqinr::count(liso.nucl2,1) # the same operation as above,\n\n# but with the seqinr library, and another call format\n\n# Other calculations\n# seqinr:: count(liso.nucl2, 1 )\n# seqinr::count(liso.nucl2,2) # content of dinucleotides\n# seqinr::count(lyso.nucl2,3) # trinucleotide content\nnucls &lt;- table(liso.nucl)\nGC &lt;- 100 * (nucls[2] + nucls[3]) / (nucls[1] + nucls[2] + nucls[3] + nucls[4])\ncat(\"GC content percentage in chicken lysozyme: \", round(GC, 3))\n\nGC content percentage in chicken lysozyme:  63.617\n\nGC(liso.nucl) * 100 # the same command as before, but with the seqinr library\n\n[1] 58.91341\n\n# count.lyso &lt;- count(lyso.nucl2,2)\n#\n# barplot(sort(count.lyso)) # bar graph of dinucleotide content\n# sorted by frequency\n\n# Nucleotide sequence conversion to numeric\nliso.nucl.numer &lt;- gsub(\"T\", \"4\", gsub(\n\"G\", \"3\",\ngsub(\"C\", \"2\", gsub(\"A\", \"1\", liso.nucl))\n)) # replace bases with values\nliso.nucl.numer2 &lt;- as.numeric(liso.nucl.numer)\nliso.nucl.numer2[1:100] # first 100 values ​​of the sequence\n\n  [1] 3 2 1 3 4 2 2 2 3 2 4 3 4 3 4 3 4 1 2 3 1 2 1 2 4 3 3 2 1 1 2 1 4 3 1 3 3\n [38] 4 2 4 4 4 3 2 4 1 1 4 2 4 4 3 3 4 3 2 4 4 4 3 2 4 4 2 2 4 3 2 2 2 2 4 3 3\n [75] 2 4 3 2 4 2 4 3 3 3 3 1 1 1 3 4 2 4 4 4 3 3 1 2 3 1\n\n# Note: can also be obtained by the s2n and n2s functions of the seqinr package\n\nseq.liso &lt;- seq(1:length(liso.nucl))\nplot(seq.liso, as.vector(liso.nucl.numer2),\ntype = \"l\",\nxlim = c(100, 300), main = \"Sequence of bases between residues 100 to 300\",\nsub = \"A=1;C=2;G=3;T=4\"\n)\n\n\n\n\n\n\n\n# Obtaining complementary sequence\ncomp.liso.nucl &lt;- seqinr::comp(liso.nucl)\nhead(seqinr::c2s(comp.liso.nucl), 50) # shows the first\n\n[1] \"cgtcagggcgacacacatgctgtgaccgttgtactccagaaacgattagaaccacgaaacgaaggacggggaccgacgagacccctttcagaaacctgctacactcgaccgtcgccgatacttcgcagtgcctgaactattgatagcccctatgtcggaccctttgacccacacacggcgttttaagctctcattgaagttgtgggtccgatgtttggcattgtggctaccctcatggctgatgccttaggatgtctagttgtcggcgaccaccacgttgctaccgtcctggggtccgaNAggtccttggaacacgttgtagggcacgagtcgggacgactcgagtctgtattgtcgctcgcacttgacgcgcttcttctagcagtcgctacctttgccgtacttgcgcacccagcggaccgcgttggcgacgttcccgtggctgcaggtccgcacctagtctccgacggccgacactcctcgacggcgcgggccgggcgggcgacgtgtcggccggcgaaacgctcgcgctgcgatgggcgaaccgtcaaaatttgcgtagggagtaattttgctgatatgcgtttgcgg\"\n\n# 50 complementary nucleotides",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Nucleic Acids</span>"
    ]
  },
  {
    "objectID": "acnucleic_en.html#acNucl",
    "href": "acnucleic_en.html#acNucl",
    "title": "9  Nucleic Acids",
    "section": "",
    "text": "Nucleic acids can be considered as alphabetic sequences of 1 letter (bases), 2 letters (dinucleotide), or 3 letters (codon). Taking the example of chicken lysozyme:\n\nAccess the NCBI - National Center for Biotechnology Information database 1;\n\n\nSelect the Nucleotide database;\nEnter the sequence of interest; ex: “hen egg” lysozyme”;\nSelect LYZF1 (or the NCBI sequence reference: NM_205281.2); Note: With the reference number, you can access the desired content from a simple Google search.\nSearch for the sequence referenced in FASTA\nThe site will display the nucleotide sequence for lysozyme, which can be copied/pasted into R, or exported as a file in “Send to….File”.\n\nNow you need to convert this sequence of letters (string) into a base vector that can be read by R, and omitting the line break. This can be speeded up with the seqinr or TmCalculator package using the s2c function (converts string into a vector of strings; c2s does the opposite). Or also with the package stringr:\n\nWith the gene sequence in hand, one can evaluate a wide range of properties or manipulate the base vector, as referenced in some R packages (seqinr, DNASeqtest, haplotypes, rDNAse). You can also perform some simpler manipulation for the selected gene, as follows:\n\nOther sequence manipulations, such as GC pair content, dinucleotide sequence graph, conversion of the base sequence into a numeric sequence and its plotting, and obtaining the complementary base sequence, for example, can be obtained by:",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Nucleic Acids</span>"
    ]
  },
  {
    "objectID": "acnucleic_en.html#dna-thermostability",
    "href": "acnucleic_en.html#dna-thermostability",
    "title": "9  Nucleic Acids",
    "section": "9.2 DNA thermostability",
    "text": "9.2 DNA thermostability\nRegarding the physicochemical properties of nucleic acids, the relationship between the thermostability of duplex DNA and the GC pair content is well known, as explained by the empirical relationship (Creighton et al. 2010):\n\\[\nTm=(81.5+16.6*log(\\frac{[Na^+]}{1+0.7*[Na^+]})+41*f_{GC}-\\frac{500}{L}-0.63\\%_f)\n\\tag{9.1}\\]\nWhere [Na\\(^{+}\\)] represents the molar concentration of sodium, f\\(_{GC}\\) the fraction of GC pairs in the sequence, L its length, and %\\(_{f}\\) the formamide content.\nIn this way, it is possible to predict the value of Tm (“melting temperature”) that indexes the thermostability of a polynucleotide sequence as a function of the salt content. Illustrating a comparison between the sequence of chicken and human lysozyme (NCBI ref. NC_000012.12), in the absence of formamide:\n\n# Comparison of denaturation curves\n\n# For chicken lysozyme:\ngc.teor &lt;- seqinr::GC(liso.nucl) # GC pair content of lysozyme\n\nNa.conc &lt;- seq(0.005, 0.2, 0.001) # NaCl concentration, mmol/L\n\nTm.Na &lt;- (81.5 + 16.6 * log10(Na.conc / (1 + 0.7 * Na.conc)) +\n41 * gc.teor - 500 / length(liso.nucl))\n# Tm value for chicken\n\n# For human lysozyme\n\nliso.nucl.h &lt;-\n\"AGCCTAGCACTCTGACCTAGCAGTCAACATGAAGGCTCTCATTGTTCTGGGGCTTGTCCTCCTTTCTGTT\nACGGTCCAGGCAAGGTCTTTGAAAGGTGTGAGTTGGCCAGAACTCTGAAAGATTGGGAATGGATGGCT\nACAGGGGAATCAGCCTAGCAAACTGTAAGTCTACTCTCCATAATTCCAGAGAATTAGCTACGTATGGAAC\nAGACACTAGGAGAGAAGGAAGAAGAAGAAGGG GCTTTGAGTGAATAGATGTTTTATTTCTTTGTGGGTTTT\nGTATACTTACAATGGCTAAAAACATCAGTTTGGTTCTTTATAACCAGAGATACCCGATAAAGGAATACGG\nGCATGGCAGGGGAAAATTCCATTCTAAGTAAAACAGGACCTGTTGTACTGTTCTAGTGCTAGGAAGTTTG\nCTGGGTGCCTGAGATTCAATGGCACATGTAAGCTGACTGAAAGATACATTTGAGGACCTGGCAGAGC TCT\nCTCAAGTCCTTGGTATGTGACTCCAGTTATTTCCCATTTTGAACTTGGGCTCTGAGAGCCTAGGTGATG\nCAGTATTTTTCTTGTCTTCAAGTCCCCTGCCGTGATGTGGGATTTTTATTTTTATTTTTATTTTATTTTA\nTTTTATTTTTAAAGACAGTCTCACTGTGTGGCCCAGGCTGGAGTGCAGTGGCATGATCTCAGCTCACTGC\nAACCTCTGCCTTCTGGGCTCAAGTGATTCT CGTGCTTCAGCCTTCTGAGTAGCTGTGACTACAGGTGTGT\nACCACCACACCCAGCTAATTTTTTGTATTTTCAGTACAGATGGGGTTTCACCATGTTGGCCAAGCTGGTC\nTTGAACTCCTGGCCTCAAATGATCTGCCCACCTCAGCCTCCCAAAGTGGTAGGATTACAGGTGTGAACCA\nCTGCACCCAGCCGACATGGGATTTTTAACAGTGATGTTTTTAAAGAATATATTGAATTCCCTACA CAAGA\nGCAGTAGGAACCTAGTTCCCTTCAGTCACTCTTTGTATAGGATCCGAAACTCAGCATGAAATGTTTTA\nTTATTTTTATCTACTCTACTTGATTAACTATCTTTCATTTTCTCCCACACAATTCAAGATGTGCCATGAG\nGAAAAGTTATTTTATAGTTTAGTACATAGTTTGTCGATGTAATAATCTCTGTAGTTTTCAGATTGAATTCA\nGACATTTCCCCTCAATAGCTATTTTTGA ATGAATGAGTGAAGGGATGAATCACGGAATAGTCTTGTTTT\nCAAGATTCTAACTTGATATCCAAATTCACCTTTAGATATTATAAGAAAATTTCTATCAGAAAATCCTTAT\nGTTTTTCTGATTAAAAAAAGCATTTTTCCATCAGCCTATGTATCTGCTATGAATTTACAAAATCTACTCA\nACAGCTCTGTTGATTTTTCTGTTCTTGGCTGAATGTTGCCTGAGGGATGGGAGCACGGGAAGG GTAAAAG\nCAATGGAACAAACATGTATTTTAATATTTTAAAAGTATGTTATATTGTTCGTTGGTGTTACAAGATGATT\nTGCATTACAAAAGGATTCTCTTACAAGTCCCTTATCTTAACACTAAAGTGCTAAGATATTTTATAAGTAA\nATCTTTATACTTATAAAACAAATCAGTAAAATAGAAGTAGCTAAGTAGAACTGATTTTGCTATAGAGTAT\nAAGTCACTTAGTGTTGCTGTTTATTAC TAAAAATAAGTTCTTTTCAGGGATGTGTTTGGCCAAATGGGAG\nAGTGGTTACAACACACGAGCTACAAACTACAATGCTGGAGACAGAAGCACTGATTATGGGATATTTCAGA\nTCAATAGCCGCTACTGGTGTAATGATGGCAAAACCCCAGGAGCAGTTAATGCCTGTCATTTATCCTGCAG\nTGGTAAGACAAGCTAATATTTGACCAATCTGGTTATACTTACAAGAATTGAGACTCAATACA AATGAAAA\nAGCCTTGAAAGGTTCATGAGGGACCTAGAAAAACTACATCTCAACTTCCAGAAAGTCATTATTATTTTCC\nTCATAATTCCCTGAGTAAGAAATTAAAGAAGTGGTATCATAAAAGGTTGATGTTTTTTAATATACAGAAG\nTTTCTGGAATGACCTATTAATTTACTGTCAATGCCTTACTGATGCTTTGTCCAGAACAATGCCATTGCT\nCCTGCTTACTTTGGGGAGGGTTTTGG GATAATTTAGTTGTATGGTCCTTTTTCAATTGTTTTACTTTTTTT\nTTTATGAAATGTTCTAAATGTATAGAAAATTAGAGACATTAGTATAATAAACAGCCATATGCCCATTATG\nCACTTTAAAAGTTGTTAACATTTTGCCATAGTTGCTTCTTCTATGCCTTTTTTTTTTTTTTTTTTTTTTT\nTTTTTTTTTGCTGAGAGTTTTTTGTTTGGTTTTGTTTTGTTTTATTTTGAGACAGGGTCT CCCTGTCCCC\nAGGCTGTAGTGCAGTGGCACCATCACAGCTCACTGCAGCCTCAAGTGATCATCCCACCACAGCCTCCCCAA\nGTAGCTGGACTACAGGTGTGCACCACCATGCCTGGCAAATTTTTGAAATTTTTAGTACAGGCAAATTCT\nGTGTTGCCCAGGCTGGTCTTGAACTCCTGAGTTCAAGCAATCTTCCCACCTCAGCCTCCTTAAGTGCTGG\nAATTACAGGCGTTAGCCACTGTA CCTGGCTACTGCTGAGAGACTTTTAAGTGAATTAGGAACATGATGAT\nATTCCATTTCTAAATTCTTTAGTTTACATCTTCAAAAAATACAGTTCCTGTAGAATTATTATTGTAAATA\nACAAATTAACTTAAGGATTTATTTATTTGGAGTGAAAACAAATATTTTACTGAACTCATAAAAATAGAAAT\nACCATGTGGAATCCTCAGTGTCAAAAATATTGCAGAAATCTTGCAAAGTTGATATTATTAAATTGTTAAA\nTATTAAAATTCCCAATAAAGAACATTAATCTTATTTCTAAAATCCAGTTAATTAAAAAAATTTATATTAT\nATAATAATATTTGGTCATTAAAATAAAAATTAGAAAATACAAATAAGAAAAATAACACCCATAATCTTACT\nACCCAGAGGTTTATAACCATGGGTAAATTCTGGTATATTCTTCCAGAATGTATATCAATCATGTGTAT\nGAATGTTAAATTATATCATAC ACATATAAACCCACATACAAACATGTAAATACTGTGTGCTTTTGCAAAA\nATTAAATTGTATTATACACACGGCTTTACAATTTGCTTCTTACACACAAAATTATTTGCATGTCAGCAA\nATACAAATCGGTTTTTAATGATCTTTTGCTCCATTTTCCAGATGAGAAAAAAATACAAATCTGTATCATC\nATTTTAAAAGAATGACTAGAATTTTAATATATGAATATTCTATAATTTACTGATCCAATTGTTACTATTG\nAGCACTTAGGTTGTTTCCATTTTTCCCTCATAAATTGCTATGAATAGCTTTTTGTATACATCTTTGGGTG\nCATTTCTTATTTCTTTTGGATAAATTTTCAATAATAGAACTGCTGAGTAAAATATCACTAGGTGTTTTTT\nTACAGTGTCTAGTGCAAAGAAGACCTTTAATCATTTTGTTAATACTTCCAGAGCTTCCAATGACTTTGGT\nAAATGAAGAAAAAAATGCTT CATTTCATGCTGAATGGGAGAGAATGAAGAGAGTTTTCCCCAACAATTAC\nACATATATGGACTCATAGAAAATAATATCTTACCATTCTTTCCACAGCCTAACAGAAAAAAGCTGGCTAA\nACCTAAATTTAAAATAAAATATCTATTAAAGTTTTTATTCCTTACCACCTGTCTTTCAGCTTTGCTGCAA\nGATAACATCGCTGATGCTGTAGCTTGTGCAAAGAGGGTTGTCCGTGATCCACAAGGCATTAGAGCATGGT\nATGTTTTAAGTGTTAAAAGGGAAAACTATCTTACTCTACTGTTGATATATACAATGAGAGCAGACTTTTA\nAAGACCAAAGTATGCTAATGACACCTCAAAATTGCAGCTTTTGGCTTATGCTAAATGATGTATTACCTAC\nATCCTTGAAGAAACAATCTACTTTAACTGATCCAGAATCTTACTCTTTTACTCCTCAATTTATTTTAGGG\nGATTTCTAGAGTTTTAAGA TGCTTCACACTCTATCAGTTCCTTGTCATATCTTGAAATTCTTTTTAGAAT\nAAGTAAGTGTGGGCCGGGCACAGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGACCGAGGCAGATGG\nATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGCCTAACATGGCAAAACCCCATCTCCACTAAAAATACA\nAAAAATTAGCTGGGTGTGGTGGCAGGTGCCTGTAATCCCAGCCACTCGGGAGGCT GAGGCAGGAGACTTG\nCTTGAACCCGGGAGGTGGAGGTTGCAGAGGATTGCGCCATTGTACTTCAGCCTGGGCGACAGAGTGAGAC\nTCTGTCTCAAATAAATACATAAAAAATAAAATGTGGAATTCACTTTGCAGTTGCTGCTGTACAACGCACAT\nTACTCAATCTTTATGTTCGGCATTCTATGCTCTACTGAGAAATTTGGGTAGGAGTGAAGTATTTTGTATA\nCATATCTTCATTTAATAAAT AGCAATAGCTGGGTCTATCTTACTATTTTATCTATTGATAAAATATTTTG\nTTTCCCCAAGGAGTGCGAAGTATGTATATTACAATGAAGATATGTTTTAACCTTTCACCATTTGCTTCAT\nCTTTTTCTACAGGGTGGCATGGAGAAATCGTTGTCAAAACAGAGATGTCCGTCAGTATGTTCAAGGTTGT\nGGAGTGTAACTCCAGAATTTTCCTTCTTCAGCTCATTTTGTCTCTCTCACATTAAG GGAGTAGGAATTAA\nGTGAAAGGTCACACTACCATTATTTCCCCTTCAAACAAATAATATTTTTACAGAAGCAGGAGCAAAATAT\nGGCCTTTCTTCTAAGAGATATAATGTTCACTAATGTGGTTATTTTACATTAAGCCTACAACATTTTTCAG\nTTTGCAAATAGAACTAATACTGGTGAAAATTTACCTAAAACCTTGGTTATCAAATACATCTCCAGTACAT\nTCCGTTCTTTTTTTTTTTGAG ACAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCAATCTCGGC\nTCACTGCAACCTCCACCTCCCGGGTTCACGCCATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACG\nGGCGCCCGCCACCACGCCCGGCTAATTTTTTGTATTTTTAGTAGAGACAGGGTTTCACCGTGTTAGCCAG\nGATGGTCTCGATCTCCTGACCTTGTGATCCACCCACCTCGGCCTCCCAAAGTGCTGG GATTACAGGCGTG\nAGCCACTGCGCCCGGCCACATTCAGTTCTTATCAAAGAAATAACCCAGACTTAATCTTGAATGATACGAT\nTATGCCCAATATTAAGTAAAAAATATAAGAAAAGGTTATCTTAAATAGATCTTAGGCAAAATACCAGCTG\nATGAAGGCATCTGATGCCTTCATCTGTTCAGTCATCTCCAAAAACAGTAAAAATAACCACTTTTTGTTGG\nGCAATATGAAATTTTTAAAGGA GTAGAATACCAAATGATAGAAACAGACTGCCTGAATTGAGAATTTTGA\nTTTCTTAAAGTGTGTTTCTTTCTAAATTGCTGTTCCTTAATTTGATTAATTTAATTCATGTATTATGATT\nAAATCTGAGGCAGATGAGCTTACAAGTATTGAAATAATTACTAATTAATCACAAATGTGAAGTTATGCAT\nGATGTAAAAAATACAAACATTCTAATTAAAGGCTTTGCAACACA\"\n\nliso.nucl.h &lt;- unlist(strsplit(liso.nucl.h, \"\"))\n# convert gene sequence from a word into separate nucleotides\nliso.nucl.h &lt;- liso.nucl.h[liso.nucl.h != \"\\n\"]\n# remove line break from previous output\n\ngc.teor.h &lt;- seqinr::GC(liso.nucl.h) # GC pair content of human lysozyme\n\nTm.Na.h &lt;- (81.5 + 16.6 * log10(Na.conc / (1 + 0.7 * Na.conc)) +\n41 * gc.teor.h - 500 / length(liso.nucl.h))\n# Tm value for human\n\n# Simulation curves\nplot(Na.conc, Tm.Na,\ntype = \"l\", col = 2,\nxlab = \"[Na+], M\", ylab = \"Tm, oC\"\n)\nlines(Na.conc, Tm.Na.h, type = \"l\", col = 3)\nlegend(x = 0.13, y = 78, legend = c(\"chicken\", \"human\"),\ncol = c(2, 3), cex = 1, lty = c(1, 2))\n\n\n\n\nComparison between the simulated Tm curves for the nucleotide sequence of chicken lysozyme and human lysozyme, as a function of the NaCl content of the medium.\n\n\n\n\nNote how the difference in GC content has a direct effect on the thermostability of double-stranded DNA. One note: although the range of Tm values reported in the literature for lysozyme is around 74\\(^o\\)C, this value refers to the cooperative denaturation of the enzyme in aqueous solution, and not to the unfolding of its duplex DNA gene sequence.\n\n\n\n\nCreighton, Thomas E et al. 2010. biophysical chemistry of nucleic acids & proteins. Distributed by Gardners Books.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Nucleic Acids</span>"
    ]
  },
  {
    "objectID": "acnucleic_en.html#footnotes",
    "href": "acnucleic_en.html#footnotes",
    "title": "9  Nucleic Acids",
    "section": "",
    "text": "NCBI. https://www.ncbi.nlm.nih.gov/protein↩︎",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Nucleic Acids</span>"
    ]
  },
  {
    "objectID": "membranas_en.html",
    "href": "membranas_en.html",
    "title": "10  Biological membranes",
    "section": "",
    "text": "10.1 Critical micelle concentration (CMC)\n\\[\ny_1 = y_2 \\\\\na_1+b_1*x = a_2+b_2*x\\\\\na_1-a_2 = b_2*x-b_1*x\\\\\na_1-a_2 = x(b_2-b_1)\\\\\nx = \\frac{a_1-a_2}{b2-b1}\n\\tag{10.1}\\]\n# Determination of critical micelle concentration (CMC)\n\nconc &lt;- c(1e-5, 0.00179, 0.00357, 0.00527, 0.00881, 0.0106, 0.0141, 0.0159)\n\n# dye content (mol/L)\nA385 &lt;- c(0.003, 0.421, 0.712, 0.905, 1.09, 1.17, 1.41, 1.47)\n\n# absorbance at 385 nm\n\n# Graph\nplot(A385 ~ conc, xlab = \"[acid yellow 29]\", ylab = \"Abs 385\")\n\n# Linear fit for 2 data sets\n\n# 1st. set\nlinCmc1 &lt;- lm(A385 ~ conc, subset = (conc &lt; 0.007 & conc &gt; 0))\n# 1st linear fit with bounds\nabline(linCmc1, col = \"blue\", lty = \"dotted\") # regression line\n\n# 2nd set:\nlinCmc2 &lt;- lm(A385 ~ conc, subset = (conc &lt; 0.02 & conc &gt; 0.007))\n# 2nd linear fit with limits\nabline(linCmc2, col = \"blue\", lty = \"dotted\") # regression line\n\n\n\n\n\n\n\n# Calculation of CMC by automatic intersection of two lines:\ncmc_auto &lt;- abs((coef(linCmc2)[1] - coef(linCmc1)[1]) /\n(coef(linCmc1)[2] - coef(linCmc2)[2]))\nas.numeric(cmc_auto) # provides the cmc in mol/L\n\n[1] 0.004642773",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Biological membranes</span>"
    ]
  },
  {
    "objectID": "membranas_en.html#critical-micelle-concentration-cmc",
    "href": "membranas_en.html#critical-micelle-concentration-cmc",
    "title": "10  Biological membranes",
    "section": "",
    "text": "Critical micelle concentration refers to the minimum surfactant content above which it can reorganize into micelles or liposomes. It is widely used in the characterization of such compounds, such as biosurfactants in industry, and can be measured by several techniques, including surface tension, polarization fluorescence, turbidimetry and molecular absorption (photometry).\nIn general, the determination of cmc is obtained by the value of the surfactant concentration at the intersection point of two straight lines obtained by linear adjustment of the data at low and high analyte levels, as follows:\n\nThe intersection point can be obtained manually, using the locator command mentioned above, or automatically. In this case, the R example that illustrates this calculation is based on spectrophotometric results obtained for a dye, acid yellow 29 (Duff e Giles 1972).\n\nThe value found by the authors was 0.004 mol/L.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Biological membranes</span>"
    ]
  },
  {
    "objectID": "membranas_en.html#transport-in-membranes-and-chemiosmotic-theory",
    "href": "membranas_en.html#transport-in-membranes-and-chemiosmotic-theory",
    "title": "10  Biological membranes",
    "section": "10.2 Transport in membranes and Chemiosmotic Theory",
    "text": "10.2 Transport in membranes and Chemiosmotic Theory\nThe equilibrium transport of solutes by membranes involves a formalism that encompasses the electrochemical potential of the solutes involved, their concentrations (or activity), charges, electrical potentials and partial volumes in molar units. Despite this complexity, however, we can illustrate the transport of H\\(^{+}\\) ions in a simplified way, following the equation below:\n\\[\n\\Delta G_{transp}=2.303(RT*log\\frac{H^+_{in}}{H^+_{out}}) + z * F * \\Delta \\phi\n\\]\nWhere F represents Faraday’s constant, 96485 J\\(^{-1}\\)\\(V^{-1}\\)\\(mol^{-1}\\) (also represented as 1 mole of electrons), and z the charge of the ion, while \\(\\Delta\\)\\(\\phi\\) represents the variation in electric potential, and \\(\\Delta\\)pH the variation in the value of pH, both obtained by measurements between the internal (mitochondrial matrix) and external (intermembrane space) sides. H\\(^{+}\\)\\(_{in}\\) and H\\(^{+}\\)\\(_{out}\\) represent the proton content of the inner and outer side of the membrane, respectively.\nNow, considering the unitary charge of H\\(^{+}\\) and the definition for pH (-log H\\(^{+}\\)),\n\\[\n\\Delta G_{transp}=\\Delta \\phi * F-2.303RT*\\Delta pH\n\\]\nTangent to the transport of solutes and ions through cell membranes, it is possible to predict, for example, the content of ATP formed during oxidative phosphorylation that involves the return of H\\(^{+}\\) ions from the intermembrane space to the mitochondrial matrix. Illustrating, considering a value of \\(\\Delta\\)\\(\\phi\\) of 70 mV and a \\(\\Delta\\)pH of 1.4 for the measurements between the matrix and the mitochondrial intermembrane space, it is predicted that ATP will be obtained by the following relations, considering the energy of 31 kJ/mol of ATP:\n\n# Predicted ATP content during oxidative phosphorylation\n\nR &lt;- 8.341 # J/mol\nT &lt;- 298 # K\nF &lt;- 96485 # Faraday constant\nDphi &lt;- 70e-3 # variation of electrical potential in/out membranes\nDpH &lt;- -1.4 # variation of pH in/out membranes\nDG_transp &lt;- F * Dphi - 2.303 * R * T * DpH # transport equation\nDG_transp_4 &lt;- 4 * DG_transp # 4 mol of H+\n\n# Considering each mole of ATP for 31 kJ/mol...\nDG_transp_4 / 31e3\n\n[1] 1.905559\n\n\nTherefore, it is clear that 2 moles of ATP are produced under the conditions explained.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Biological membranes</span>"
    ]
  },
  {
    "objectID": "membranas_en.html#transport-proteins-in-membranes",
    "href": "membranas_en.html#transport-proteins-in-membranes",
    "title": "10  Biological membranes",
    "section": "10.3 Transport proteins in membranes",
    "text": "10.3 Transport proteins in membranes\nWhile protons such as H\\(^{+}\\) are transported according to their concentration gradient between the internal and external sides of membranes, other compounds and solutes depend on a transport protein, such as glucose and citric acid. In this case, the transport is not passive, but facilitated diffusion, and its kinetic behavior through the membrane obeys the Michaelis-Menten formalism as follows.\n\\[\nv_{transp}=\\frac{V_{max}*S_{out}}{K_{transp}+S_{out}}\n\\]\nWhere, similarly, V\\(_{max}\\) represents the maximum (or limit) transport speed of the substrate, S\\(_{out}\\) the substrate content transported, and K\\(_{transp}\\) the dissociation constant of the protein-substrate complex (or substrate concentration at half saturation of the transporter).\n\n\n\n\nDuff, DG, e CH Giles. 1972. «Spectrophotometric determination of the critical micelle concentration of surfactants». Journal of Colloid and Interface Science 41 (3): 407–14.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Biological membranes</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html",
    "href": "biotermodin_en.html",
    "title": "11  Biothermodynamics",
    "section": "",
    "text": "11.1 Bioenergetics\n\\[\n\\Delta G = \\Delta H - T * \\Delta S\n\\tag{11.1}\\]\n\\[\nN \\rightleftarrows D\n\\tag{11.2}\\]\n\\[\nK_{eq} = \\frac{[D]}{[N]}\n\\tag{11.3}\\]\n\\[\n\\Delta G = - R*T*ln(K_{eq})\n\\tag{11.4}\\]\nWhere \\(K_{eq}\\), [D], and [N] represent, respectively, the equilibrium constant for protein denaturation, as well as its concentrations in the denatured and native forms.\nAt \\(35^{o}\\)C: \\(\\Delta\\)G\\(_{desn}\\) = \\(\\Delta\\)H\\(_{desn}\\) - 308 * \\(\\Delta\\)S\\(_{desn}\\) = +4.4 kJ \\(mol^{-1}\\)\nAt \\(45^{o}\\)C: \\(\\Delta\\)G\\(_{desn}\\) = \\(\\Delta\\)H\\(_{desn}\\) - 318 * \\(\\Delta\\)S\\(_{desn}\\) = -5.2 kJ \\(mol^{-1}\\)\n\\[\na_{11}*x_1 + a_{12} * x_2 = b_1\n\\\\\na_{21}*x_1 + a_{22} * x_2 = b_2\n\\tag{11.5}\\]\nWhere \\(x_1\\) and \\(x_2\\) represent, respectively, \\(\\Delta\\)H\\(_{desn}\\) and \\(\\Delta\\)S\\(_{desn}\\).\n\\[\na_{11}*x_1 + a_{12} * x_2 = b_1\n\\\\\na_{21}*x_1 + a_{22} * x_2 = b_2\n\\tag{11.6}\\]\n\\[\nA = \\begin{bmatrix}\na_{11} & a_{12}\\\\\na_{21} & a_{22}\n\\end{bmatrix} ,\n\\]\n\\[\nx = \\begin{bmatrix}\nb_1\\\\\nb_2\n\\end{bmatrix} ,\n\\]\n\\[\nb = \\begin{bmatrix}\nx_1\\\\\nx_2\n\\end{bmatrix}\n\\]\n\\[\nA * x = b\n\\tag{11.7}\\]\n\\[\nx = A^{-1} * b\n\\tag{11.8}\\]",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html#sec-Bioenerg",
    "href": "biotermodin_en.html#sec-Bioenerg",
    "title": "11  Biothermodynamics",
    "section": "",
    "text": "While Kinetics deals with the flow of information involving a phenomenon, Thermodynamics works with the forces involved in it. These forces, called thermodynamic quantities, help to understand various biological phenomena, such as the equilibria listed below.\n\nStability of biopolymers;\nLigand-receptor interaction;\nTransport of biomolecules and ions;\nConformational changes in biomacromolecules;\nAssociation of biopolymers;\nElectron transfer in proteins;\nCombustion and synthesis of biomolecules;\nGeneration of metabolic energy.\n\nAlthough Thermodynamics is not responsible for explaining atomic theory, molecular mechanisms or reaction rates, its theoretical formalism allows us to evaluate the energy changes (enthalpy, entropy, and Gibbs energy) that occur between the initial and final states of a transformation. From these quantities, it is possible to sketch mechanistic models of the transformations involved, based on the empirical set of similar observations reported.\nThe Gibbs equation for the equilibrium that describes these quantities is:\n\nExamples of this are the transformations in the values ​​of \\(\\Delta\\)H and \\(\\Delta\\)S that can be extracted from a conformational transition that accompanies the thermal denaturation of a protein (Cooper 2004).\nTo do this, it is necessary to determine the value of \\(\\Delta\\)G of the phase transition, which can be done in several ways, and using equally diverse methodology. Thus, through spectroscopic measurements (molecular absorption, fluorescence, luminescence), hydrodynamic measurements (viscosity, sedimentation coefficient, osmotic pressure), electrochemical measurements (potentiometry, voltammetry), or biological activity measurements, among many others, it is possible to quantify the thermodynamic parameter \\(\\Delta\\)G. This, in turn, can be extracted from the following relations, considering a two-state transition:\n\n\n\n\nA quick look at Equação 11.22 makes it clear that this is a linear function with temperature. Thus, it is plausible to imagine a system in which the thermodynamic quantities above (\\(K_{eq}\\) and, consequently, \\(\\Delta\\)G) can be determined with temperature variation. Putting it into numbers:\n\n\nUnderstand that a solution to the problem involves solving the equations sequentially, subtracting one from the other to standardize an unknown (say, \\(\\Delta\\)S) that applied to the other equation will result in the second unknown (in this case, \\(\\Delta\\)H). Although plausible, this procedure is manual and loses value if we imagine a 3rd temperature tested for the protein denaturation in question.\nAnother solution, more practical and computational, involves solving the system of linear equations, as follows:\n\n\nIn this case, we can set up a matrix system such that:\n\nThat is,\n\n\n\nNow solve the values ​​of x (or \\(\\Delta\\)’s) linearly:\n\nUsing matrix algebra, solve Equação 13.2 for the values ​​of x:\n\nSince this is a system of linear equations, this solution has in itself the premise that the values ​​of \\(\\Delta\\)H and \\(\\Delta\\)S do not vary in the temperature range studied.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html#solution-of-a-system-of-linear-equations-in-r",
    "href": "biotermodin_en.html#solution-of-a-system-of-linear-equations-in-r",
    "title": "11  Biothermodynamics",
    "section": "11.2 Solution of a system of linear equations in R",
    "text": "11.2 Solution of a system of linear equations in R\nTo solve the problem from the previous section using R, we first define the matrix for A and the matrix for b such that:\n\\[\nA = \\begin{bmatrix}\n1 & -308\\\\\n1 & -318\n\\end{bmatrix} ,\n\\]\n\\[\nb = \\begin{bmatrix}\n+4.4\\\\\n-5.2\n\\end{bmatrix}\n\\]\nThus,\n\n# Definition of matrices\nA &lt;- matrix(c(1, -308, 1, -318), ncol = 2, byrow = TRUE) # matrix A;\n# the negative sign is due to the function having a negative slope\nb &lt;- matrix(c(4.4, -5.2), ncol = 1) # matrix b\n\nAccording to that presented in Equação 13.3, the matrix solution can be obtained by the solve command:\n\n# Matrix solution for linear system\nsolve(A) %*% b # # the %*% operation indicates the scalar product of two\n\n       [,1]\n[1,] 300.08\n[2,]   0.96\n\n# vectors (\"dot product\")\n\nIn this case, the thermodynamic parameters found were \\(\\Delta\\)H\\(_{desn}\\) = 300 kJ \\(mol^{-1}\\) and \\(\\Delta\\)S\\(_{desn}\\) = 960 J \\(mol^{-1}\\).\nNote the “%*%” notation for the multiplication of two matrices in the last line of the code. This is the cross multiplication or dot product of two matrices. Matrix multiplication is defined only for two dimensionally compatible matrices in a given order. This implies that the number of columns in the 1st matrix is ​​equal to the number of rows in the 2nd matrix. In this case, the resulting matrix will have the same number of rows as the 1st matrix and the same number of columns as the 2nd matrix. See the example:\n\\[\n\\begin{pmatrix}\n1 \\\\\n2 \\\\\n3 \\\\\n\\end{pmatrix} *\n\\begin{pmatrix}\n1 & 2 & 3 \\\\\n\\end{pmatrix}\n= \\begin{pmatrix}\n1 & 2 & 3 \\\\\n2 & 4 & 6 \\\\\n3 & 6 & 9 \\\\\n\\end{pmatrix}\n\\tag{11.9}\\]\nAnother observation should also be made regarding the matrix solution of linear systems. A quick reflection on the linear nature of Gibbs’ Equação 11.22 and its application to the solution of thermodynamic parameters for the system of linear equations above suggests that we could obtain other values ​​for \\(\\Delta\\)G from other tested temperatures. Assuming that there were, say, 5 or 6 values ​​of T with their respective values ​​of \\(\\Delta\\)G\\(_{desn}\\), and reinforcing the premise that the parameters \\(\\Delta\\)H\\(_{desn}\\) and \\(\\Delta\\)S\\(_{desn}\\) remained constant throughout the thermal range, we could easily conclude that it is a linear relationship of \\(\\Delta\\)G\\(_{desn}\\) as a function of \\(\\Delta\\)H\\(_{desn}\\) T.\nThus, as seen in the Enzymes chapter, we could solve for the parameters \\(\\Delta\\)H\\(_{desn}\\) and \\(\\Delta\\)SH\\(_{desn}\\) by linear fit. In fact, one of the Van’t Hoff expressions that define this linear relationship is:\n\\[\nln \\, K_{eq} = - \\frac{\\Delta H}{R} * \\frac{1}{T} + \\frac{\\Delta S}{R}\n\\tag{11.10}\\]\nAnother direct consequence is that any set of data pairs of dependent (y) and independent (x) variables, and that exhibit homogeneity of variances and normal distribution, as explained in the Enzymes chapter, can also be solved for in its parameters (intercept and slope) with the help of matrix algebra.\nIn fact, the linear adjustment matrix solution can be obtained from the relation below:\n\\[\n\\beta = (X^T \\; X)^{-1} \\; X^T*y\n\\tag{11.11}\\]\nTherefore, the linear adjustment illustrated by the Lineweaver-Burk equation from the Enzymes chapter can also be performed with the help of matrices, although some statistical indicators presented in the table generated by the lm function are extracted by other functions of the matrix/statistical calculation algorithm. In Equação 13.4 the term in parentheses involves the inversion operation of the matrix. In linear algebra there is no division operation for matrices, but only the multiplication of a matrix by a scalar or by the inverse of another. And even then, only if it is a square matrix. Thus, the term (X\\(^{T}\\) X)\\(^{-1}\\) can only be calculated with matrix inversion. In R this action is performed by the solve command.\nAs before, it is also vitally important that the matrix X containing the independent variable is created with unit values ​​on the left, as follows:\n\\[\nX = \\begin{bmatrix}\n1 & x_{1}\\\\\n1 & x_{2}\\\\\n1 & x_{3}\\\\\n... & ...\n\\end{bmatrix}\n\\]\nThus, the solution to the problem explained in the Lineweaver-Burk equation from the Enzymes chapter can be solved in a matrix as:\n\n# Matrix solution for the Lineweaver-Burk kinetic parameters\n\n# Repeating the data for the Lineweaver-Burk variables\nS &lt;- seq(0.1, 1, length.out = 20) # generates a sequence with 20 points\n# between 0 and 1 for substrate values\nVm &lt;- 10\nKm &lt;- 0.5 # kinetic parameters\nset.seed(1500) # establishes the same random seed as the direct graph\n# of Michaelis-Menten, for reproducibility of the points\nerror &lt;- runif(20, 0, 1) # command for uniform error (no. of points, min, max)\nv &lt;- Vm * S / (Km + S) + error # Michaelis-Menten equation\ninv.S &lt;- 1 / S # create variables for the double reciprocal\ninv.v &lt;- 1 / v\n\n# Creation of matrices A and b\nA2 &lt;- matrix(c(rep(1, 20), inv.S), nrow = 20, byrow = FALSE) # create matrix\n# with unit value required before the independent variable\nb2 &lt;- as.matrix(inv.v, nrow = 1, byrow = FALSE) # vector b\n\n# Matrix solution of the linear fit\nbeta &lt;- solve(t(A2) %*% A2) %*% t(A2) %*% b2\nbeta\n\n           [,1]\n[1,] 0.11363419\n[2,] 0.03277244\n\n\nNote that the intercept (\\(\\beta\\) 1) and slope (\\(\\beta\\) 2) values ​​are close to those found with the help of the lm function of R.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html#matrices-and-r",
    "href": "biotermodin_en.html#matrices-and-r",
    "title": "11  Biothermodynamics",
    "section": "11.3 Matrices and R",
    "text": "11.3 Matrices and R\nThe use of matrices in solving linear problems and non-linear is quite vast. In fact, a linear fit is solved computationally by the use of matrices, rather than by summations. Likewise, some algorithms for non-linear fit also implement matrix algebra in problem solving (Gauss-Newton, Levenberg-Marquadt).\nTherefore, it is interesting to have a quick overview of the matrix potential that R has.\n\n# Some manipulations with matrices\n\n## Identifying rows and columns\nres &lt;- matrix(c(-308, -318),\nnrow = 2, byrow = TRUE, # matrix definition\ndimnames = list(c(\"Delta H\", \"Delta S\"), \"kJ/mol\")\n)\nres\n\n        kJ/mol\nDelta H   -308\nDelta S   -318\n\n## Arithmetic operations\nm1 &lt;- matrix(c(1, 2, 3, 4), nrow = 2, byrow = T)\nm2 &lt;- matrix(c(4, 5, 6, 7), nrow = 2, byrow = T)\nm1 + 5\n\n     [,1] [,2]\n[1,]    6    7\n[2,]    8    9\n\nm2 - 7 # addition or subtraction in scalar\n\n     [,1] [,2]\n[1,]   -3   -2\n[2,]   -1    0\n\nm1^2\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    9   16\n\nsin(m2) # power or trigonometry\n\n           [,1]       [,2]\n[1,] -0.7568025 -0.9589243\n[2,] -0.2794155  0.6569866\n\nm1 + m2 # addition of elements in matrices of equal dimension\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    9   11\n\nm1 * m2 # multiplication of elements in matrices of equal dimension\n\n     [,1] [,2]\n[1,]    4   10\n[2,]   18   28\n\nm1 %*% m2 # dot product of vectors\n\n     [,1] [,2]\n[1,]   16   19\n[2,]   36   43\n\ndet(m1) # determinant of a matrix\n\n[1] -2\n\nt(m2) # transposition of a matrix\n\n     [,1] [,2]\n[1,]    4    6\n[2,]    5    7\n\ndiag(m1) # diagonal matrix\n\n[1] 1 4\n\nsolve(m2) # inverse of a matrix\n\n     [,1] [,2]\n[1,] -3.5  2.5\n[2,]  3.0 -2.0\n\neigen(m1) # eigenvalue and eigenvector of a matrix\n\neigen() decomposition\n$values\n[1]  5.3722813 -0.3722813\n\n$vectors\n           [,1]       [,2]\n[1,] -0.4159736 -0.8245648\n[2,] -0.9093767  0.5657675\n\n\nR also supports several other operations used in numerical and symbolic calculations that use matrices, such as the functions kronecker (matrix multiplication), svd (Single Value Decomposition), qr (QR Decomposition), and chol (Cholesky Decomposition).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html#solving-thermodynamic-parameters-of-enzyme-stability",
    "href": "biotermodin_en.html#solving-thermodynamic-parameters-of-enzyme-stability",
    "title": "11  Biothermodynamics",
    "section": "11.4 Solving thermodynamic parameters of enzyme stability",
    "text": "11.4 Solving thermodynamic parameters of enzyme stability\nThermodynamic parameters, such as those contained in the Van’t Hoff expression, Equação 11.10, can also be obtained simultaneously by matrix algebra. For example, it is common in Biotechnology to evaluate thermostability parameters of enzymes subjected to thermal stress (as well as chemical stress, such as pH, urea or use of proteases). This is done in order to verify, for example, whether an enzyme can withstand high temperatures in industrial processes, to compare enzymes modified by site-directed mutation, or to evaluate the behavior of enzymes associated with various pathogenesis. The formalism of this analysis goes through the Arrhenius Collision Theory, as well as the Eyring Transition State Theory, resulting in the linear system of equations as follows:\n\\[\n\\begin{cases}\\Delta G^\\ddagger = \\Delta H^\\ddagger-T* \\Delta S^\\ddagger\n\\\\\nln(\\frac{kcat*h}{K_B*T})=-\\frac{1}{RT}*\\Delta H^\\ddagger + \\frac{1}{R}*\\Delta S^\\ddagger\n\\end{cases}\n\\tag{11.12}\\]\nWhere the terms with \\(\\ddagger\\) symbolize the variations of quantities related to the activation (or deactivation) of the enzyme (transition state of the activated complex), \\(K_{B}\\) represents the Boltzmann constant (1.381x10\\(^{-23}\\) JK\\(^{-1}\\)), h the Planck constant (6.686x10\\(^{-34}\\) J*s), and R the general gas constant (8.314 JK\\(^{-1}\\) mol\\(^{-1}\\)). It is not always possible to converge a matrix solution by simply using cross multiplication (dot product).\nThe code snippet below exemplifies this attempt, based on the data published by Riaz et al (Bhatti et al. 2007) below, and previously considering the matrices A and b as a function of the parameters specified by the authors:\n\\[\n\\Delta G^{\\ddagger}=65920\\, J\\,mol^{-1} \\\\\nT = 328 K \\\\\nkcat = 217 s^{-1}\n\\tag{11.13}\\]\n\\[\nA = \\begin{bmatrix}\n1 & -328\\\\\n-3.67e-4 & 0.120\\\\\n\\end{bmatrix} ,\n\\]\n\\[\nb = \\begin{bmatrix}\n65920\\\\\n-24.17\\\\\n\\end{bmatrix}\n\\]\n\n# Attempt at a simple matrix solution in published data\n# (Appl. Microbiol. Biotechnol, 73, 1290, 2007):\n\nA &lt;- matrix(c(1, -3.67e-4, -328, 0.120), nrow = 2, byrow = TRUE)\nb &lt;- matrix(c(65921, -24.17), nrow = 2)\nsolve(A) %*% b\n\n             [,1]\n[1,]    -21038593\n[2,] -57505488910\n\n\nNote the inconsistency for the resulting thermodynamic parameters. The matrix solution by the solve command also suffers from solving the problem, incurring an error if executed, as in the following excerpt. Also note the distinct possibility for constructing the matrices.\n\nAframe &lt;- data.frame(c(1, -3.67e-4), c(-328, 0.120))\nA &lt;- as.matrix(Aframe)\nb &lt;- as.matrix(c(65921, -24.17))\nsolve(t(A) %*% A) %*% t(A) %*% b\n\nFor these more complex situations, it may be useful to use R packages, such as rootSolve already used or nleqslv used previously. In this sense, the root search minimization for the system of equations can be demonstrated as follows:\n\n# Minimization for roots of a system of thermodynamic equations\n\nlibrary(rootSolve)\nT &lt;- 328\nR &lt;- 8.314\nh &lt;- 6.626e-34\nkb &lt;- 1.381e-23\nkcat &lt;- 217\nDG &lt;- -R * T * log((kcat * h) / (kb * T)) # 65920 J/mol\nmodel &lt;- function(x) c(x[1] - T * x[2] - DG, x[2] / R - x[1] / (R * T) -\nlog((kcat * h) / (kb * T)))\n(ss &lt;- multiroot(model, start = c(50000, 50000)))\n\n$root\n[1] 40843.50837   -76.45441\n\n$f.root\n[1]  2.110028e-09 -7.744916e-13\n\n$iter\n[1] 3\n\n$estim.precis\n[1] 1.055401e-09\n\n\nBy this numerical solution the values ​​found for the parameters were \\(\\Delta\\) H\\(^{\\ddagger}\\) = 40.8 kJmol\\(^{-1}\\) and \\(\\Delta\\) S\\(^{\\ddagger}\\) = -76.5 Jmol\\(^{-1}\\)K\\(^{-1}\\).\nComparing the values, the authors found \\(\\Delta\\) H\\(^{\\ddagger}\\) = 33.3 kJmol\\(^{-1}\\) and \\(\\Delta\\) S\\(^{\\ddagger}\\) = -99.8 Jmol\\(^{-1}\\)K\\(^{-1}\\). Note the similarity of the results obtained by minimizing roots with the parameters found by the authors. The value of \\(\\Delta\\) H\\(^{\\ddagger}\\) for these, however, was obtained only from obtaining the experimental value of Arrhenius activation energy (Ea), by the slope of a linearized graph of the reaction rate, as follows:\n\\[\nk = A *e^{-Ea/RT}\n\\\\\nln(k) = \\frac{\\Delta S^{\\ddagger}}{R} - \\frac{\\Delta H^{\\ddagger}}{R} * \\frac{1}{T}\n\\tag{11.14}\\]\nAlthough a significant adequacy of the values ​​obtained by the authors and at a single temperature is noted, caution must be exercised with the procedure, since minimizations usually require good initialization seeds of the algorithm to produce good results. Furthermore, the very nature of the thermodynamic relationship between a reaction rate (such as kcat) and the resulting Gibbs energy change occurs on an exponential scale:\n\\[\nk = f(kcat) = e^{-\\Delta G^{\\ddagger}/RT}\n\\tag{11.15}\\]\nThis means in practice that small changes in \\(\\Delta\\) G\\(^{\\ddagger}\\) result in huge changes in the value of k (in this case, kcat). For this reason, small differences in the value of \\(\\Delta\\) G\\(^{\\ddagger}\\) can result in huge differences in \\(\\Delta\\) H\\(^{\\ddagger}\\) and \\(\\Delta\\) S\\(^{\\ddagger}\\) for the solution of the linear system. To illustrate this impact more directly, try changing the value of \\(\\Delta\\) G\\(^{\\ddagger}\\), rounding it:\n\nrequire(rootSolve)\nT &lt;- 328\nR &lt;- 8.314\nh &lt;- 6.626e-34\nkb &lt;- 1.381e-23\nkcat &lt;- 217\nDG &lt;- 66000\nmodel &lt;- function(x) c(x[1] - T * x[2] - DG, x[2] / R - x[1] / (R * T) -\nlog((kcat * h) / (kb * T)))\n(ss &lt;- multiroot(model, start = c(50000, 50000)))\n\n$root\n[1] 51579492242   157254348\n\n$f.root\n[1] 177.50881195  -0.09422566\n\n$iter\n[1] 3\n\n$estim.precis\n[1] 88.80152",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html#enthalpy-of-reaction-by-matrices",
    "href": "biotermodin_en.html#enthalpy-of-reaction-by-matrices",
    "title": "11  Biothermodynamics",
    "section": "11.5 Enthalpy of Reaction by Matrices",
    "text": "11.5 Enthalpy of Reaction by Matrices\nChemical reactions are usually represented by the following equation:\n\\[\n0 = \\sum_{i=1}^{N} \\nu_i B_i\n\\tag{11.16}\\]\nThus, if we observe the representations that accompany chemical reactions, we will see that they also constitute linear functions, as in the examples below:\n\\[\n2 C_2H_2(g)+ 5 O_2(g) \\rightleftarrows 4 CO_2(g) + 2 H_2O(l), \\\\\n\\Delta_fH^o = -2600 \\,\nkJ/mol\\\\\n2 C_2H6(g) + 7 O_2(g) \\rightleftarrows 4 CO_2(g) + 6 H_2O(l), \\\\\n\\; \\Delta_fH^o = -3210 \\, kJ/mol \\\\\nH_2(g) + \\frac{1}{2} O_2(g) \\rightleftarrows H_2O(l), \\\\\n; \\Delta_fH^o = -286 \\, kJ/mol\\\\\nC_2H_2(g) + 2H_2(g) \\rightleftarrows C_2H_6(g), \\\\\n\\; \\Delta_fH^o = ?\n\\tag{11.17}\\]\nAnd, if we select some reactions that have relationships between them, such as those presented in Equação 11.17 above, we will then have a system of linear equations, capable of being solved by matrix algebra. This relationship between chemical reactions that involve the formation of compounds refers to Hess’s Law.\nMathematically, Hess’s Law can be expressed as:\n\\[\n\\Delta_fH^o = \\sum_{n=1}^{\\infty} \\nu \\Delta_fH^o_P - \\sum_{n=1}^{\\infty} \\nu \\Delta_fH^o_R\n\\tag{11.18}\\]\nWhere \\(\\nu\\) represents the stoichiometry of the reaction, that is, the number of moles of each compound/element, while P and R refer to the Product and Reactant.\nReturning to the Equação 11.17 example, what we want is to obtain the value of the reaction enthalpy for ethane (\\(C_2H_6\\)), based on the reaction enthalpy values ​​of the related species (Khalil 2000). There are at least three possible solutions, in which the reaction enthalpy can be determined by the bond enthalpy, by the formation enthalpy itself, and by Hess’s Law, which can be calculated using matrices.\nTo do this, it is necessary to 1) compose the matrices A and b, 2) calculate the vector of coefficients beta, and 3) perform the scalar product (%*%) of beta with a matrix formed by the formation enthalpy values. The rationale for composing the matrices involves listing each compound with its reaction stoichiometry, and requires that a negative value be given to reactants, while a positive value is given to products.\nThe table below illustrates this construction for the problem in question.\n\nlibrary(knitr) # to generate the table\ncomp &lt;- c(\"C2H2\", \"O2\", \"CO2\", \"H2O\", \"C2H6\", \"H2\") # list of compounds\n# involved\nrea1 &lt;- c(-2, -5, +4, +2, 0, 0) # stoichiometry (reaction1)\nrea2 &lt;- c(0, -7, +4, +6, -2, 0) # stoichiometry (reaction2)\nrea3 &lt;- c(0, -0.5, 0, +1, 0, -1) # stoichiometry (reaction3)\nincog &lt;- c(-1, 0, 0, 0, +1, -2) # stoichiometry of the reaction with enthalpy\n# unknown\ntab_esteq &lt;- data.frame(comp, rea1, rea2, rea3, incog) # dataframe with the\n# results\ncolnames(tab_esteq) &lt;- c(\"compound\", \"reaction 1\", \"reaction 2\", \"reaction 3\",\n\"ethane\") # name the columns\nknitr::kable(tab_esteq, caption = \"Reaction stoichiometry for a matrix solution of ethane formation (C2H6).\", \"pipe\") # table\n\n\nReaction stoichiometry for a matrix solution of ethane formation (C2H6).\n\n\ncompound\nreaction 1\nreaction 2\nreaction 3\nethane\n\n\n\n\nC2H2\n-2\n0\n0.0\n-1\n\n\nO2\n-5\n-7\n-0.5\n0\n\n\nCO2\n4\n4\n0.0\n0\n\n\nH2O\n2\n6\n1.0\n0\n\n\nC2H6\n0\n-2\n0.0\n1\n\n\nH2\n0\n0\n-1.0\n-2\n\n\n\n\n\nAnd the code snippet that follows calculates the value of \\(\\Delta H_r^o\\) for the formation of ethane.\n\n# Matrix solution for enthalpy of formation\nA &lt;- matrix(c(-2, 0, 0, -5, -7, -0.5, 4, 4, 0, 2, 6, 1, 0, -2, 0, 0, 0, -1),\nnrow = 6, byrow = T) # create matrix of reactions with known\n# enthalpy variation\nb &lt;- matrix(c(-1, 0, 0, 0, 1, -2), nrow = 6, byrow = T) # create matrix of\n# stoichiometric coefficients of reaction with unknown\n# enthalpy variation\nbeta &lt;- solve(t(A) %*% A) %*% t(A) %*% b # beta calculation\nenerg &lt;- matrix(c(-2600, -3210, -286), nrow = 1, byrow = T) # create matrix\n# with enthalpy values\n\nethane &lt;- energ %*% beta\ncat(\"Value for deltaHr ethane: \", ethane, \" kJ/mol\")\n\nValue for deltaHr ethane:  -267  kJ/mol",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html#thermodynamic-quantities-by-polynomial-fit",
    "href": "biotermodin_en.html#thermodynamic-quantities-by-polynomial-fit",
    "title": "11  Biothermodynamics",
    "section": "11.6 Thermodynamic Quantities by Polynomial Fit",
    "text": "11.6 Thermodynamic Quantities by Polynomial Fit\nAs seen in the previous sections of this chapter and in the Enzymes chapter, linear relations allow the extraction of kinetic or thermodynamic parameters associated with biophysical-chemical phenomena, such as in the study of ligand associations with biopolymers, self-association of biomacromolecules, enzyme kinetics, or thermodynamic stability equilibrium of biopolymers. Regarding the latter, Equação 11.10 illustrates the linear relationship between a thermodynamic parameter monitored during the experiment, such as \\(K_{eq}\\) or \\(\\Delta\\)G, and temperature (although other perturbations could also be viable, such as pH, denaturant content, ionic strength, etc.).\nHowever, we could not use linear matrix relationships or linear fits to solve quantitative parameters in situations that do not rely on linear behavior between variables, as reported by Equação 11.10, for example.\nTo illustrate, the relationship between temperature and the value for \\(\\Delta\\)G of the self-association of apolipoprotein Apo A-II present in HDL lipoprotein does not exhibit a linear profile, and can be obtained from the literature with the help of the following code snippet: (Waelbroeck, Van Obberghen, e De Meyts 1979).\n\n# Dependence of T on deltaG for insulin and receptor\n\nT &lt;- c(5.29, 10.07, 15.23, 20.21, 25.11, 30.29, 37.39) + 273\n# temperature data, in degrees Kelvin\ndG &lt;- c(11.74, 12.17, 12.46, 12.73, 12.88, 12.98, 13.13) * -1e3\n# -deltaG data, in kcal/mol\nplot(T, dG,\nxlab = \"T, K\", ylab = expression(paste(Delta, \"G, kcal/mol\"))\n)\n\n\n\n\n\n\n\nFigura 11.1: Temperature dependence of the Gibbs energy change of the interaction of insulin with its receptor.\n\n\n\n\n\nFigura 11.1 shows a parabolic trend between the test temperature and the Gibbs energy variation of the process. Thus, a 3rd degree polynomial can be fitted to the data, as follows.\n\n# Polynomial fit of thermodynamic parameters\n\npol3 &lt;- lm(dG ~ poly(T, 3, raw = TRUE)) # fit to 3rd degree polynomial; # \"raw=TRUE\" is essential\n# Alternatively, one can also fit polynomials as\n# pol3&lt;-lm(dG ~ T + I(T^2)+I(T^3))\n\nsummary(pol3)\n\n\nCall:\nlm(formula = dG ~ poly(T, 3, raw = TRUE))\n\nResiduals:\n      1       2       3       4       5       6       7 \n  2.350 -13.432  26.731 -16.407  -8.577  12.164  -2.829 \n\nCoefficients:\n                          Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)              8.970e+05  2.449e+05   3.663   0.0352 *\npoly(T, 3, raw = TRUE)1 -8.836e+03  2.498e+03  -3.537   0.0385 *\npoly(T, 3, raw = TRUE)2  2.866e+01  8.492e+00   3.375   0.0433 *\npoly(T, 3, raw = TRUE)3 -3.105e-02  9.613e-03  -3.230   0.0482 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 21.6 on 3 degrees of freedom\nMultiple R-squared:  0.999, Adjusted R-squared:  0.9981 \nF-statistic:  1045 on 3 and 3 DF,  p-value: 5.02e-05\n\nplot(T, dG,\nxlab = \"T, K\", ylab = expression(paste(Delta, \"G, kcal/mol\"))\n# graph of T x deltaG\n)\nlines(T, fitted(pol3), col = \"red\") # curve fitted to the data\n\n\n\n\n\n\n\nFigura 11.2: Polynomial fit to the Gibbs energy variation data of the interaction of insulin with its receptor.\n\n\n\n\n\nHere it is worth mentioning that obtaining the parameters of a polynomial can also be validated with the help of linear algebra (matrices). For example, build the matrix A of the temperature values, and the matrix b of the values ​​of \\(\\Delta\\)G:\n\\[\nA = \\begin{bmatrix}\n1 & 278.29\\\\\n1 & 283.07\\\\\n1 & 288.23\\\\\n1 & 293.21\\\\\n1 & 298.11\\\\\n1 & 303.29\\\\\n1 & 310.39\\\\\n\\end{bmatrix} ,\n\\] \\[\nb = \\begin{bmatrix}\n-11740\\\\\n-12170\\\\\n-12460\\\\\n-12730\\\\\n-12880\\\\\n-12980\\\\\n-13130\\\\\n\\end{bmatrix}\n\\]\nIn this case, the matrix operation takes into account the conversion of the matrix A of the independent variable into an alternation matrix, also known as Vandermonde matrix. A Vandermonde matrix is ​​presented as follows:\n\\[\nmatrix \\,V = \\begin{bmatrix}\n1 & x_1 & x_1^2 & x_1^3 & ... \\\\\n1 & x_2 & x_2^2 & x_2^3 & ... \\\\\n1 & x_3 & x_3^2 & x_3^3 & ...\\\\\n1 & ...& ... & ... & ...\\\\\n\\end{bmatrix} ,\n\\]\nAn apparent limitation of this procedure is that the adjustment must be performed with few experimental points, since the exponential term grows with the number of points. On the other hand, the matrix solution circumvents the need to obtain statistical sums of the variables. R has a package to automate this transformation, matrixcalc, exemplified in the code snippet below:\nNow just apply the same matrix relation of Equação 13.3, in this case, for four interleaved points of the experimental data above, and therefore producing a 4th degree polynomial:\n\n# Polynomial adjustment 4th degree for thermodynamic parameters\n\nT &lt;- c(5.29, 15.23, 25.11, 37.39) + 273 # temperature data,\n# in degrees Kelvin\ndG &lt;- c(11.74, 12.46, 12.88, 13.13) * -1e3 #\n\nlibrary(matrixcalc)\n# Creating matrices A (Vandermonde) and b\nb &lt;- as.matrix(dG, nrow = 4, byrow = TRUE) # vector b\nA &lt;- vandermonde.matrix(alpha = T, n = 4)\nA # function to create alternation matrix (Vandermonde)\n\n     [,1]   [,2]     [,3]     [,4]\n[1,]    1 278.29 77445.32 21552259\n[2,]    1 288.23 83076.53 23945149\n[3,]    1 298.11 88869.57 26492908\n[4,]    1 310.39 96341.95 29903579\n\nsol.vnd &lt;- solve(A) %*% b\nsol.vnd # polynomial coefficients (4th degree)\n\n              [,1]\n[1,]  5.095658e+05\n[2,] -4.886799e+03\n[3,]  1.525183e+01\n[4,] -1.589352e-02\n\n\nTo plot the data, simply convert the polynomial coefficients above into the resulting polynomial expression, which can be done with the polynom package:\n\nlibrary(polynom) # converts vector of coefficients into symbolic polynomial\np &lt;- as.polynomial(sol.vnd)\np2 &lt;- as.function(p) # allows converting the polynomial to the curve function\nplot(T, dG)\ncurve(p2, from = 273, to = 315, add = TRUE) # smooth polynomial curve\n\n\n\n\n\n\n\n\nAlthough the polynomial fit, either by the R eigenfunction (lm) or by the matrix solution above, reveals good adherence of the model to the experimental data, as represented by Figura 11.2 and the results table above, there is no correlation of thermodynamic parameters, since it is an empirical mathematical model, and not an analytical one for the system.\nHowever, it is possible to obtain a good approximation of the quantities \\(\\Delta\\)H (enthalpy), \\(\\Delta\\)S (entropy) and \\(\\Delta\\)Cp (heat capacity) that phenomenologically model the thermodynamic behavior at a given temperature, by specific relations between these quantities (Edelhoch e Osborne Jr 1976).\n\\[\n\\Delta S = -(\\frac{\\partial \\Delta G}{\\partial T})_p\n\\tag{11.19}\\]\nIn short, the variation of entropy can be defined as the gradient of the variation of Gibbs energy with temperature. Another way of saying it would be to state that the entropy variation can also be defined as the first derivative of that relation, which can be defined empirically by:\n\\[\n\\Delta G = a+bT+cT^2+dT^3\n\\tag{11.20}\\]\nThus, the value of \\(\\Delta\\)S can be obtained by the first derivative of the empirical relation above (Equação 11.20):\n\\[\n\\Delta S = -(\\frac{\\partial \\Delta G}{\\partial T})_p = -b-2cT-3dT^2\n\\tag{11.21}\\]\nThe value of \\(\\Delta\\)H, in turn, can now be extracted from the Equação 11.22 repeated here, together with the Equação 11.20:\n\\[\n\\Delta G = \\Delta H - T * \\Delta S\n\\tag{11.22}\\]\n\\[\n\\Delta H = \\Delta G +T * \\Delta S\n\\tag{11.23}\\]\nApplying the empirical equations for the thermodynamic parameters above:\n\\[\n\\Delta H = (a+bT+cT^2+dT^3) +T(-b-2cT-3dT^2)\n\\tag{11.24}\\]\n\\[\n\\Delta H = a-cT^2-2dT^3\n\\tag{11.25}\\]\nSimilarly, the heat capacity at constant pressure can be defined as:\n\\[\n\\Delta Cp = -(\\frac{\\partial \\Delta H}{\\partial T})_p\n\\tag{11.26}\\]\nThat is, the value of \\(\\Delta\\)Cp can be approximated by the first derivative of \\(\\Delta\\)H (Equação 11.24) over T. That is:\n\\[\n\\Delta Cp = -2cT-6dT^2\n\\tag{11.27}\\]\nAlthough they are approximations, the thermodynamic parameters thus obtained reflect the possibility of describing a phenomenon, such as the interaction of insulin with its receptor (Waelbroeck, Van Obberghen, e De Meyts (1979)), from the perspective of preponderant weak bonds, such as hydrogen bonds, van der Waals forces, salt effect, electrostatic interactions and hydrophobic effect (Ross e Subramanian 1981), only by monitoring an equilibrium constant with temperature. The code snippet below solves the thermodynamic parameters for the complexation of insulin with its receptor at 25\\(^o\\)C by the method described.\n\n# Polynomial solution of thermodynamic parameters for interaction of\n# insulin with receptor\n\nT &lt;- c(5.29, 10.07, 15.23, 20.21, 25.11, 30.29, 37.39) +\n273 # temperature data, in degrees Kelvin\ndG &lt;- c(11.74, 12.17, 12.46, 12.73, 12.88, 12.98, 13.13) *\n-1e3 # -deltaG data, in kcal/mol\n\n# Fit to 2nd degree polynomial\npol3 &lt;- lm(dG ~ poly(T, 3, raw = TRUE)) # fit to 3rd degree polynomial degree\n\nTref &lt;- 298 # reference temperature, in degrees Kelvin\n\n# Calculations\ndG &lt;- coef(pol3)[1] + coef(pol3)[2] * Tref + coef(pol3)[3] *\nTref^2 + coef(pol3)[4] * Tref^3 # deltaG\ndS &lt;- -coef(pol3)[2] - 2 * coef(pol3)[3] * Tref - 3 * coef(pol3)[4] *\nTref^2 # deltaS\ndH &lt;- coef(pol3)[1] - coef(pol3)[3] * Tref^2 - 2 * coef(pol3)[4] *\nTref^3 # deltaH\ndCp &lt;- -2 * coef(pol3)[3] * Tref - 6 * coef(pol3)[4] * Tref^2 # deltaCp\n\n# Parameters in 298 K\ncat(\"deltaG value: \", dG, \"cal/mol\", \"\\n\")\n\ndeltaG value:  -12868.43 cal/mol \n\ncat(\"deltaS value: \", dS, \"cal/mol/K\", \"\\n\")\n\ndeltaS value:  27.29257 cal/mol/K \n\ncat(\"deltaH value: \", dH, \"cal/mol\", \"\\n\")\n\ndeltaH value:  -4735.248 cal/mol \n\ncat(\"deltaCp value: \", dCp, \"cal/mol/K\", \"\\n\")\n\ndeltaCp value:  -537.5956 cal/mol/K \n\n\nThe values ​​found for the interaction are very close to those reported by the authors at 25\\(^o\\)C (Waelbroeck, Van Obberghen, e De Meyts (1979)), although they used a fit with a 2nd degree polynomial. If you change the code snippet above to a polynomial of the same degree and omit the terms of the thermodynamic equations that identify the coefficient d, a value of \\(\\Delta\\)Cp of -735 kcal/mol should be observed, very similar to the reported value of -766 kcal/mol.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html#thermodynamic-stability-of-biopolymers",
    "href": "biotermodin_en.html#thermodynamic-stability-of-biopolymers",
    "title": "11  Biothermodynamics",
    "section": "11.7 Thermodynamic Stability of Biopolymers",
    "text": "11.7 Thermodynamic Stability of Biopolymers\nThe thermodynamic stability of proteins, enzymes and nucleic acids is essential for the study of new engineered biopolymers, modified complex matrices (artificial plasma, for example), as well as for the research of drug and medicine candidates. In general terms, the biopolymer under evaluation is considered in a two-state model, native and denatured, as presented in the Equação 11.3 of this chapter.\nHowever, as the experimental determination of [N] and [D] concentrations becomes complex, we seek to obtain a relationship between them, specifically, their fraction, such that:\n\\[\nf_D+f_N = 1\n\\tag{11.28}\\]\nWhich results in:\n\\[\nf_N = 1 - f_D\n\\tag{11.29}\\]\nThus, an experimental signal S obtained in the presence of N and D fractions in a biopolymer sample can be represented as:\n\\[\nS = f_N * S_N +f_D * S_D\n\\tag{11.30}\\]\nSubstituting Equação 11.29 in Equação 11.30 we obtain:\n\\[\nf_D = \\frac{S_i-S_N}{S_D-S_N}\n\\tag{11.31}\\]\nWhere Si represents the signal at point i.\nThus, even if the concentrations [N] and [D] are not directly obtained, their fractions can be recovered from the signal obtained from denaturation tests against various perturbants, such as temperature, pH, salts or denaturing reagents (urea, guanidine chloride, for example).\nIn this way, the value of the equilibrium thermodynamic constant of denaturation K\\(_D\\) can also be recovered, such that:\n\\[\nK_D = \\frac{[D]}{[N]}=\\frac{f_D}{f_N}\n\\tag{11.32}\\]\nInserting Equação 11.29 into Equação 11.32, we obtain:\n\\[\nK_D = \\frac{f_D}{1-f_D}\n\\tag{11.33}\\]\nAnd, therefore,\n\\[\n\\Delta G_D = -RT*ln\\;K_D\n\\tag{11.34}\\]\nIn this way, it is possible to evaluate the thermodynamic stability of a biopolymer by its stability curve, contrasting the perturbant against the value of \\(\\Delta\\)G\\(_D\\) obtained by the above procedures.\nAnalytically, a stability curve can be generated from the constant parameters in the integrated Gibbs-Helmholtz equation (LiCata e Liu (2011)):\n\\[\n\\Delta G(T) = \\Delta H_m(\\frac{Tm-T}{Tm})-\\Delta Cp[Tm-T(1-ln \\; \\frac{Tm}{T})])\n\\tag{11.35}\\]\nThus, a stability curve can be illustrated by the following code snippet:\n\n# Denaturation curve for protein\n\nTm &lt;- 85\ndHm &lt;- 180\ndCp &lt;- 3\nx &lt;- 0:80\n\ncurve(dHm * (1 - x / Tm) + dCp * ((x - Tm - x * log(x / Tm)))\n, xlim = c(0, 80)) # Nicholson1996; Sholz2009\n\n\n\n\nSimulated stability curve for the denaturation of a protein. Tm = 75oC, DeltaHm = 180 kcal/mol, and DeltaCp = 3 kcal/mol/K.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "biotermodin_en.html#quantitative-structure-function-relationship-qsar-and-multilinear-fitting",
    "href": "biotermodin_en.html#quantitative-structure-function-relationship-qsar-and-multilinear-fitting",
    "title": "11  Biothermodynamics",
    "section": "11.8 Quantitative Structure-Function Relationship (QSAR) and Multilinear Fitting",
    "text": "11.8 Quantitative Structure-Function Relationship (QSAR) and Multilinear Fitting\nThe same procedures employed to solve matrix problems, specifically with Equação 13.4, can also accommodate a QSAR (Quantitative Structure-Function Relationship) analysis of interest. For example, benzodiazepinone derivatives (TIBO) are known to inhibit reverse transcriptase (Tong et al. 2018), an enzyme that catalyzes the conversion of RNA into viral DNA in acquired immune deficiency syndrome (AIDS). In this sense, observations derived from the QSAR study can contribute to the design of potential HIV transcriptase inhibitors. Thus, Tong et al. proposed a multilinear predictive model relating some properties of TIBO analogues with biological activity, as follows:\n\\[\npIC_{50}=x_0+x_1*S+x_2*W\n\\] {#eq:eqTIBO}\nWhere pIC\\(_{50}\\) represents the measured biological activity (-log IC\\(_{50}\\)), S indexes solubility values, and W refers to the width parameter of the first atom of the substituent group. These data are tabulated below:\n\n# Tabulation data for QSAR\n\ngroup &lt;- c(\"H\", \"Cl\", \"SCH3\", \"OCH3\", \"CN\", \"CHO\", \"Br\", \"CH3\", \"CCH\")\n# substituent groups in TIBO\nS &lt;- c(3.53, 4.24, 4.09, 3.45, 2.96, 2.89, 4.39, 4.03, 3.8) # solubility parameter\nW &lt;- c(1, 1.8, 1.7, 1.35, 1.6, 1.6, 1.95, 1.6, 1.6)\n# group width parameter\npIC50 &lt;- c(7.36, 8.37, 8.3, 7.47, 7.25, 6.73, 8.52, 7.87, 7.53)\n# biological activity of TIBO\n\ntab.tibo &lt;- data.frame(group, S, W, pIC50)\nknitr::kable(tab.tibo, caption = \"multivariate data of biological activity of TIBO and predictive parameters.\", \"pipe\") # table\n\n\nmultivariate data of biological activity of TIBO and predictive parameters.\n\n\ngroup\nS\nW\npIC50\n\n\n\n\nH\n3.53\n1.00\n7.36\n\n\nCl\n4.24\n1.80\n8.37\n\n\nSCH3\n4.09\n1.70\n8.30\n\n\nOCH3\n3.45\n1.35\n7.47\n\n\nCN\n2.96\n1.60\n7.25\n\n\nCHO\n2.89\n1.60\n6.73\n\n\nBr\n4.39\n1.95\n8.52\n\n\nCH3\n4.03\n1.60\n7.87\n\n\nCCH\n3.80\n1.60\n7.53\n\n\n\n\n\nNote that there are two predictor variables and one dependent variable, and whose solution can be found by multilinear or multiple linear fit. R allows this to be done in at least two ways: internal linear fit function (lm) or matrix algebra.\n\n11.8.1 Multiple linear fit by lm function:\nIn a simplified way, one can obtain the multivariate expression that defines the relationship of the predictive quantities W and S with the biological activity of TIBO by:\n\n# Multilinear fitting in QSAR\n\nlm.tibo &lt;- lm(tab.tibo$pIC50 ~ tab.tibo$S + tab.tibo$W)\n# command for multilinear fitting;\n\n# Alternatively,\n# lm.tibo &lt;- lm(cbind(S,W)~pIC50)\nsummary(lm.tibo)\n\n\nCall:\nlm(formula = tab.tibo$pIC50 ~ tab.tibo$S + tab.tibo$W)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.27636 -0.15649  0.02922  0.08911  0.24761 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   3.5903     0.5435   6.606 0.000579 ***\ntab.tibo$S    0.9571     0.1519   6.300 0.000746 ***\ntab.tibo$W    0.3619     0.3020   1.199 0.275888    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2045 on 6 degrees of freedom\nMultiple R-squared:  0.912, Adjusted R-squared:  0.8826 \nF-statistic: 31.07 on 2 and 6 DF,  p-value: 0.0006826\n\n\nNote the most direct way to assign already declared variables to an R function (*dataframe $ vector). This is the simplest way, since it does not depend on extra packages (like dplyr), although it is less readable.\nExpressing the results in multiple linear function:\n\\[\ny=5.75+0.14*S+0.95*W\n\\tag{11.36}\\]\n\n\n11.8.2 Multiple linear adjustment by matrices:\nThe beta coefficients obtained above can also be found by linear algebra, using the b biological activity matrix and the A matrix containing the independent variables, this one also created with unit values ​​on the left, as before, followed by the application of Equação 13.4:\n\\[\nX = \\begin{bmatrix}\n1 & S_{1} & W_{1} \\\\\n1 & S_{2} & W_{2}\\\\\n1 & S_{3} & W_{3}\\\\\n... & ...\n\\end{bmatrix}\n\\]\n\n# Creating matrices A and b\nA &lt;- matrix(c(rep(1, 9), S, W), nrow = 9, byrow = FALSE)\n# creates matrix with unit value required before the independent variable\nb &lt;- as.matrix(pIC50, nrow = 1, byrow = FALSE) # vector b\n\n# Matrix solution of linear adjustment\nbeta &lt;- solve(t(A) %*% A) %*% t(A) %*% b\nbeta\n\n          [,1]\n[1,] 3.5902556\n[2,] 0.9571092\n[3,] 0.3619292\n\n\nNote that the values ​​for the coefficients are coincident. In practice, the multiple linear adjustment procedure can be used, as in the example above, to predict a response (such as pIC\\(_{50}\\)) as a function of predictor variables (such as S and W).\nThis multilinear matrix procedure can also be applied to other types of multivariate analysis, such as factorial experiment and response surface methodology. This is due to the very nature of these systems, when linear. See the applications below. Even for quadratic response surface methodology (where the parameters vary with the square of the predictor variables), the matrix solution (Equação 13.4) is also possible.\n\\[\ny = b_0+b_1*x, \\, linear fit\\\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+...+b_n*x_n, \\, fit \\, multilinear\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+...+b_n*x_n, \\, methodology \\, of \\, surface \\, of \\, response \\, linear\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_{12}*x_1*x_2, \\, planning \\, factorial \\, 2^2\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_3*x_3+b_{12}*x_1*x_2+,b_{13}*x_1*x_3+b_{23}*x_2*x_3+b_{123}*x_1*x_2*x3 \\, experiment \\, factorial \\, 2^3\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_{11}*x_1^2+b_{22}*x_2^2+b_{12}*x_1*x_2, \\, quadratic \\, response \\, surface \\, methodology\n\\\\\n\\tag{11.37}\\]\nAs a rule, all applications listed in Equação 13.5 can be solved with the help of matrix relations of the equations Equação 13.4 (linear, multilinear and linear response surface adjustments) or Equação 13.2 (factorial designs). Two situations of this nature are exemplified below.\n\n\n11.8.3 A word about matrices and applications\nAs already noted, the use of matrices extends to various situations, not necessarily of a Biochemical or Biophysical nature, data adjustments, Hess’s or Lambert-Beer’s Law, as well as the construction of a menu (matrix of ingredients for each dish by price of each ingredient), or the daily caloric expenditure in physical activity (matrix of weekly workload of each activity by matrix of caloric expenditure of the activity). In fact, they are tools used in Bioinformatics, Economics, Ecology, Engineering, and many other areas, satisfying the basic relations between the variables under study. These conditions, in turn, represent nothing more than the sum of products, in which these are manifested by quantities declared in the problem. Thus, a small representation of the statement above could be illustrated simply as:\n\\[\ny = \\sum_{n=1}^{\\infty} (x_1*x_2)\n\\tag{11.38}\\]\n\n\n\n\nBhatti, Haq Nawaz, M Hamid Rashid, Rakhshanda Nawaz, A Mukhtar Khalid, Muhammad Asgher, e A Jabbar. 2007. «Effect of aniline coupling on kinetic and thermodynamic properties of Fusarium solani glucoamylase». Applied microbiology and biotechnology 73 (6): 1290–98.\n\n\nCooper, Alan. 2004. «Thermodynamics and interactions». Em Biophysical Chemistry, 99–122.\n\n\nEdelhoch, Harold, e James C Osborne Jr. 1976. «The thermodynamic basis of the stability of proteins, nucleic acids, and membranes». Advances in protein chemistry 30: 183–250.\n\n\nKhalil, Mutasim I. 2000. «Calculating enthalpy of reaction by a matrix method». Journal of Chemical Education 77 (2): 185.\n\n\nLiCata, Vince J, e Chin-Chi Liu. 2011. «Analysis of free energy versus temperature curves in protein folding and macromolecular interactions». Methods in enzymology 488: 219–38.\n\n\nRoss, Philip D, e S Subramanian. 1981. «Thermodynamics of protein association reactions: forces contributing to stability». Biochemistry 20 (11): 3096–3102.\n\n\nTong, Jianbo, Shan Lei, Shangshang Qin, e Yang Wang. 2018. «QSAR studies of TIBO derivatives as HIV-1 reverse transcriptase inhibitors using HQSAR, CoMFA and CoMSIA». Journal of Molecular Structure 1168: 56–64.\n\n\nWaelbroeck, Magali, E Van Obberghen, e P De Meyts. 1979. «Thermodynamics of the interaction of insulin with its receptor.» Journal of Biological Chemistry 254 (16): 7736–40.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Biothermodynamics</span>"
    ]
  },
  {
    "objectID": "metabolismo_en.html",
    "href": "metabolismo_en.html",
    "title": "12  Cellular Metabolism",
    "section": "",
    "text": "12.1 Metabolic Pathways & Reaction Balancing",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Cellular Metabolism</span>"
    ]
  },
  {
    "objectID": "metabolismo_en.html#metabolic-pathways-reaction-balancing",
    "href": "metabolismo_en.html#metabolic-pathways-reaction-balancing",
    "title": "12  Cellular Metabolism",
    "section": "",
    "text": "Metabolism is an intricate network of chemical reactions catalyzed (or not) by various enzymes, resulting in a balanced and dynamic network of autocatalytic processes. Sometimes this web of reactions can be observed in the countless so-called metabolic maps available, printed or on the internet. However, metabolic pathways are classified for better understanding into subsets of reactions relevant to a certain group of nutrients or biological compounds, such as carbohydrates, lipids and nucleic acids, for example.\nAnd in a broader view of these subsets, a further classification results in several sequential and interdependent biochemical reactions, the so-called metabolic pathways or routes. These metabolic pathways summarize catabolic or anabolic processes involving substrates, products, enzymes, cofactors and coenzymes, as illustrated in glycolysis, gluconeogenesis, glycogenolysis, citric acid cycle, respiratory chain, pentose pathway, fatty acid beta-oxidation, among others.\nThus, a metabolic pathway can be considered as a linear combination of enzymatically catalyzed reactions (e.g. anaerobic glycolysis). In addition, one can also consider biochemical reactions as biochemical equations, and therefore as a linear system of biochemical equations with resolution by linear algebra. Thus, one can use matrix relations to solve the stoichiometric balance (mass and charge), obtaining the final net reaction from a set of known reactions. In short, biochemical equations as matrix equations (Alberty 1991).",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Cellular Metabolism</span>"
    ]
  },
  {
    "objectID": "metabolismo_en.html#matrix-operation",
    "href": "metabolismo_en.html#matrix-operation",
    "title": "12  Cellular Metabolism",
    "section": "12.2 Matrix operation",
    "text": "12.2 Matrix operation\nBy applying linear algebra, it is possible to obtain the final balance of sequential reactions by the following relation, also seen in the Biothermodynamics chapter:\n\\[\nA =\n\\begin{pmatrix}\na_{11} & a_{12} & a_{13} & ... & a_{1n} \\\\\na_{21} & a_{22} & a_{23} & ... & a_{2n} \\\\\na_{31} & a_{32} & a_{33} & ... & a_{3n} \\\\\n... & ... & ... & ... & a_{jn}\\\\\n\\end{pmatrix} ,\\\nb =\n\\begin{pmatrix}\nb_1 \\\\\nb_2 \\\\\nb_3 \\\\\n... \\\\\nb_n \\\\\n\\end{pmatrix} ,\\\ny =\n\\begin{pmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3 \\\\\n... \\\\\ny_n \\\\\n\\end{pmatrix}\n\\tag{12.1}\\]\nIn this case, A represents the stoichiometric matrix of reactions and compounds, b the metabolic pathway vector, and y the balanced net reaction vector. The pathway vector indicates the number of times each reaction must occur to produce the final net reaction. Matrix A is arranged in such a way as to present each reaction in each column and each reactant in each row, filling it with the stoichiometric coefficients of reactants and products. For these, it is necessary to present a positive sign for products (they are formed) and a negative sign for reactants (they are consumed).\nThe matrix operation to obtain the net reaction involves only a cross product, such as:\n\\[\nA * b = y\n\\tag{12.2}\\]\n\n12.2.1 Obtaining the metabolic pathway vector for aerobic glycolysis:\nAssuming that we know the summarized net reaction for a set of metabolic reactions, such as aerobic glycolysis (in turn including anaerobic glycolysis, the citric acid cycle, and oxidative phosphorylation), we can easily obtain the pathway vector. From this calculated pathway vector, we can obtain the final net reaction of the more detailed set of reactions. In practice, this detailing involves the participation of oxidation-reduction coenzymes, ADP, ATP, and Pi.\nFor example, consider the reactions below, related to a glycolysis synthesis (Alberty 1996):\n\\[\nglucose \\rightleftarrows 2\\,pyruvate \\\\\npyruvate + CoA \\rightleftarrows acetyl \\, CoA + CO_2\nacetyl \\, CoA + 3 H_2O\n\\rightleftarrows 2 CO_2+CoA\n\\frac{1}{2} O_2 \\rightleftarrows H_2O\n\\tag{12.3}\\]\n\\[\nacetyl \\, CoA + 3 H_2O\n\\rightleftarrows 2 CO_2+CoA\n\\frac{1}{2} O_2 \\rightleftarrows H_2O \\\\\n\\]\nThe sequential reactions above have as a net resulting reaction:\n$$ glucose + 6O_2 CO_2 + 6 H_2O\n$$ {#eq-eqGlicoSimpFin}\nTo obtain the route vector, it is necessary to elaborate the matrix relation, such that:\n\\[\nA =\n\\begin{pmatrix}\n-1 & 0 & 0 & 0 \\\\\n2 & -1 & 0 & 0 \\\\\n0 & 0 & -3 & 1 \\\\\n0 & -1 & 1 & 0 \\\\\n0 & 1 & -1 & 0 \\\\\n0 & 1 & 2 & 0 \\\\\n0 & 0 & 0 & -1/2 \\\\\n\\end{pmatrix}\n\\tag{12.4}\\]\n\\[\ny =\n\\begin{pmatrix}\n-1 \\\\\n0 \\\\\n6 \\\\\n0 \\\\\n0 \\\\\n6 \\\\\n-6 \\\\\n\\end{pmatrix}\n\\tag{12.5}\\]\nThus, the solution for the route vector is:\n\\[\nb = A^{-1} * y\n\\tag{12.6}\\]\nIt turns out that the linear system for the set of equations of the glycolytic pathway is overestimated (there are more equations than unknowns), not allowing the solution by the solve function directly, as illustrated in the Biothermodynamics chapter. In this case, the vector b can be obtained by least squares solution:\n\\[\nb = (A^{T}*A)^{-1}*A^T * y\n\\tag{12.7}\\]\nSolving the vector of pathways in R:\n\n# Matrix solution for the vector of metabolic pathways\n\nA &lt;- matrix(c(-1, 0, 0, 0, 2, -1, 0, 0, 0, 0, -3, 1, 0, -1, 1, 0, 0, 1,\n-1, 0, 0, 1, 2, 0, 0, 0, 0, -1 / 2), nrow = 7,\nbyrow = TRUE) # matrix A of reaction stoichiometry\nrownames(A) &lt;- list(\"glucose\", \"pyruvate\", \"H2O\", \"CoA\", \"acetyl CoA\"\n, \"CO2\", \"O2\") # reactant labels\nA # matrix A of reactions\n\n           [,1] [,2] [,3] [,4]\nglucose      -1    0    0  0.0\npyruvate      2   -1    0  0.0\nH2O           0    0   -3  1.0\nCoA           0   -1    1  0.0\nacetyl CoA    0    1   -1  0.0\nCO2           0    1    2  0.0\nO2            0    0    0 -0.5\n\ny &lt;- c(-1, 0, 6, 0, 0, 6, -6) # vector y of routes\n\nsolve(t(A) %*% A) %*% t(A) %*% y\n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    2\n[4,]   12\n\n\n\n\n12.2.2 Obtaining the balance of ATP, ADP, Pi and redox coenzymes in glycolysis\nWith the obtained route vector ({1,2,2,12}), it is now possible to apply it to a more extensive set of glycolysis equations, to this time solve the balancing of reactions involving oxidation-reduction coenzymes, ATP, ADP, and Pi:\n\\[\nglucose+2Pi+2ADP+2NAD^+ \\rightleftarrows 2 \\,pyruvate+2ATP+2NADH+2H_2O \\, , \\\\\nglycolysis \\, anaerobic,\n\\] \\[\npyruvate+CoA+NAD^+ \\rightleftarrows acetyl-CoA+CO_2+NADH \\\\\n\\]\n\\[\nacetyl-CoA + 4NAD^++ADP+Pi+2H_2O \\rightleftarrows2CO_2+4NADH+ATP+CoA, \\,\n\\\\\n\\, pyruvate \\, dehydrogenase\n\\] \\[\nNADH+ \\frac{1}{2}O_2+3Pi+3ADP \\rightleftarrows NAD^++4H_2O+3ATP \\, ,\\\\\noxidation \\, phosphorylative\n\\tag{12.8}\\]\nIt is worth mentioning a simplification by replacing GTP and GDP with ATP and ADP (Krebs cycle), since they are interconvertible in metabolism. For simplification, the interconversion of FAD and NAD in the net reaction is also assumed (Alberty 1996) :\n\\[\nFADH + NAD^+ \\rightleftarrows FAD + NADH\n\\tag{12.9}\\]\nWith the reactions present in Equação 12.8 and the route vector obtained previously, the new stoichiometric matrix can be constructed and the least squares solution (Equação 12.7) can be applied to obtain the net reaction of glycolysis. And to do this, simply apply the Equação 12.2) cross product:\n\nA &lt;- matrix(c(-1, 0, 0, 0, -2, 0, -1, -3, -2, 0, -1, -3, -2, -1,\n-4, 1, 2, -1, 0, 0, 2, 0, 1, 3, 2, 1, 4, -1, 2, 0,\n-2, 4, 0, -1, 1, 0, 0, 1, -1, 0, 0, 1, 2, 0, 0, 0,\n0, -1 / 2), nrow = 12, byrow = TRUE)\n# matrix A of reaction stoichiometry\nrownames(A) &lt;- list(\"glucose\", \"Pi\", \"ADP\", \"NAD\", \"pyruvate\", \"ATP\",\n\"NADH\", \"H2O\", \"CoA\", \"acetyl CoA\", \"CO2\", \"O2\")\n# reagent labels\nA # reaction matrix A\n\n           [,1] [,2] [,3] [,4]\nglucose      -1    0    0  0.0\nPi           -2    0   -1 -3.0\nADP          -2    0   -1 -3.0\nNAD          -2   -1   -4  1.0\npyruvate      2   -1    0  0.0\nATP           2    0    1  3.0\nNADH          2    1    4 -1.0\nH2O           2    0   -2  4.0\nCoA           0   -1    1  0.0\nacetyl CoA    0    1   -1  0.0\nCO2           0    1    2  0.0\nO2            0    0    0 -0.5\n\ny &lt;- c(1, 2, 2, 12) # vector y of routes\n\nA %*% y\n\n           [,1]\nglucose      -1\nPi          -40\nADP         -40\nNAD           0\npyruvate      0\nATP          40\nNADH          0\nH2O          46\nCoA           0\nacetyl CoA    0\nCO2           6\nO2           -6\n\n# solve(t(A)%*%A)%*%t(A)%*%y\n\nFrom this result, the final net reaction of the glycolytic pathway can be assembled as:\n\\[\nglucose + 6O_2 + 40 ADP + 40 Pi \\rightleftarrows 6CO_2+ 40ATP\n\\tag{12.10}\\]\nThe example above illustrates the use of matrix algebra to solve problems of balancing biochemical reactions. By its nature, it is a comprehensive and algorithmic method (therefore, programmable), although it is not the only one. Other proposed solutions for balancing and conservation of mass and charge include direct inspection by screening and error based on mnemonic rules, balancing by half-equation method, and the oxidation number method, not discussed here.\n\n\n\n\nAlberty, Robert A. 1991. «Chemical equations are actually matrix equations». Journal of chemical education 68 (12): 984.\n\n\n———. 1996. «Calculation of biochemical net reactions and pathways by using matrix operations». Biophysical journal 71 (1): 507–15.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Cellular Metabolism</span>"
    ]
  },
  {
    "objectID": "planejExper_en.html",
    "href": "planejExper_en.html",
    "title": "13  Experimental design",
    "section": "",
    "text": "13.1 Matrix system\n\\[\na_{11}*x_1 + a_{12} * x_2 = b_1\n\\\\\na_{21}*x_1 + a_{22} * x_2 = b_2\n\\tag{13.1}\\]\n\\[\nA = \\begin{bmatrix}\na_{11} & a_{12}\\\\\na_{21} & a_{22}\n\\end{bmatrix} ,\n\\]\n\\[\nx = \\begin{bmatrix}\nb_1\\\\\nb_2\n\\end{bmatrix} ,\n\\]\n\\[\nb = \\begin{bmatrix}\nx_1\\\\\nx_2\n\\end{bmatrix}\n\\]\n\\[\nA * x = b\n\\tag{13.2}\\]\n\\[\nx = A^{-1} * b\n\\tag{13.3}\\]\n\\[\n\\beta = (X^T \\; X)^{-1} \\; X^T*y\n\\tag{13.4}\\]\n\\[\ny = b_0+b_1*x, \\, linear\\ fit\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+...+b_n*x_n, \\, multilinear\\ fit\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+...+b_n*x_n, \\, linear\\ response\\ surface\\ methodology\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_{12}*x_1*x_2, \\, factorial\\ design\\, 2^2\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_3*x_3+b_{12}*x_1*x_2+,b_{13}*x_1*x_3+b_{23}*x_2*x_3+b_{123}*x_1*x_2*x3 \\, experiment \\, factorial \\, 2^3\n\\\\\ny = b_0+b_1*x_1+b_2*x_2+b_{11}*x_1^2+b_{22}*x_2^2+b_{12}*x_1*x_2, \\, quadratic \\, response \\, surface \\, methodology\n\\\\\n\\tag{13.5}\\]",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Experimental design</span>"
    ]
  },
  {
    "objectID": "planejExper_en.html#matrix-system",
    "href": "planejExper_en.html#matrix-system",
    "title": "13  Experimental design",
    "section": "",
    "text": "Recalling a simple matrix system, as seen in the Biothermodynamics chapter:\n\nThat is,\n\n\n\nNow solve for the values ​​of x (or \\(\\Delta\\)’s) linearly:\n\nUsing matrix algebra, the Equação 13.2 is solved for the values ​​of x:\n\nThus, the matrix solution, widely used in multivariate situations, such as response surface methodology and factorial experiment, can be obtained by the following Equação 13.4:\n\nOther examples are illustrated in Equação 13.5:\n\nAs a rule, all applications listed in Equação 13.5 can be solved with the help of matrix relations of the equations Equação 13.4 (linear, multilinear and linear response surface adjustments) or Equação 13.2 (factorial designs). Two situations of this nature are exemplified below.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Experimental design</span>"
    ]
  },
  {
    "objectID": "planejExper_en.html#reaction-yield-factorial-design-22",
    "href": "planejExper_en.html#reaction-yield-factorial-design-22",
    "title": "13  Experimental design",
    "section": "13.2 Reaction Yield & Factorial Design 2\\(^{2}\\)",
    "text": "13.2 Reaction Yield & Factorial Design 2\\(^{2}\\)\nThe simplest factorial experiment is the one that evaluates the response of an experiment (yield, for example) in which two factors (temperature and type of catalyst, for example) are varied at two levels each (low and high). The table prepared in the excerpt below from the data provided by Neto et al (Neto, Scarminio, e Bruns 2010) exemplifies this situation.\n\n# Factorial design\n\n# Experiment data\ntemp &lt;- c(40, 60, 40, 60)\ncatalis &lt;- c(\"A\", \"A\", \"B\", \"B\")\nrendim &lt;- c(59, 90, 54, 68)\n\n# Factorial design table\n\ntab.fat &lt;- data.frame(temp, catalis, rendim)\nknitr::kable(tab.fat, caption = \"Factorial experiment data (Neto et al., 2010).\", \"pipe\") # table\n\n\nFactorial experiment data (Neto et al., 2010).\n\n\ntemp\ncatalis\nrendim\n\n\n\n\n40\nA\n59\n\n\n60\nA\n90\n\n\n40\nB\n54\n\n\n60\nB\n68\n\n\n\n\n\nTo conduct matrix analysis of the data, it is necessary to convert the table of independent variables (predictors) into a coded design matrix, in which high values ​​(upper level) are represented by +1 and low values ​​(lower level) by -1. In addition, it is also necessary to assign +1 to the 1st. column, and produce a 4th column containing the product of the encoded predictors. For example, for temperature at 40 (-1) and catalyst B (+1), the row will contain the product -1. This final 4x4 matrix is ​​called the contrast coefficient matrix:\n\\[\nX = \\begin{bmatrix}\n1 & -1 & -1 & 1 \\\\\n-1 & -1 & 1 & 1 \\\\\n-1 & 1 & -1 & 1 \\\\\n1 & 1 & 1 & 1 \\\\\n\\end{bmatrix}\n\\]\nIn addition, it is necessary to divide the result of the matrix operation by a specific scalar vector. In short: the coded matrix X of the predictors is created, the matrix Y of the response is applied to Equação 13.2, and the result is divided by a characteristic vector of the factorial design 2\\(^{2}\\) (c(4,2,2,2)). The code snippet below solves the problem raised:\n\n# Creation of the coded planning matrix\nX &lt;- matrix(c(1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, 1, 1),\nnrow = 4, byrow = TRUE)\n\nWarning in matrix(c(1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, 1, 1), : data\nlength [15] is not a sub-multiple or multiple of the number of rows [4]\n\n# Creation of the yield matrix\nY &lt;- as.matrix(rendim)\n# Determination of the beta coefficients:\nbeta &lt;- t(X) %*% Y / c(4, 2, 2, 2)\nbeta\n\n       [,1]\n[1,]  67.75\n[2,]  22.50\n[3,] -13.50\n[4,]  -8.50\n\n\nThus, the result is interpreted as:\n\\[\n\\begin{pmatrix}\nM \\\\\nT \\\\\nC \\\\\nTC \\\\\n\\end{pmatrix} =\n\\begin{pmatrix}\n67.75 \\\\\n22.50 \\\\\n-13.50 \\\\\n-8.50 \\\\\n\\end{pmatrix}\n\\tag{13.6}\\]\nWhere M represents the overall mean of the response, T and C the main effects (temperature and catalyst), and TC the interaction effect. In summary, the results suggest that 1) the temperature favored the yield, especially for catalyst A, 2) there is a reduction in yield when replacing catalyst A with B, and c) the highest yields are obtained with catalyst A at the highest temperature. Expressing these results in the multiple linear function:\n\\[\ny=67.75+22.5*T-13.5*C-8.5*T*C\n\\tag{13.7}\\]\nInterestingly, we arrive at the same results if, instead of applying Equação 13.2, we use Equação 13.4, followed by multiplication (and not division) by another vector (c(1,2,2,2):\n\nbeta &lt;- (solve(t(X) %*% X) %*% t(X) %*% Y) * c(1, 2, 2, 2)\nbeta\n\n       [,1]\n[1,]  67.75\n[2,]  22.50\n[3,] -13.50\n[4,]  -8.50",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Experimental design</span>"
    ]
  },
  {
    "objectID": "planejExper_en.html#response-surface-methodology-rsm",
    "href": "planejExper_en.html#response-surface-methodology-rsm",
    "title": "13  Experimental design",
    "section": "13.3 Response Surface Methodology (RSM)",
    "text": "13.3 Response Surface Methodology (RSM)\nThis multivariate statistical technique is also commonly used in modeling responses influenced by more than one factor, sometimes associated with factorial design, and with a view to optimizing a response without the need to evaluate all possible combinations. This can be particularly useful when one wants to optimize a test whose response depends, for example, on scalar predictors, such as the concentration range of a given reagent and the pH conditions.\nFor example, for a linear response surface (Neto, Scarminio, e Bruns 2010), in a test in which one wishes to verify the best yield (rend, %) of a reaction by varying 3 levels of reagent concentration (conc, %) and three magnetic stirring speeds (agit, rpm), one can, as before, prepare the contrast matrix from the information in the following table:\n\n# Data for response surface methodology\n\nconc &lt;- c(45, 55, 45, 55, 50, 50, 50)\nagit &lt;- c(90, 90, 110, 110, 100, 100, 100)\nx1 &lt;- c(-1, 1, -1, 1, 0, 0, 0)\nx2 &lt;- c(-1, -1, 1, 1, 0, 0, 0)\nyield &lt;- c(69, 59, 78, 67, 68, 66, 69)\n\ntab.msr &lt;- data.frame(conc, agit, x1, x2, yield)\nknitr::kable(tab.msr, caption = \"Experiment data of linear response surface methodology\n(Neto et al, 2010).\", \"pipe\") # table\n\n\nExperiment data of linear response surface methodology (Neto et al, 2010).\n\n\nconc\nagit\nx1\nx2\nyield\n\n\n\n\n45\n90\n-1\n-1\n69\n\n\n55\n90\n1\n-1\n59\n\n\n45\n110\n-1\n1\n78\n\n\n55\n110\n1\n1\n67\n\n\n50\n100\n0\n0\n68\n\n\n50\n100\n0\n0\n66\n\n\n50\n100\n0\n0\n69\n\n\n\n\n\n\n# Criação da matriz de coeficientes de contraste\nX &lt;- matrix(c(1, 1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 0, 0, 0, -1, -1, 1, \n              1, 0, 0, 0), nrow = 7, byrow = FALSE)\n\n# Criação da matriz de rendimento\n\nY &lt;- as.matrix(yield)\n\n# Determinação dos coeficientes beta:\nbeta &lt;- solve(t(X) %*% X) %*% t(X) %*% Y\nbeta\n\n      [,1]\n[1,] 68.00\n[2,] -5.25\n[3,]  4.25\n\n\nThus, the linear function that expresses the response surface will be:\n\\[\ny=68.00-5.25*conc+4.25*agit\n\\tag{13.8}\\]\n\n13.3.1 Quadratic Response Surface\nSometimes the linear model may not fit the experimental design, which can be verified by an Analysis of Variance (ANAVA) of the experiment. In these cases, a quadratic surface methodology can be applied, which can be expressed as seen in Equação 13.5. In these cases, a construction called star planning is common, which adds an identical one rotated by 45\\(^{o}\\) to the initial planning, and whose new points are \\(\\sqrt{2}\\) coded units away from the central point. The example below aims to illustrate this methodology.\n\n# Dados para superfície quadrática de resposta\n\nconc &lt;- c(30, 40, 30, 40, 35, 35, 35, 28, 35, 42, 35)\nagit &lt;- c(115, 115, 135, 135, 125, 125, 125, 125, 139, 125, 119)\nx1 &lt;- c(-1, 1, -1, 1, 0, 0, 0, -sqrt(2), 0, sqrt(2), 0)\nx2 &lt;- c(-1, -1, 1, 1, 0, 0, 0, 0, sqrt(2), 0, -sqrt(2))\nrendim &lt;- c(86, 85, 78, 84, 90, 88, 89, 81, 80, 86, 87)\n\ntab.msr2 &lt;- data.frame(conc, agit, x1, x2, rendim)\nknitr::kable(tab.msr2, caption = \"Dados de experimento de metodologia de \n             superfície quadrática de resposta (Neto e cols, 2010).\", \"pipe\")\n\n\nDados de experimento de metodologia de superfície quadrática de resposta (Neto e cols, 2010).\n\n\nconc\nagit\nx1\nx2\nrendim\n\n\n\n\n30\n115\n-1.000000\n-1.000000\n86\n\n\n40\n115\n1.000000\n-1.000000\n85\n\n\n30\n135\n-1.000000\n1.000000\n78\n\n\n40\n135\n1.000000\n1.000000\n84\n\n\n35\n125\n0.000000\n0.000000\n90\n\n\n35\n125\n0.000000\n0.000000\n88\n\n\n35\n125\n0.000000\n0.000000\n89\n\n\n28\n125\n-1.414214\n0.000000\n81\n\n\n35\n139\n0.000000\n1.414214\n80\n\n\n42\n125\n1.414214\n0.000000\n86\n\n\n35\n119\n0.000000\n-1.414214\n87\n\n\n\n\n# tabela\n\nThis time the contrast coefficient matrix expands to six columns as a function of the terms x\\(_{1}^{2}\\), x\\(_{2}^{2}\\), and x\\(_{1}\\)x\\(_{2}\\), becoming:\n\\[\n\\begin{pmatrix}\n1 & -1 & -1 & 1 & 1 & 1 \\\\\n1 & 1 & -1 & 1 & 1 & -1 \\\\\n1 & -1 & 1 & 1 & 1 & -1 \\\\\n1 & 1 & 1 & 1 & 1 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & -\\sqrt(2) & 0 & 2 & 0 & 0 \\\\\n1 & 0 & \\sqrt(2) & 0 & 2 & 0 \\\\\n1 & \\sqrt(2) & 0 & 2 & 0 & 0 \\\\\n1 & 0 & -\\sqrt(2) & 0 & 2 & 0 \\\\\n\\end{pmatrix}\n\\]{#eq-msr2)\nThe procedure for the quadratic surface repeats the matrix operation performed with the linear one:\n\n# Creating the matrix of contrast coefficients for the quadratic surface\nX &lt;- matrix(c(rep(1, 11), -1, 1, -1, 1, 0, 0, 0, -sqrt(2),\n0, sqrt(2), 0, -1, -1, 1, 1, 0, 0, 0, 0, sqrt(2),\n0, -sqrt(2), 1, 1, 1, 0, 0, 0, 2, 0, 2, 0, 1, 1,\n1, 1, 0, 0, 0, 0, 2, 0, 1, 1,\n1, 1, 0, 0, 0, 0, 2, 0, 2, 1, -1, -1, 1, 0, 0, 0, 0,\n0, 0, 0), nrow = 11, byrow = FALSE)\n\nWarning in matrix(c(rep(1, 11), -1, 1, -1, 1, 0, 0, 0, -sqrt(2), 0, sqrt(2), :\ndata length [75] is not a sub-multiple or multiple of the number of rows [11]\n\n# Creating the yield matrix\nY &lt;- as.matrix(rendim)\n# Determining the beta coefficients:\nbeta &lt;- solve(t(X) %*% X) %*% t(X) %*% Y\nbeta\n\n          [,1]\n[1,] 89.505503\n[2,] -1.936109\n[3,] -4.129153\n[4,] -3.253803\n[5,] -5.832328\n[6,]  1.992845\n[7,]  2.169559\n\n\nThe result expresses the quadratic function of the surface found, as follows:\n\\[\ny=89.00+1.51*x_1-2.36*x_2-2.81*x_1^2-2.81*x_2^2+1.75*x_1*x_2\n\\tag{13.9}\\]\nFrom the result above it is possible to predict the optimized conditions for the test. In this sense, R allows, for example, the construction of a three-dimensional graph that represents the function obtained, and without the need for an additional package: as follows:\n\n## Quadratic response surface (MSR)\n\nx &lt;- seq(-1, 1, 0.1) # predictor x\ny &lt;- seq(-1, 1, 0.1) # predictor y\nmrs &lt;- function(x, y) {\n89.00 + 1.51 * x - 2.36 * y - 2.81 * x^2 - 2.81 * y^2 + 1.75 * x * y\n} # function applied to predictors\nz &lt;- outer(x, y, mrs) # 3D plot output (response)\nres &lt;- persp(x, y, z, xlab = \"x1\", ylab = \"x2\", zlab = \"z\",\nshade = 0.4, theta = 30, phi = 15, ticktype = \"detailed\")\n# surface plot of function z(x,y)\npoints &lt;- trans3d(x1, x2, rendim, pmat = res) # command for adding experimental points\npoints(points, pch = 19, col = 1) # adding points\n\n\n\n\nQuadratic surface described by the MSR equation with superposition of experimental values.\n\n\n\n\nHowever, there are some packages for R for three-dimensional representation of data and functions (rgl, plot3D, scatterplot3d), as well as for factorial design analysis (agricolae, afex, FMC), and response surface methodology (rsm).\n\n\n\n\nNeto, Benı́cio Barros, Ieda Spacino Scarminio, e Roy Edward Bruns. 2010. Como Fazer Experimentos-: Pesquisa e Desenvolvimento na Ciência e na Indústria. Bookman Editora.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Experimental design</span>"
    ]
  },
  {
    "objectID": "redes_en.html",
    "href": "redes_en.html",
    "title": "14  Metabolic Networks",
    "section": "",
    "text": "14.1 Biochemical pathways of metabolism\nA representation of the black box of enzymatic reactions. E = enzyme c,d = cofactors, coenzymes, modifiers; f,g = secondary compounds resulting from catalysis.\n\\[\nA\n\\begin{array}{c}\n_{k}\\\\\n\\rightarrow \\\\\n^{}\\end{array} B\n\\tag{14.1}\\]\n\\[\nv=\\frac{dy}{dx}=-\\frac{dA}{dt}=\\frac{dB}{dt}\n\\tag{14.2}\\]\n\\[\n\\frac{dA}{dt}= -k*A;\\\\\n\\frac{db}{dt} = k*B\n\\tag{14.3}\\]\n\\[\ndA=-k*A*dt;\\\\\ndB=k*A*dt\n\\tag{14.4}\\]\n\\[\n\\frac{dN}{dt}=-k*N; \\, N(t) = N_0*e^{-kt}; (N=N_0 \\,em \\, t=0)\n\\tag{14.5}\\]",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Metabolic Networks</span>"
    ]
  },
  {
    "objectID": "redes_en.html#redesMet",
    "href": "redes_en.html#redesMet",
    "title": "14  Metabolic Networks",
    "section": "",
    "text": "We can consider cellular metabolism as a network of homeostatically feedback metabolic pathways. If we zoom in on any of the biochemical reactions involved in this complex web, we can identify a black box common to all of them:\n\nAlthough the representation above may involve equilibrium reactions (double arrows), or even the absence of a catalyst, the image generalizes individual biochemical reactions that are part of any metabolic map. If we now wish to evaluate the consumption of compound A (reactant, substrate) and the resulting formation of compound B (product), that is, the levels of the compounds in a time interval, we can consider, as seen in the chapter on Enzymes), the reaction above as 1st order in both reactant and product:\n\nThus, the reaction rate can be considered as the variation of A or B over time as:\n\nIn other words, when there is consumption, the rate of variation is negative, and when there is formation, it is positive. Separating the two rates:\n\nAnd thus, to calculate the variation in each compound over a time interval:\n\nNote that we are dealing with a system of differential equations, nominally ordinary, since the changes in time occur as a function of a single parameter (species concentration). If it were a system dependent on more than one parameter, we would be dealing with partial differential equations (common in thermodynamic relations that involve changes with variations in volume, temperature, and pressure).\nSome differential equations can be solved analytically, such as those involving bacterial exponential growth:",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Metabolic Networks</span>"
    ]
  },
  {
    "objectID": "redes_en.html#numerical-solution-for-a-system-of-differential-equations",
    "href": "redes_en.html#numerical-solution-for-a-system-of-differential-equations",
    "title": "14  Metabolic Networks",
    "section": "14.2 Numerical solution for a system of differential equations",
    "text": "14.2 Numerical solution for a system of differential equations\nOn the other hand, when an equation or system of differential equations has a certain complexity for the analytical solution, the numerical solution is sought. Although there are several libraries for solving differential equations using R (deSolve, pracma, lsoda), some simple systems can be solved using the basic installation packages:\nThe simplest procedure uses the Euler method. The basic idea of ​​the method consists of integrating a differential function of infinitesimal variation in the independent variable (in this case, time), for a real relation, and from given initial values. Simply put, the value of the function will correspond to the increase of the increment dy for each interval dx, from the relation of each reaction involved in the transformation of the compounds. Example for the reactions present in Equação 14.4:\n\n\n\n# Solution of differential equations for conversion A--&gt;B\n\nk &lt;- 0.5 # kinetic constant of catalysis\ndt &lt;- .005\ntmax &lt;- 3 # time interval & maximum time\nt &lt;- seq(0, tmax, dt) # time vector\nn &lt;- tmax / dt + 1 # no. of simulation points (it is necessary to add 1 so that the vectors have the same size) \nx &lt;- matrix(rep(0, 2 * n), nrow = 2, ncol = n) # construction of the matrix of one row for each compound, and one column for each time dt \nx[1, 1] &lt;- 1 \nx[2, 1] &lt;- 0 # initial concentration values \nfor (i in 2:n) { \n  dA &lt;- -k * x[1, i - 1] * dt # dA \n  dB &lt;- k * x[1, i - 1] * dt # dB \n  x[1, i] &lt;- x[1, i - 1] + dA # variation in A with increase in dA x[2, i] &lt;- x[2, i - 1] + dB # variation in B with increase in dB # loop that adds the value of the new content to each interval dt composite\n}\nplot(t, x[1, ],\ntype = \"l\", lty = 1,\nxlab = \"time, s\", ylab = \"[species], M\", ylim = c(0, 1.025),\nbty = \"l\"\n) # plot of composite 1\nlines(t, x[2, ], lty = 2, col = 2) # add plot of composite 2\nlegend(\nx = 2, 5, y = 1, legend = c(\"A\", \"B\"), col = c(1, 2),\ncex = 1, lty = c(1, 2)\n)\n\n\n\n\nSolution of system of differential equations by Euler method for 1st order conversion of species A into B, at a kinetic rate k.\n\n\n\n\nExperiment with varying the kinetic constant k, or the initial values ​​for each compound, and observe the resulting effect. Metabolic reactions often present interconversions between compounds, such that a substrate of the reaction can also be configured as a product of catalysis of the same, and with kinetic rates of synthesis (k) and degradation (km, or k minus) for each compound, as follows:\n\\[\nA \\begin{array}{c}\n_{k}\\\\\n\\rightleftharpoons\\\\\n^{km} \\end{array} B\n\\tag{14.6}\\]\nIn this case, the system of differential equations will be:\n\\[\ndA=-k*A*dt+km*B*dt;\\\\\ndB=k*A*dt-km*B*dt\n\\tag{14.7}\\]\nImplementing the code snippet in R:\n\nk &lt;- 0.5\nkm &lt;- 0.5 # kinetic constants of catalysis\ndt &lt;- .005\ntmax &lt;- 10 # time interval & maximum time\nt &lt;- seq(0, tmax, dt) # define time vector\nn &lt;- tmax / dt + 1 # define no. of points\nx &lt;- matrix(rep(0, 2 * n), nrow = 2, ncol = n) # build a matrix with one\n# row for each compound, and one column for each time dt\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 1 # initial concentration values\nfor (i in 2:n) {\ndA &lt;- -k * x[1, i - 1] * dt + km * x[2, i - 1] * dt\ndB &lt;- k * x[1, i - 1] * dt - km * x[2, i - 1] * dt\nx[1, i] &lt;- x[1, i - 1] + dA\nx[2, i] &lt;- x[2, i - 1] + dB\n# loop that adds to each interval dt the new concentration value for\n# each compound\n}\nplot(t, x[1, ],\ntype = \"l\", lty = 1,\nxlab = \"time, s\", ylab = \"[species], M\", ylim = c(0, 2), bty = \"l\"\n) # graph of compound 1\nlines(t, x[2, ], lty = 2, col = 2) # addition of graph of compound 2\nlegend(\nx = 2, 5, y = 2, legend = c(\"A\", \"B\"), col = c(1, 2), cex = 1,\nlty = c(1, 2)\n)\n\n\n\n\nNumerical solution for the reversible conversion of species A into B. k = km = 0.5; Ao and Bo = 1 (initial contents).\n\n\n\n\nNote that the amounts of A and B remain constant throughout the interval. This is due to the identical values ​​of the kinetic constants for each forward and reverse reaction, as well as the identical initial amounts for each compound. Illustrating a variation of these:\n\n# Example of conversion A--&gt;B\n\nk &lt;- 0.5\nkm &lt;- 0.1 # kinetic constants of catalysis\ndt &lt;- .005\ntmax &lt;- 10 # time interval & maximum time\nt &lt;- seq(0, tmax, dt) # define time vector\nn &lt;- tmax / dt + 1 # define no. of points\nx &lt;- matrix(rep(0, 2 * n), nrow = 2, ncol = n) # build matrix of\n# one row for each compound, and one column for each time dt\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0.2 # initial concentration values\nfor (i in 2:n) {\ndA &lt;- -k * x[1, i - 1] * dt + km * x[2, i - 1] * dt\ndB &lt;- k * x[1, i - 1] * dt - km * x[2, i - 1] * dt\nx[1, i] &lt;- x[1, i - 1] + dA\nx[2, i] &lt;- x[2, i - 1] + dB\n# loop that adds to each interval dt the new concentration value for\n# each compound\n}\nplot(t, x[1, ],\ntype = \"l\", lty = 1,\nxlab = \"time, s\", ylab = \"[species], M\", ylim = c(0, 2), bty = \"l\"\n) # graph of compound 1\nlines(t, x[2, ], lty = 2, col = 2) # addition of graph of compound 2\nlegend(x = 2, 5, y = 2, legend = c(\"A\", \"B\"), col = c(1, 2), cex = 1, lty = c(1, 2))\n\n\n\n\nNumerical solution for the reversible conversion of species A to B. k = 0.5; km = 0.1; Ao = 1; Bo = 0.2 (initial contents).\n\n\n\n\nNow we can imagine a slightly more complex reaction, like the one illustrated in Equação 14.8:\n\\[\nA \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{km1} \\end{array} B\n\\begin{array}{c}\n_{k2}\\\\\n\\rightarrow \\\\\n^{}\\end{array}C\n\\tag{14.8}\\]\nIn this case, the system of differential equations will be:\n\\[\ndA=-k1*A*dt+km1*B*dt;\\\\\ndB=k1*A*dt-km1*B*dt-k2*B*dt;\\\\\ndC=k2*B\n\\tag{14.9}\\]\nImplementing the code snippet:\n\n# Euler solution for 3-compound kinetics\n\nk1 &lt;- 0.5\nkm1 &lt;- 0.1\nk2 &lt;- 1 # kinetic constants of catalysis\ndt &lt;- .005\ntmax &lt;- 3 # time interval & maximum time\nt &lt;- seq(0, tmax, dt) # define time vector\nn &lt;- tmax / dt + 1 # define no. of points\nx &lt;- matrix(rep(0, 3 * n), nrow = 3, ncol = n) # build matrix of\n# one row for each compound, and one column for each time dt\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0\nx[3, 1] &lt;- 0 # initial concentration values\nfor (i in 2:n) {\ndA &lt;- -k1 * x[1, i - 1] * dt + km1 * x[2, i - 1] * dt\ndB &lt;- k1 * x[1, i - 1] * dt - (km1 + k2) * x[2, i - 1] * dt\ndC &lt;- k2 * x[2, i - 1] * dt\nx[1, i] &lt;- x[1, i - 1] + dA\nx[2, i] &lt;- x[2, i - 1] + dB\nx[3, i] &lt;- x[3, i - 1] + dC # loop that adds to each interval dt\n# the new content value for each compound\n}\nplot(t, x[1, ],\ntype = \"l\", lty = 1,\nxlab = \"time, s\", ylab = \"[species], M\", ylim = c(0, 1.025), bty = \"l\"\n) # plot of compound 1\nlines(t, x[2, ], lty = 2, col = 2) # add plot of compound 2\nlines(t, x[3, ], lty = 3, col = 3) # add plot of compound 3\nlegend(x = 2, 5, y = 1, legend = c(\"A\", \"B\", \"C\"), col = c(1, 2, 3),\ncex = 1, lty = c(1, 2, 3))\n\n\n\n\n\n\n\nFigura 14.1: Euler solution for 3-compound kinetics. k1 = 0.5; k2 = 1; km1 = 0.1. Initial contents: Ao = 1; Bo = 0; Co = 0.\n\n\n\n\n\nNote that the Equação 14.9 above reflects a Michaelis-Mentem catalysis, although considering the enzyme content E as constant and, therefore, independent of the reaction (zero order). And also note that the graph of Figura 14.1 translates, in a way, the Briggs-Haldane steady-state condition discussed in Enzymes. Note that the variation of B, reflected in this condition as the complex ES, remains relatively constant for a certain period of time, being produced by the collision with the enzyme E, and deconstructed both by its conversion to E + P (in this case, C), and by its reversion to E + S (in this case, A).\nFor a slightly more complex reaction:\n\\[\nA \\begin{array}{c}\n_{k1}\\\\\n\\rightleftharpoons\\\\\n^{km1} \\end{array} B\n\\begin{array}{c}\n_{k2}\\\\\n\\rightleftharpoons\\\\\n^{km2}\\end{array}C\n\\tag{14.10}\\]\nWhat does the following code snippet in R suggest:\n\n# Euler solution for reversible kinetics of 3 compounds\n\n# constants of the forward reaction\nk1 &lt;- 3\nkm1 &lt;- 1\nk2 &lt;- 4\nkm2 &lt;- 0.7\ndt &lt;- .005\ntmax &lt;- 10\nt &lt;- seq(0, tmax, dt)\nn &lt;- tmax / dt + 1\nx &lt;- matrix(rep(0, 3 * n), nrow = 3, ncol = n)\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0\nx[3, 1] &lt;- 0\nfor (i in 2:n) {\n dA &lt;- -k1 * x[1, i - 1] * dt + km1 * x[2, i - 1] * dt\n dB &lt;- k1 * x[1, i - 1] * dt - (km1 + k2) * x[2, i - 1] * dt +\n km2 * x[3, i - 1] * dt\n dC &lt;- k2 * x[2, i - 1] * dt - km2 * x[3, i - 1] * dt\n x[1, i] &lt;- x[1, i - 1] + dA\n x[2, i] &lt;- x[2, i - 1] + dB\n x[3, i] &lt;- x[3, i - 1] + dC\n}\nplot(t, x[1, ],\n type = \"l\", lty = 1,\nxlab = \"time, s\", ylab = \"[species], mol/L\",\nylim = c(0, 1.025), bty = \"l\"\n)\nlines(t, x[2, ], col = 2, lty = 2)\nlines(t, x[3, ], col = 3, lty = 3)\nlegend(x = 8, y = 0.6, legend = c(\"A\", \"B\", \"C\"), col = c(1, 2, 3),\ncex = 1, lty = c(1, 2, 3))\n\n\n\n\nEuler solution for reversible kinetics of 3 compounds. k1 = 1; km1 = 3; k2 = 5; km1 = 0.1. Initial contents: Ao = 1; Bo = 0; Co = 0.\n\n\n\n\nNow, suppose a more complex chain of biochemical reactions, with negative (inhibition, ki) and positive (activation, ka) allosteric modulators for certain enzymes. The example below illustrates this situation:\n\n\n\n\n\nAn example of biochemical reactions in a fictitious metabolic pathway. The dotted arrows together with the ki and ka values ​​represent allosteric modulations with respective enzyme inhibition and activation constants.\n\n\n\n\nThus, the set of reactions in the metabolic network above can be equated as:\n\\[\ndA=-k1*A*dt+ka*F*dt;\\\\\ndB=k1*A*dt+km3*D*dt-k3*B*dt-k2*B*dt-ki*E*dt;\\\\\ndC=k2*B*dt;\\\\\n\\tag{14.11}\\]\n\\[\ndD=k3*B*dt-km3*D*dt-k4*D*dt;\\\\\ndE=k4*D*dt-k5*E*dt;\\\\\ndF=k5*E*dt-ka*F*dt\n\\tag{14.12}\\]\nThe following code snippet can be written for the numerical Euler solution involving the differential equations listed above as:\n\n# Solution for metabolic pathway with allosteric inhibition and activation\n\n# Kinetic and allosteric constants\nk1 &lt;- 2\nk2 &lt;- 0.5\nk3 &lt;- 0.7\nkm3 &lt;- 0.3\nk4 &lt;- 5\nk5 &lt;- 1\nki &lt;- 0.3 # inhibition constant\nka &lt;- 0.2 # activation constant\ndt &lt;- .005\ntmax &lt;- 10\nt &lt;- seq(0, tmax, dt)\nn &lt;- tmax / dt + 1\nx &lt;- matrix(rep(0, 6 * n), nrow = 6, ncol = n)\n# Initial values ​​of compounds\nx[1, 1] &lt;- 1\nx[2, 1] &lt;- 0\nx[3, 1] &lt;- 0\nx[4, 1] &lt;- 1\nx[5, 1] &lt;- 0\nx[6, 1] &lt;- 0\nfor (i in 2:n) {\n# system of equations inserted into the interval matrix\ndA &lt;- -k1 * x[1, i - 1] * dt + ka * x[6, i - 1] * dt\ndB &lt;- k1 * x[1, i - 1] * dt + km3 * x[4, i - 1] * dt - k3 *\n x[2, i - 1] * dt - k2 * x[2, i - 1] * dt - ki * x[1, i - 1] * dt\n dC &lt;- k2 * x[2, i - 1] * dt\n dD &lt;- k3 * x[2, i - 1] * dt - km3 * x[4, i - 1] * dt - k4 *\n x[4, i - 1] * dt\n dE &lt;- k4 * x[4, i - 1] * dt - k5 * x[5, i - 1] * dt\n dF &lt;- k5 * x[5, i - 1] * dt - ka * x[6, i - 1] * dt\n # Adding dy to y values\n x[1, i] &lt;- x[1, i - 1] + dA\n x[2, i] &lt;- x[2, i - 1] + dB\n x[3, i] &lt;- x[3, i - 1] + dC\n x[4, i] &lt;- x[4, i - 1] + dD\n x[5, i] &lt;- x[5, i - 1] + dE\n x[6, i] &lt;- x[6, i - 1] + dF\n}\n# Preparation of kinetic graphs\nplot(t, x[1, ],\n type = \"l\", lty = 1,\n xlab = \"time,s\", ylab = \"[species], mol/L\",\n ylim = c(0, 1.025), bty = \"l\"\n)\nlines(t, x[2, ], col = 2, lty = 2)\nlines(t, x[3, ], col = 3, lty = 3)\nlines(t, x[4, ], col = 4, lty = 4)\nlines(t, x[5, ], col = 5, lty = 5)\nlines(t, x[6, ], col = 6, lty = 6)\nlegend(x = 6.5, y = 0.65, legend = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"),\ncol = c(1, 2, 3, 4, 5, 6), cex = 1, lty = c(1, 2, 3, 4, 5, 6))\n\n\n\n\nSolution for a fictitious metabolic pathway presenting allosteric inhibition (ki) and activation (ka). Kinetic rates: k1 = 2, k2 = 0.5, k3 = 0.7, km3 = 0.3, k4 = 5, k5 = 1, ki = 0.3, ka = 0.2. Initial values ​​of the compounds: A = 1; B, C, D, E, F = 0\n\n\n\n\nChange the kinetic and/or allosteric constants of the system above and observe the effect on each of the compounds. In general, the Euler solution applied to systems of increasing complexity, such as a metabolic network, may present deviations centered on the selection of the value of dt, or even produce inconsistent values. To get around this situation, other algorithms are used, such as 2nd, 3rd, or 4th order Runge-Kutta, present in R packages, or even by systems analysis.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Metabolic Networks</span>"
    ]
  },
  {
    "objectID": "redes_en.html#some-reactions-of-glucose-metabolism",
    "href": "redes_en.html#some-reactions-of-glucose-metabolism",
    "title": "14  Metabolic Networks",
    "section": "14.3 Some reactions of glucose metabolism",
    "text": "14.3 Some reactions of glucose metabolism\nFor a 4th order Runge-Kutta method, it is necessary to install the deSolve package or similar to solve a system of 1st order ordinary differential equations or partial differential equations. The library aggregates functions that allow a leaner and simpler code for solving the system. Illustrating its application, here are some of the many simple relationships of the metabolic network that involves glycolysis, gluconeogenesis, and pentose pathway in cells:\n\n\n\n\n\nSome metabolic relationships involved in glycolysis, gluconeogenesis and pentose pathways.\n\n\n\n\nThe following metabolic reactions can be attributed to these relationships:\n\\[\nG6P\n\\begin{array}{c}\n_{k1}\\\\\n\\rightarrow \\\\\n^{}\\end{array} R5P\\\\\nG3P+DHCP\n\\begin{array}{c}\n_{k2}\\\\\n\\rightarrow \\\\\n^{}\\end{array} PEP\\\\\n2G3P\n\\begin{array}{c}\n_{k3}\\\\\n\\rightarrow \\\\\n^{}\\end{array} 6GP\\\\\nR5P\n\\begin{array}{c}\n_{k4}\\\\\n\\rightarrow \\\\\n^{}\\end{array} G3P\\\\\n2PEP\n\\begin{array}{c}\n_{k5}\\\\\n\\rightarrow \\\\ ^{}\\end{array} G6P\n\\tag{14.13}\\]\nThe code snippet for the Runge-Kutta solution can be the following example, with results in two graphs; initially with the curves isolated, and then combined.\n\nlibrary(deSolve)\n\n# Solution for conversion kinetics in some metabolic pathways\n\n# Reaction parameters\nk1 &lt;- 0.1\nk2 &lt;- 0.5\nk3 &lt;- 0.05\nk4 &lt;- 0.5\nk5 &lt;- 0.2\nparms &lt;- c(k1, k2, k3, k4, k5)\n\n# Initial values ​​for each compound\nG6P0 &lt;- 1\nR5P0 &lt;- 0\nG3P0 &lt;- 0.3\nDHCP0 &lt;- 0.1\nPEP0 &lt;- 0\n# Time interval\ntmin &lt;- 0\ntmax &lt;- 20\ndt &lt;- 0.01\ntime &lt;- seq(tmin, tmax, dt)\n# Function for the derivatives of the species in time\neq.dif &lt;- function(time, x, parms) {\n# compound specification\nG6P &lt;- x[1]\nR5P &lt;- x[2]\nG3P &lt;- x[3]\nDHCP &lt;- x[4]\nPEP &lt;- x[5]\n# differential equations\ndG6P &lt;- -k1 * G6P + k3 * G3P^2 + k5 * PEP^2\ndR5P &lt;- k1 * G6P - k4 * R5P\ndG3P &lt;- -k2 * G3P * DHCP - k3 * G3P^2 + k4 * R5P\ndDHCP &lt;- -k2 * G3P * DHCP\ndPEP &lt;- k2 * G3P * DHCP - k5 * PEP^2\nlist(c(dG6P, dR5P, dG3P, dDHCP, dPEP)) # increments of species\n}\n# lsoda routine for ordinary differential solution\n\nout &lt;- lsoda(c(G6P0, R5P0, G3P0, DHCP0, PEP0), time, eq.dif, parms,\nrtol = 1e-4, atol = 1e-6\n)\n# Output the result in vectors for each quantity (time and species)\nt &lt;- out[, 1]\nG6P &lt;- out[, 2]\nR5P &lt;- out[, 3]\nG3P &lt;- out[, 4]\nDHCP &lt;- out[, 5]\nPEP &lt;- out[, 6]\n# Graphing vertical\npar(mfrow = c(1, 5))\nplot(t, G6P, type = \"l\")\nplot(t, R5P, type = \"l\")\nplot(t, G3P, type = \"l\")\nplot(t, DHCP, type = \"l\")\nplot(t, PEP, type = \"l\")\n\n\n\n\nConversion kinetics for a simple metabolic network involving some reactions of glycolysis, gluconeogenesis and pentose pathway. Values ​​of kinetic constants: k1 = 0.1; k2 = 0.5; k3 = 0.05; k4 = 0.5; k5 = 0.2. Initial values ​​of the compounds: G6P = 1; for the others, 0.\n\n\n\n# Preparation of graph with all species\npar(mfrow = c(1, 1))\nplot(t, G6P, type = \"l\", col = 1, lty = 1, ylab = \"[species]\",\n ylim = c(0, 1))\nlines(t, R5P, type = \"l\", col = 2, lty = 2)\nlines(t, G3P, type = \"l\", col = 3, lty = 3)\nlines(t, DHCP, type = \"l\", col = 4, lty = 4)\nlines(t, PEP, type = \"l\", col = 5, lty = 5)\nlegend(x = 10, y = 1, legend = c(\"G6P\", \"R5P\", \"G3P\", \"DHCP\", \"PEP\"),\ncol = c(1, 2, 3, 4, 5), cex = 1, lty = c(1, 2, 3, 4, 5))\n\n\n\n\nConversion kinetics for a simple metabolic network involving some reactions of glycolysis, gluconeogenesis and pentose pathway. Values ​​of kinetic constants: k1 = 0.1; k2 = 0.5; k3 = 0.05; k4 = 0.5; k5 = 0.2. Initial values ​​of the compounds: G6P = 1; for the others, 0.\n\n\n\n\nNote that, by the quantities offered to the simulation, that is, kinetic constants and initial values, G3P and PEP register a significant interval in elevation, also coincident with their presence in several of the relations of Equação 14.13.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Metabolic Networks</span>"
    ]
  },
  {
    "objectID": "redes_en.html#kinetics-of-6-mercaptopurine-metabolism",
    "href": "redes_en.html#kinetics-of-6-mercaptopurine-metabolism",
    "title": "14  Metabolic Networks",
    "section": "14.4 Kinetics of 6-mercaptopurine metabolism",
    "text": "14.4 Kinetics of 6-mercaptopurine metabolism\nRaising the complexity of metabolic networks a little, we can illustrate the cellular metabolism of 6-mercaptopurine (6-MP) as a function of cellular ATP content (Lavrova et al. 2017). As a purine antagonist, the drug is used in chemotherapy for the treatment of lymphocytic leukemia, interrupting cell growth, although it produces cytotoxic side effects arising from reactions with the thiol group.\nFigura 14.2 represents a simplified scheme of the metabolism of 6-MP. The concentrations of the species and kinetic constants originate from the concentration values ​​in \\(\\mu\\)mol/mL, and time in days.\n\n\n\n\n\n\n\n\nFigura 14.2: Simplified schematic of 6-mercaptopurine metabolism (adapted from Lavrova et al., 2017).\n\n\n\n\n\nFor the 10 reactions related to the ODEs that make up the representation of 6-MP metabolism (Lavrova et al. 2017), the code snippet below implements the 4th order Runge-Kutta solution by the lsoda function:\n\n# Degradation of 6-mercaptopurine and Runge-Kutta solution\n\nlibrary(deSolve)\n# Parameters\nk0 &lt;- 5\nk1 &lt;- 10\nk2 &lt;- 10\nk3 &lt;- 5\nk4 &lt;- 1e-5\nk7 &lt;- 0.01\nk8 &lt;- 0.5\nkm7 &lt;- 1\nkm1 &lt;- 0.01\nkm2 &lt;- 4\nkm3 &lt;- 0.01\nkm4 &lt;- 0.1\nkm8 &lt;- 0.01\nVPUR &lt;- 0.01\nVD &lt;- 0.9\nVOUT &lt;- 1e-4\n# Parameter list\nparms &lt;- c(k0, k1, k2, k3, k4, k7, k8, km7, km1, km2, km3, km4, km8,\nVPUR, VD, VOUT)\n# compound specification\nMPex &lt;- x[1]\nMPin &lt;- x[2]\nTIMP &lt;- x[3]\nTXMP &lt;- x[4]\nTGMP &lt;- x[5]\nmeTGMP &lt;- x[6]\nTITP &lt;- x[7]\nATP &lt;- x[8]\nAMP &lt;- x[9]\nPP &lt;- x[10]\n# initial concentrations of species\nreag0 &lt;- c(MPex0 = 0.68, MPin0 = 0, TIMP0 = 0, TXMP0 = 0, TGMP0 = 0,\nmeTGMP0 = 0, TITP0 = 0, ATP0 = 0.2, AMP0 = 0, PP0 = 0)\n\n# time interval definition\ntmin &lt;- 0\ntmax &lt;- 2\ndt &lt;- 0.01\ntime &lt;- seq(tmin, tmax, dt)\n# Function for the derivatives of each species\neq.dif &lt;- function(time, x, parms) {\n# Parameter definition\nMPex &lt;- x[1]\nMPin &lt;- x[2]\nTIMP &lt;- x[3]\nTXMP &lt;- x[4]\nTGMP &lt;- x[5]\nmeTGMP &lt;- x[6]\nTITP &lt;- x[7]\nATP &lt;- x[8]\nAMP &lt;- x[9]\nPP &lt;- x[10]\n# Differential equations\ndMPex &lt;- -k0 * MPex\ndMPin &lt;- -(VPUR + k1) * MPin + k0 * MPex + km1 * TIMP\ndTIMP &lt;- k1 * MPin + km8 * TITP - (k2 + k7 * ATP + km1 + k8 * PP) *\nTIMP + km2 * TXMP + km7 * TITP * AMP\ndTXMP &lt;- k2 * TIMP - k3 * TXMP * ATP - km2 * TXMP + km3 * TGMP *\n AMP * PP\n dTGMP &lt;- k3 * TXMP * ATP - (k4 + VD) * TGMP - km3 * TGMP * AMP *\n PP + km4 * meTGMP\n dmeTGMP &lt;- k4 * TGMP - VOUT * meTGMP - km4 * meTGMP\n dTITP &lt;- k8 * TIMP * PP - km8 * TITP + k7 * TIMP * ATP - km7 *\n TITP*AMP\n dATP &lt;- -k7 * TIMP * ATP + km3 * TGMP * AMP * PP - k3 * TXMP *\n ATP + km7 * TITP * AMP\n dAMP &lt;- -km3 * TGMP * AMP * PP + k3 * TXMP * ATP + k7 * TIMP *\n ATP - km7 * TITP * AMP\ndPP &lt;- -k8 * TIMP * PP + km8 * TITP - km3 * TGMP * AMP * PP + k3 *\nTXMP * ATP\nlist(c(dMPex, dMPin, dTIMP, dTXMP, dTGMP, dmeTGMP, dTITP, dATP,\ndAMP, dPP)) # list of differential values ​​for each species\n}\n# lsoda routine for solving differential equations ordinary\nsol.eq &lt;- lsoda(reag0, time, eq.dif, parms,\nrtol = 1e-4, atol = 1e-6\n)\n# Isolating the result columns\nt &lt;- sol.eq[, 1]\nMPex &lt;- sol.eq[, 2]\nMPin &lt;- sol.eq[, 3]\nTIMP &lt;- sol.eq[, 4]\nTXMP &lt;- sol.eq[, 5]\nTGMP &lt;- sol.eq[, 6]\nmeTGMP &lt;- sol.eq[, 7]\nTITP &lt;- sol.eq[, 8]\nATP &lt;- sol.eq[, 9]\nAMP &lt;- sol.eq[, 10]\nPP &lt;- sol.eq[, 11]\n\n# Creating the graph\nplot(t, MPex, type = \"l\", xlab = \"tempo, days\",\n ylab = \"[species], umol/L\")\nlines(t, MPin, type = \"l\", col = 2, lty = 2)\nlines(t, TIMP, type = \"l\", col = 3, lty = 3)\nlines(t, TXMP, type = \"l\", col = 4, lty = 4)\nlines(t, TGMP, type = \"l\", col = 5, lty = 5)\nlines(t, meTGMP, type = \"l\", col = 6, lty = 6)\nlines(t, TITP, type = \"l\", col = 7, lty = 7)\nlines(t, ATP, type = \"l\", col = 8, lty = 8)\nlines(t, AMP, type = \"l\", col = 9, lty = 9)\nlines(t, PP, type = \"l\", col = 10, lty = 10)\nlegend(x = 1.5, y = 0.65, legend = c(\"MPex\", \"MPin\", \"TIMP\", \"TXMP\",\n \"TGMP\", \"meTGMP\", \"TITP\", \"ATP\",\n \"AMP\", \"PP\"), col = c(1, 2, 3, 4,\n 5, 6, 7, 8,\n 9, 10),\n cex = 0.7, lty = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n\n\n\n\nDependence of the dynamics of the metabolic network of 6-mercaptopurine degradation as a function of the initial ATP content at 0.2 umol/L. The values s initials and parameters are described in the code snippet.\n\n\n\n\nSince the dynamics of variation of the compounds is dependent on the initial cellular ATP content, try varying this initial value (e.g.: ATP0=2):\n\n\n\n\n\nDependence of the dynamics of the metabolic network for degradation of 6-mercaptopurine as a function of the initial ATP content at 2 umol/L. The initial values ​​and parameters are described in the code snippet.\n\n\n\n\nNote that, with the 10x reduction in ATP content, TGMP and TIMP maintained more stable levels throughout the period.\n\n\n\n\nLavrova, Anastasia I, Eugene B Postnikov, Andrey Yu Zyubin, e Svetlana V Babak. 2017. «Ordinary differential equations and Boolean networks in application to modelling of 6-mercaptopurine metabolism». Royal Society Open Science 4 (4): 160872.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Metabolic Networks</span>"
    ]
  },
  {
    "objectID": "referencias_en.html",
    "href": "referencias_en.html",
    "title": "15  References",
    "section": "",
    "text": "AKAIKE, H. A new look at the statistical model identification. IEEE transactions on automatic control, [s. l.], vol. 19, n.º 6, p. 716–723, 1974.\n\n\nALBERTY, R. A. Calculation of biochemical net reactions and pathways by using matrix operations. Biophysical journal, [s. l.], vol. 71, n.º 1, p. 507–515, 1996.\n\n\nALBERTY, R. A. Chemical equations are actually matrix equations. Journal of chemical education, [s. l.], vol. 68, n.º 12, p. 984, 1991.\n\n\nBHATTI, H. N. et al. Effect of aniline coupling on kinetic and thermodynamic properties of Fusarium solani glucoamylase. Applied microbiology and biotechnology, [s. l.], vol. 73, n.º 6, p. 1290–1298, 2007.\n\n\nBLOOMFIELD, V. Computer simulation and data analysis in molecular biology and biophysics: an introduction using R. [S. l.]: Springer Science & Business Media, 2009.\n\n\nCOOPER, A. Thermodynamics and interactions. Em: BIOPHYSICAL CHEMISTRY. [S. l.: s. n.], 2004. p. 99–122.\n\n\nCREIGHTON, T. E. et al. biophysical chemistry of nucleic acids & proteins. [S. l.]: Distributed by Gardners Books, 2010.\n\n\nDAHLQUIST, F. [13] The meaning of scatchard and hill plots. Methods in enzymology, [s. l.], vol. 48, p. 270–299, 1978.\n\n\nDELEAN, A.; MUNSON, P.; RODBARD, D. Simultaneous analysis of families of sigmoidal curves: application to bioassay, radioligand assay, and physiological dose-response curves. American Journal of Physiology-Endocrinology And Metabolism, [s. l.], vol. 235, n.º 2, p. E97, 1978.\n\n\nDUFF, D.; GILES, C. Spectrophotometric determination of the critical micelle concentration of surfactants. Journal of Colloid and Interface Science, [s. l.], vol. 41, n.º 3, p. 407–414, 1972.\n\n\nEDELHOCH, H.; OSBORNE JR, J. C. The thermodynamic basis of the stability of proteins, nucleic acids, and membranes. Advances in protein chemistry, [s. l.], vol. 30, p. 183–250, 1976.\n\n\nGANDRUD, C. Reproducible research with R and RStudio. [S. l.]: Chapman; Hall/CRC, 2018.\n\n\nJOHNSON, K. A. 1 transient-state kinetic analysis of enzyme reaction pathways. Em: THE ENZYMES. [S. l.]: Elsevier, 1992. vol. 20, p. 1–61.\n\n\nKHALIL, M. I. Calculating enthalpy of reaction by a matrix method. Journal of Chemical Education, [s. l.], vol. 77, n.º 2, p. 185, 2000.\n\n\nLAVROVA, A. I. et al. Ordinary differential equations and Boolean networks in application to modelling of 6-mercaptopurine metabolism. Royal Society Open Science, [s. l.], vol. 4, n.º 4, p. 160872, 2017.\n\n\nLEONE, F. de A. Fundamentos de Cinética Enzimática. [S. l.]: Appris Ed., 2021.\n\n\nLICATA, V. J.; LIU, C.-C. Analysis of free energy versus temperature curves in protein folding and macromolecular interactions. Methods in enzymology, [s. l.], vol. 488, p. 219–238, 2011.\n\n\nMICHAELIS, L.; MENTEN, M. Die Kinetik der Invertinwirkung. Biochem Z, [s. l.], vol. 49, n.º 4, p. 333–369, 1913.\n\n\nNETO, B. B.; SCARMINIO, I. S.; BRUNS, R. E. Como Fazer Experimentos-: Pesquisa e Desenvolvimento na Ciência e na Indústria. [S. l.]: Bookman Editora, 2010.\n\n\nOSBORNE JR, J. C. et al. The thermodynamics of the self-association of the reduced and carboxymethylated form of apoA-II from the human high density lipoprotein complex. Biochemistry, [s. l.], vol. 15, n.º 2, p. 317–320, 1976.\n\n\nOTAKI, J. M. et al. Availability of short amino acid sequences in proteins. Protein science, [s. l.], vol. 14, n.º 3, p. 617–625, 2005.\n\n\nPARSONS, D.; VALLNER, J. Theoretical models for cooperative binding—I. one-site creator of binding sites. Mathematical Biosciences, [s. l.], vol. 41, n.º 3-4, p. 189–215, 1978.\n\n\nPAULING, L. The oxygen equilibrium of hemoglobin and its structural interpretation. Proceedings of the National Academy of Sciences of the United States of America, [s. l.], vol. 21, n.º 4, p. 186, 1935.\n\n\nPO, H. N.; SENOZAN, N. The Henderson-Hasselbalch equation: its history and limitations. Journal of Chemical Education, [s. l.], vol. 78, n.º 11, p. 1499, 2001.\n\n\nROSS, P. D.; SUBRAMANIAN, S. Thermodynamics of protein association reactions: forces contributing to stability. Biochemistry, [s. l.], vol. 20, n.º 11, p. 3096–3102, 1981.\n\n\nSARKAR, D. Lattice: multivariate data visualization with R. [S. l.]: Springer Science & Business Media, 2008.\n\n\nSCATCHARD, G. The attractions of proteins for small molecules and ions. Annals of the New York Academy of Sciences, [s. l.], vol. 51, n.º 4, p. 660–672, 1949.\n\n\nSPIESS, A.-N.; NEUMEYER, N. An evaluation of R2 as an inadequate measure for nonlinear models in pharmacological and biochemical research: a Monte Carlo approach. BMC pharmacology, [s. l.], vol. 10, n.º 1, p. 1–11, 2010.\n\n\nTANG, L. et al. Kinetic mechanism and enantioselectivity of halohydrin dehalogenase from Agrobacterium radiobacter. Biochemistry, [s. l.], vol. 42, n.º 18, p. 5378–5386, 2003.\n\n\nTONG, J. et al. QSAR studies of TIBO derivatives as HIV-1 reverse transcriptase inhibitors using HQSAR, CoMFA and CoMSIA. Journal of Molecular Structure, [s. l.], vol. 1168, p. 56–64, 2018.\n\n\nTRAUT, T. W. Allosteric regulatory enzymes. [S. l.]: Springer Science & Business Media, 2007.\n\n\nTYUMA, I.; IMAI, K.; SHIMIZU, K. Analysis of oxygen equilibrium of hemoglobin and control mechanism of organic phosphates. Biochemistry, [s. l.], vol. 12, n.º 8, p. 1491–1498, 1973.\n\n\nWAELBROECK, M.; VAN OBBERGHEN, E.; DE MEYTS, P. Thermodynamics of the interaction of insulin with its receptor. Journal of Biological Chemistry, [s. l.], vol. 254, n.º 16, p. 7736–7740, 1979.\n\n\nWICKHAM, H. ggplot2. Wiley interdisciplinary reviews: computational statistics, [s. l.], vol. 3, n.º 2, p. 180–185, 2011.\n\n\nWILKINSON, G. Statistical estimations in enzyme kinetics. Biochemical Journal, [s. l.], vol. 80, n.º 2, p. 324–332, 1961.\n\n\nXIE, Y. Dynamic Documents with R and knitr. 2nd. ed. Boca Raton, Florida: Chapman; Hall/CRC, 2015. Disponível em: http://yihui.org/knitr/. \n\n\nYUNG-CHI, C.; PRUSOFF, W. H. Relationship between the inhibition constant (KI) and the concentration of inhibitor which causes 50 per cent inhibition (I50) of an enzymatic reaction. Biochemical pharmacology, [s. l.], vol. 22, n.º 23, p. 3099–3108, 1973.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>References</span>"
    ]
  }
]