[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ERtools",
    "section": "",
    "text": "1 TODO\nBloomfield - xii - códigos do livro - convesão unidades - p11\n*** Outros - ver pacotes baseados em ggplot2 (e graphics) - reproduzir ggplot2 com graphics - completar com meus tutoriais de R - completar com ER tools do GDocs - usar pacote datasets pra exemplos - heat mapa\nO ER é legal !!!"
  },
  {
    "objectID": "index.html#documentos-dinâmicos",
    "href": "index.html#documentos-dinâmicos",
    "title": "ERtools",
    "section": "2.1 Documentos dinâmicos",
    "text": "2.1 Documentos dinâmicos\n      Um documento dinâmico poderá ter:\n\nTexto estilizado\n\n\nformatação de fonte (negrito, itálico, tamanho, super e subscrito, tachado)\ncaracteres especiais (grego)\nsubtítulos estilizados nas seções\n\n\nEquação\nFigura\nGráfico\nTabela\nCronograma\nFluxograma / Diagrama\nReferências bibliográficas\nReferências cruzadas (figura, gráfico, tabela, equação)\nAnálise de dados\nCálculos\nPacotes de LaTex\n\n\n tamanhos de etiquetas, espessura, e valores dos eixos\n- diferenciar estética pra &gt; 1 grupo\n- criar paineis\n- ajustar linha e curva\n- ajustes linear e não linear (sigmoide, hipérbole, eq. de usuário)\n- ajuste não linear como camada adicionada produzida por geom_curve ou similar a partir de parâmetros de ajuste fora do ggplot2\n- reprodução de plots e análise de artigos \n- sobre o que é: gráficos e análise com poucos dados (bancada)\n- sobre o que não é: data science\n- simulações\n- 3 sistemas gráficos\n- programação básica\n- shiny, knitr, plotly\n- soluções numéricas e analíticas\n- Anava, testes pos-hoc, planejamento \n\nreceitas super-simples\nbem direto e asteísta\nsoluções pra problemas comuns (teste-t, gráfico de barras com erros)\nnotas de rodapé com dicas e pacotes avançados \nquando estiver entendendo melhor…recupera o ScriptRplot\n\n\n\n\n\no que uma pessoa precisa após obter o dado\ncarregar os dados: compilar o dado numa planilha…ou analisá-lo diretamente no R\nplotar pra ver a relação entre variáveis (plot, pairs)\nacrescentar linha pontilhada em determinado marco\nanalisar os dados: sumário estatístico, diferenças de médias/variâncias, testes pos-hoc\nplot de subconjuntos mais desejados\nsimular um cenário e observar parâmetros de uma equação\nproduzir gráficos de qualidade pra publicação\n\nPra carregar os dados:\ncopiando e colando \ncriando\nna unha\ncolando de planilha\njuntando vetores\ncriando dataframe ou matriz\nimportando (Excel, csv)\n\nPra fazer um plot:\nSeleciona as variáveis de um dataset (ou faz o plot de um contendo apenas x e y), ou seleciona um subconjunto desejado, ou seleciona alguma estatística dos dados (mean e sd de triplicatas - 3 vetores y, por ex)\nProcessa dos dados\npra evitar missing data (na.rm=TRUE)\npra transformar variáveis\nEscolhe um tipo de plot (pontos, linhas, barras)\nFaz o plot\nSe tiver barras de erros, já coloca antes (ou depois)\nColoca (ou não) legenda\nMelhora a visualização (símbolo, tamanho, cor, fonte, eixos)\nAltera as etiquetas de eixos\nAdiciona outro eixo, se necessário\nEscreve algo no plot\nAdiciona uma linha de marcação no plot -  (abline(h=0))\nAltera plano de fundo\nVerifica relação entre variáveis (modelagem)- linear, polinomial, curvilinear (não linear)\nObtém os parâmetros do modelo\nInforma no plot o modelo/parâmetros\nRefina o plot pra publicação\n\nER RAcional\n\nCria um projeto\nCustomiza (ou não) o _yaml\nRedige texto com numeração (#)\nCria-se chunks e suas características\nInsere-se comentários nos chunks;   #\nPode-se ressaltar texto com cores\nPode-se ressaltar chunks com formatações específicas\nPode-se inserir imagens e formatá-las\nO mesmo para gráficos, tabelas, simulações, animações"
  },
  {
    "objectID": "intro.html#r-como-ferramenta-para-.",
    "href": "intro.html#r-como-ferramenta-para-.",
    "title": "Projetos",
    "section": "R como ferramenta para ….",
    "text": "R como ferramenta para ….\n\nmencionar programação orientada a objeto\nmencionar programação vectorizada"
  },
  {
    "objectID": "projetos.html#criação-de-projeto",
    "href": "projetos.html#criação-de-projeto",
    "title": "2  Introdução",
    "section": "2.1 Criação de projeto",
    "text": "2.1 Criação de projeto\n      Pode-se considerar como um projeto, digamos, tudo que se desejar fazer pelo ‘R & RStudio’ de forma organizada. Elencam-se aí documentos simples, slides, e livros, dentre outros. Seja qual o tipo de projeto a que se destina, a criação é muito parecida. Como ambiente de desenvolvimento integrado (ou IDE da sigla em inglês), o RStudio permite a criação de projetos por ponteiro de mouse.\n      Alternativamente, o projeto pode ser criado por linha de comando no Terminal, quer do próprio RStudio como pelo R, esse com ou sem interface gráfica (ou GUI, da sigla em inglês).\n\n2.1.1 Criação de projeto pelo RStudio\n      Para tanto, siga as instruções que seguem:\n\nClique em File (ou em sua tradução para Português, dependendo da instalação do programa);\nSelecione na sequência, New Project, New Directory, Quarto Project;\nPreencha os campos (novo diretório, por ex) e selecione alguma característica para o projeto (editor visual, por ex);\nPronto ! Pressupondo-se que o projeto chama-se “teste”, o sistema irá disponibilizar um projeto simples contendo quatro arquivos, a saber:\n\n\nteste.Rproj # arquivo principal do projeto \ntest.qmd # arquivo de documento do projeto\n.gitignore # arquivo de informação de compartilhamento em repositório (Git)\n_quarto.yml # arquivo de metadados\n\n      Dos arquivos acima, pode-se traduzir cada um como:\n\n.Rproj - arquivo que conterá todas as informações do projeto, como o caminho de diretório, pastas e subpastas, scripts, e outros documentos. É o arquivo que, quando clicado num explorador de arquivos, apresenta o projeto e seu conteúdo.\n.qmd - arquivo em que será inserido texto e/ou códigos. É como um arquivo DOCX (MS-Word) ou ODT (Libreoffice), onde a digitação será compilada para um produto final (HTML, PDF, EPUB, ODT). A sigla refere-se a Quarto Markup Document.\n*_quarto.yml* - arquivo de configuração que contém toda a informação necessária para a compilação do(s) arquivo(s) .qmd constantes do projeto. Essas informações incluem o tipo de documento gerado (PDF, HTML, por ex), título, autor, data, e formatações gerais do documento final. O atributo yml é uma abreviação de yaml, um acrónimo recursivo para YAML (“Ain’t Markup Language” ou “Yet Another Markup Language). Trata-se de uma linguagem para dados de leitura relativamente fácil (human-readable) empregada na escrita de arquivos de configuração, e voltada para dados e não para documentos.\n\n      Agora, traduzindo a tradução propriamente dita, dois arquivos são vitais na compilação; o arquivo .qmd, ou vários desses, como uma folha de papel onde será escrito o documento, e o arquivo *_quarto.yml*, onde será escrita toda a configuração para a compilação.\n      E desse dois, o arquivo *_quarto.yml* é normalmente utilizado na compilação de mais de um arquivo .qmd, repassando a esses toda a configuração desejada (como a sequência de capítulos de um livro, cada qual escrito como um documento .qmd separadamente). Se a ideia é elaborar apenas um arquivo de documento, dinâmico ou não, basta a criação de um documento simples, como descrito mais embaixo.\n\n\n2.1.2 Criação de projeto pelo Terminal\n      Nesse caso, não é necessário o RStudio, como mencionado acima, mas um terminal de prompt de comando, tal como o CMD (Windows) ou Terminal (Linux). Algumas opções para se digitar num Terminal para a criação de um projeto incluem:\n\nquarto create project # abre janela de opções pra projeto\nquarto create project &lt;tipo&gt; &lt;nome&gt; # cria o projeto já identificado"
  },
  {
    "objectID": "projetos.html#rodando-um-projeto",
    "href": "projetos.html#rodando-um-projeto",
    "title": "2  Introdução",
    "section": "2.2 Rodando um projeto",
    "text": "2.2 Rodando um projeto\n      Para se “rodar” o projeto, ou seja, para que o algoritmo realize a compilação, tanto de textos como de códigos, também existem opções por ponteiro de mouse ou por Terminal.\n\n2.2.1 Compilando por mouse\n      Algumas alternativas também possibilitam “rodar” o documento, tais como:\n\nPor atalho, Ctrl + Shift + K (K de knitr, a máquina por traz do algoritmo…ou vice-versa);\nClicando-se em File, Render Document;\nClicando-se no ícone de uma seta azul seguido de Render, abaixo do menu principal.\n\n\n\n2.2.2 Compilando por Terminal\n      Por outro lado, a compilação de um documento dinâmico por Terminal também pode dar-se de várias formas, como:\n\nquarto render # renderiza o projeto no diretório\nquarto render meuprojeto # renderiza um projeto específico\nquarto render articles # renderiza um tipo de documento do subdiretório (também por Ctrl+Shift+K)\nquarto render --to pdf  \n... ou ....   quarto render meuprojeto --to pdf # renderiza para MS-Word\nquarto render meudoc.qmd --to odt # renderiza para Libreoffice (Writer)"
  },
  {
    "objectID": "projetos.html#linguagem-do-projeto",
    "href": "projetos.html#linguagem-do-projeto",
    "title": "2  Introdução",
    "section": "2.3 Linguagem do projeto",
    "text": "2.3 Linguagem do projeto\n      Pode-se definir a linguagem (ex: en, pt, es) para um documento único (arquivo .qmd) ou para todo projeto (ex: livro). Para tanto:\n\n2.3.1 Para um documento único\n      Basta acrescentar a linha de comando no cabeçalho do documento:\n\n---\ntitle: \"Documento\"\nlang: pt\n---\n\n\n\n2.3.2 Para um projeto\n      Nesse caso, a alteração se dará em todos os arquivos .qmd do projeto, sendo necessário uma inclusão simples no arquivo *_quarto.yml* de metadados:\n\nproject:\n  type: book\n  \nbook:\n  title: \"Meulivro\"\n  author: \"Eu\"\n  date: \"x/xx/xxxx\"\n  language: pt"
  },
  {
    "objectID": "projetos.html#um-documento-dinâmico-simples",
    "href": "projetos.html#um-documento-dinâmico-simples",
    "title": "2  Introdução",
    "section": "2.4 Um documento dinâmico simples",
    "text": "2.4 Um documento dinâmico simples\n      O pacote ´quarto´ permite a elaboração de diversos tipos de documentos dinâmicos, destacando-se apresentações, animações, livros, e documentos mais simples. Iniciando por esses é possível perceber o racional de produção dos demais.\n      Um documento dinâmico simples pode ser pensado como um documento de editor de texto estilizado, embora com a possibilidade de inserção e execução de linhas de comandos para execução de tarefas e programação. Tendo em mente a estrutura mais simples, um documento estilizado poderá conter:\n\nTítulo;\nSubtítulos;\nTexto estilizado;\nComentários não visíveis;\nObjeto complementar (imagem, tabela, gráfico, equação).\n\n      As etapas abaixo descrevem a elaboração de um documento simples."
  },
  {
    "objectID": "projetos.html#título",
    "href": "projetos.html#título",
    "title": "2  Introdução",
    "section": "2.5 Título",
    "text": "2.5 Título\n\n2.5.1 Compilando o documento"
  },
  {
    "objectID": "projetos.html#subtítulos",
    "href": "projetos.html#subtítulos",
    "title": "2  Introdução",
    "section": "2.6 Subtítulos",
    "text": "2.6 Subtítulos\n      Subtítulos são inseridos automaticamente em sequência numérica e com fontes estilizadas (negrito) de tamanhos distintos. São alocados simplesmente por número de hashtags inseridos antes. Existem 6 níveis (ex: 1.2, 2.4.1, etc), e que são indexados por #, ##, ###, ####, #####, ######.\n      Desejando-se que a numeração não apareça no subtítulo, ou que não seja listada no sumário inicial (quando a opção de docuemnto é livro; TOC (Table of Contents), bastas os comandos:\n\n## subtítulo {.unnumbered} # não aparece no título\n## subtítulo {.unlisted .unnumbered} # não é listada no TOC"
  },
  {
    "objectID": "projetos.html#texto-estilizado",
    "href": "projetos.html#texto-estilizado",
    "title": "2  Introdução",
    "section": "2.7 Texto estilizado",
    "text": "2.7 Texto estilizado\n      Usando-se Rmarkdown é possível estabelecer com facilidade termos em negrito, itálico, etc, tal como segue:\n\n*itálico* # itálico\n**negrito** # negrito\n~~cortado~~ # cortado\n^2^ # superescrito\n*** # linha horizontal"
  },
  {
    "objectID": "projetos.html#estilo-de-texto",
    "href": "projetos.html#estilo-de-texto",
    "title": "2  Introdução",
    "section": "2.8 Estilo de texto",
    "text": "2.8 Estilo de texto\n      Usando-se Rmarkdown é possível estabelecer com facilidade termos em negrito, itálico, etc, tal como segue:\n\n*itálico* ou _itálico_# itálico\n**negrito** ou __negrito__ # negrito\n~~cortado~~ # cortado\nx^2^ # superescrito\n-- # linha curta\n--- # linha não tão curta\n\n\n2.8.1 Listas\n      Listas podem apresentar-se com ou sem numeração. Para as últimas, ítens e subítens podem explicitar-se como segue:\n\n* item 1\n* item 2\n+ subitem 1\n+ subitem 2\n\n      O resultado do trecho acima fica:\n\nitem 1\nitem 2\nsubitem 1\nsubitem 2\n\n      Já para uma lista numerada pode-se espelhar o exemplo acima. Pode-se elaborá-la enumerando-se manualmente ou, de forma mais prática, automaticamente, nesse caso bastando-se inserir “1.” para todos os ítens da lista.\n\n1. item 1\n1. item 2\n+ subitem 1\n+ subitem 2\n\nO resultado ficará como:\n\nitem 1\nitem 2\n\n\nsubitem 1\nsubitem 2\n\n\n\n2.8.2 Fontes\n\n\n\n2.8.3 Cores\ncor de texto: Roses are , violets are ."
  },
  {
    "objectID": "projetos.html#comentários",
    "href": "projetos.html#comentários",
    "title": "2  Introdução",
    "section": "2.9 Comentários",
    "text": "2.9 Comentários\n      É sempre desejável conhecer o significado de um conjunto de comandos, ou a essência de uma solução para um problema, uma lista de afazeres (ToDo), um trecho que se está experimentando, ou que foi colado de outra fonte para observação, ou qualquer informação que não se deseja visualizar no documento final, ou em preparação.\n      A inserção de comentários dá-se pelo atalho Shift + Ctrl + C, ao iniciar uma linha (pra um subtítulo, por ex), ao final dessa (pra uma explicação sobre o código), ou para um trecho selecionado. Para desfazer o comentário, basta repetir o atalho."
  },
  {
    "objectID": "contrVer.html#criando-um-projeto-no-rstudio-para-versionamento-de-código",
    "href": "contrVer.html#criando-um-projeto-no-rstudio-para-versionamento-de-código",
    "title": "3  Controle de versões",
    "section": "3.1 Criando um projeto no RStudio para versionamento de código",
    "text": "3.1 Criando um projeto no RStudio para versionamento de código\n      O controle de versões faz parte da logística em Pesquisa Reproduzível (Vuorre and Curley 2018). Basicamente, esse controle permite o versionamento do código produzido para um documento ou projeto no R ou RStudio. Nesse último a interface gráfica facilita o monitoramento de versões. A grande vantagem por detrás do controle de versões é a possibilidade de recuperar uma versão eficiente do documento, sem que se precise salvá-lo a todo momento com nomes diferentes como forma de proteção.\n      Segue um pequeno tutorial para a implementação do versionamento de códigos pelo Terminal para instalação de arquivos, e RStudio para uso do sistema.\n\nCrie o projeto em File -&gt; New Project;\nEscolha New Directory;\nEscolha Quarto project;\nDigite o nome do diretória a criar;\nSelecione a caixa Create a git repository;\nEscolha se deseja um editor de texto simples ao iniciar ou um editor visual (use visual markdown editor)."
  },
  {
    "objectID": "contrVer.html#configurando-github",
    "href": "contrVer.html#configurando-github",
    "title": "3  Controle de versões",
    "section": "3.2 Configurando GitHub",
    "text": "3.2 Configurando GitHub\n\n3.2.1 Instalando e configurando o Git no PC:\n      Num Terminal, digite:\n\nsudo apt-get update\nsudo apt-get install git\ngit version ; conferindo a instalação\ngit config –global user.name “login de usuário” ; ex:jaime\ngit config –global user.email “email do usuário” ; ex: jaime@gmail.com\ngit config user.name ; conferindo username\ngit config user.email ; conferindo email\n\n      Alternativamente, conferindo ambos:\n\ngit config –global –list"
  },
  {
    "objectID": "contrVer.html#criando-um-repositório-no-github",
    "href": "contrVer.html#criando-um-repositório-no-github",
    "title": "3  Controle de versões",
    "section": "3.3 Criando um repositório no Github",
    "text": "3.3 Criando um repositório no Github\n\nEntra no Github;\nVá em Your Repositories (menu que abre no canto superior direito);\nClicar em New\n\n\n\n\n\n\n\n3.3.1 Definindo um Token para acesso ao repositório\n\nNo Github, vá em:\n\n\nSettings\nDeveloper Settings\nPersonal access tokens\n\n\nEscolha uma das opções (ex: “Tokens classic”)\nGenerate new token\n\n\nEscreva uma nota sobre o token;\nColoque um período de expiração;\nSelecione repo para os repositórios\n\n\nClique em Generate token\nCopie essa senha para a próxima etapa, a de linkar o projeto local no RStudio para acesso remoto no Github.\n\n\n\n3.3.2 Linkando o repositório criado ao RStudio\n\nCria o projeto no RStudio, e com Version Control\nVá à pasta criada e digite os comandos que a página do Github oferece, na sequência:\n\n\necho “# nome.do.repositório” &gt;&gt; README.md\ngit init\ngit add README.md\ngit commit -m “first commit”\ngit branch -M main\ngit remote add origin https://github.com/nomeDaContaGit/NomeRepositorioGit.git ; esse é o link oferecido pelo próprio Git\ngit remote add origin\ndigite a senha (token) obtida anteriormente no site do Github\n\nObs: - Um commit nada mais é do que a imagem das alterações locais realizadas em um projeto, ou seja, um registro de suas alterações. A cada commit são geradas remotamente no Github uma versão diferente do projeto, e que pode ser recuperada em caso de falhas, por exemplo. - Pode-se colar num Terminal as linhas globalmente, executando-as uma única vez:\necho \"# nomeDoRepositorio\" &gt;&gt; README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/nomeDoUsuario/nomeDoRepositorio.git\ngit push -u origin main"
  },
  {
    "objectID": "contrVer.html#sincronizando-o-projeto-do-rstudio-com-o-repositório-no-github",
    "href": "contrVer.html#sincronizando-o-projeto-do-rstudio-com-o-repositório-no-github",
    "title": "3  Controle de versões",
    "section": "3.4 Sincronizando o projeto do RStudio com o repositório no Github",
    "text": "3.4 Sincronizando o projeto do RStudio com o repositório no Github\n\nReinicie o RStudio para aparecer a aba Git (se já não apareceu antes);\nFaça alguma modificação no arquivo do projeto (md, rmd, qmd).\nSalve o arquivo e/ou renderize (deverá aparecer arquivo na aba Git que foi editado localmente);\nSelecione os arquivos da aba Git para sincronização remota (um bom e velho clique + Ctrl-A seleciona todos);\nClique em Commit, e digite qualquer observação no campo;\nClique em Commit da nova janela;\nClique em Push, para envio à nuvem;\nDigite o username para acesso ao Github;\nDigite o token obtido na seção anterior (senha)\nFeche as janelas."
  },
  {
    "objectID": "contrVer.html#clonando-um-repositório-do-git-como-projeto-no-rstudio",
    "href": "contrVer.html#clonando-um-repositório-do-git-como-projeto-no-rstudio",
    "title": "3  Controle de versões",
    "section": "3.5 Clonando um repositório do Git como projeto no RStudio",
    "text": "3.5 Clonando um repositório do Git como projeto no RStudio\n\nCrie o repositório no Git;\nCrie o projeto em File -&gt; New Project;\nEscolha Version Control;\nSelecione Git;\nCole o caminho do link para o repositório (Repository URL);\nCrie um diretório para o projeto (Create Project);\nClique em Create Project."
  },
  {
    "objectID": "contrVer.html#deletando-um-repositório",
    "href": "contrVer.html#deletando-um-repositório",
    "title": "3  Controle de versões",
    "section": "3.6 Deletando um repositório",
    "text": "3.6 Deletando um repositório\n\nEntra no repositório no Git;\nVá em Settings do repositório (menu superior), e não geral, que fica no canto superior direito;\nLá embaixo tem a opção de delete.\n\n\n\n\n\nVuorre, Matti, and James P Curley. 2018. “Curating Research Assets: A Tutorial on the Git Version Control System.” Advances in Methods and Practices in Psychological Science 1 (2): 219–36."
  },
  {
    "objectID": "chunks.html#chunk---trecho-de-código",
    "href": "chunks.html#chunk---trecho-de-código",
    "title": "4  Códigos",
    "section": "4.1 Chunk - trecho de código",
    "text": "4.1 Chunk - trecho de código\n      A alma da programação letrada (literate programming; Knuth (1984)) é unir num mesmo documento texto estilizado e linguagem de programação. À esta última cabe a inserção de chunks ou trechos de códigos que são compilados pelo R.\n      Para inserir um chunk duas opções simples:\n\nPor atalho: Ctrl + Alt + I ;\nPor digitação: insere-se uma tripla crase, * ```*, tanto pra abrir o trecho, como para fechá-lo, seguido de chaves, como segue.\n\n```{ } # inserção de *chunk*\nlinhas de comando"
  },
  {
    "objectID": "chunks.html#opções-de-chunk",
    "href": "chunks.html#opções-de-chunk",
    "title": "4  Códigos",
    "section": "4.2 Opções de chunk",
    "text": "4.2 Opções de chunk\n      As opções de trechos de códigos (chunks) permitem que se visualize ou não as linhas, ou que se execute ou não os códigos (TRUE ou FALSE), e diversas outras, como segue.\n\n```{r, eval = FALSE} # previne-se avaliar a linha \n```{r, echo = FALSE} # previne-se apresentar a linha\n```{r, output = FALSE} # evita a apresentação de resultados\n```{r, include = FALSE} # previne códigos e resultados\n```{r, error=TRUE} # previne-se interrupção da compilação por erro\n```{r, cache=TRUE} # cria-se memória *cache* de reuso de códigos já rodados para se acelerar a compilação\n```{r, warning = FALSE} # evita mensagens de aviso\n```{r, tidy = TRUE} # formatação de códigos para visualização com função ´tidy_source()´ do pacote ´formatR´.\n```{r, attr.source='.numberLines'} - inserir número de linhas\n```{r, dev=c('png', 'pdf', 'svg', 'tiff')} - armazenar múltiplos tipos de arquivos de imagens\n```{r, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE} # todos os *chunks* ao final do documento (útil, se possuirem títulos)\n\n      É interessante nomear um chunk pra identificação posterior, como na detecção de um erro por debug. Nesse caso, a opção simples é:\n\n\n4.2.1 Outras opções de chunks & linguagens\n      Quando se desejar apresentar o cabeçalho do trecho de código, utilize:\n```{r nome.do.chunk } # \n      Exemplificando,\n```{r, eval=TRUE}\n1 + 1\n      Para opções globais em chunks, sem a necessidade de repeti-las a cada trecho:\n\nknitr::opts_chunk$set(echo=TRUE)\n\n      Uma alternativa é inserir a opção de chunk no arquivo quarto.yml de metadados, como segue:\n\n---\ntitle: \"meu título\"\nauthor: \"euzinho\"\nformat: html\nexecute:\n  echo: false\n  message: false\n  warning: false\n  results: false\n---\n\n      Um exemplo prático de uma opção global é o ajuste de largura de chunks pra não exceder a mesma na compilação para PDF. Nesse caso:\n\nrequire(formatR)\n```{r, tidy=TRUE, tidy.opts=list(width.cutoff=50)\n\n      Para comando em LaTex, o chunk deve especificar o ambiente:\n```{=tex}\n\\begin{equation}\nKd=\\frac{[P]*[L]}{[P]+[L]}\n\\end{equation}"
  },
  {
    "objectID": "chunks.html#opções-de-chunk-para-imagens",
    "href": "chunks.html#opções-de-chunk-para-imagens",
    "title": "4  Códigos",
    "section": "4.3 Opções de chunk para imagens",
    "text": "4.3 Opções de chunk para imagens\n\n```{r, fig.cap = \"...\"} # adiciona uma descrição de imagem\n```{r, fig.width = \"...\"} # largura \n```{r, fig.height = \"...\" # altura\n```{r, fig.dim = \"...\""
  },
  {
    "objectID": "chunks.html#inserindo-um-script-do-r-num-chunk",
    "href": "chunks.html#inserindo-um-script-do-r-num-chunk",
    "title": "4  Códigos",
    "section": "4.4 Inserindo um script do R num chunk",
    "text": "4.4 Inserindo um script do R num chunk\n      É possível também alocar as linhas de comando para um cálculo, gráfico, ou análise, em um chunk. Entre as vantagens de se inserir um trecho de código externo num chunk pode-se incluir um fluxo mais ameno na leitura (afinal, puxar um comando pra script externo é mais simples do que copiar/colar um trecho de 50 linhas; readability). Exemplificando:\n\n# Rodando o script de regressão linear do diretório Analise:\nsource(\"Analise/regressao_lin.R\", local = knitr::knit_global())\nplot # roda o plot criado com a regressão"
  },
  {
    "objectID": "chunks.html#inserção-inline-de-equações-e-resultados",
    "href": "chunks.html#inserção-inline-de-equações-e-resultados",
    "title": "4  Códigos",
    "section": "4.5 Inserção inline de equações e resultados",
    "text": "4.5 Inserção inline de equações e resultados\n      Os resultados obtidos a partir de uma análise de dados pode ser alocado após a compilação de um chunk. Por vezes, porém, é interessante alocar esse resultado na própria linha de texto, espelhando o que ocorre manualmente com editores de texto comuns.\n      Essa situação, em que se aloca um conteúdo de um chunk não no próprio, mas numa sequência textual, é denominada por inserção em linha de informações. As principais inserções em linha constituem equações rápidas ou resultados de análises computacionais.\n      A inserção em linha é efetuada alocando-se o conteúdo dentro da sintaxe ” r “, como segue.\n\n4.5.1 Inserção inline de equações.\n      Ilustrando-se esse tipo de inserção:\n\n A equação deverá resultar numa relação tal que `r x^2+5*y` seja igual ao intercepto. \n\n      A expressão acima tem por resultado:\n      “A equação deverá resultar numa relação tal que 29 seja igual ao intercepto.”\n\n\n4.5.2 Inserção de resultados de análise\n      Da mesma forma acima, é possivel inserir em linha um resultado obtido diretamente de uma análise de dados, como ilustrado abaixo.\n\n O ajuste linear apresentou um valor para a inclinação do gráfico de `r coef(modelo)[1]` \n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "cabecalho.html",
    "href": "cabecalho.html",
    "title": "5  Cabeçalho",
    "section": "",
    "text": "O cabeçalho de um documento em Rmarkdown ou Quarto, ou de um projeto (nesse caso, pelo arquivo de configuração *_quarto.yml*) direciona como o documento será formatado. Um cabeçalho mínimo pode ilustrar-se por:\n\n---\ntitle: \"Documento\"\n---\n\n      O que basta para começar digitar o documento. De fato, nem mesmo esse dado é necessário, embora seja informativo à identificação do material em compilação. Mas existem diversar outras formatações que se extendem ao documento como um todo, e mesmo para um projeto (livro, website), e das quais mencionam-se algumas abaixo.\n      É importante se observar a identação correta do cabeçalho (ou do arquivo de metadados *_quarto_yml*), pois uma identação errada não permitirá compilar o documento.\n\ndate: \"`r Sys.Date()`\" # data automática\n\n      Para a criação de um documento com numeração de seções com três subníveis, por exemplo, basta:\n\n---\ntitle: \"Documento\"\nnumber-sections: true\nnumber-depth: 3\n---\n\n      A saída do documento (output) pode ocorrer como HTML (Hypertext Markup Language), PDF (Portable Document Format) ou DOCX (Microsoft-Word). Para isso, basta escolher:\n\n---\ntitle: \"Documento\"\nformat: html # ou pdf ou docx\n\n      Um exemplo mais completo (embora longe de abranger as todas as possibilidades) é dado abaixo para a elaboração de um livro.\n\n# Principal\nproject:\n  type: book\n  output-dir: _book\neditor: visual\ntitle: \"Meu livro\"\nreader-mode: true\nauthor: \"euzinho\"\ndate: today\ndate-format: \"D, MMM, YYYY\"\nlang:pt\n\n# Bibliografia e formatação\nbibliography: references.bib\ncsl: american-medical-association.csl\nclassoption:\n  - twocolumn\n  - landscape\npapersize: a5\nlinestretch: 1.5   ; espacejamento\nfontsize: 12pt\nlinks-as-notes: true\n\n# Output\nformat:\n  html:\n    theme: cosmo\n  pdf:\n    documentclass: scrreprt\n    includes:\n      in_header: \"preamble.tex\"\n    fontfamily: accanthis\n    latex_engine: pdflatex\n\n  docx: default\n  html:\n    css: styles.css\n  pdf:\n    documentclass: report\n    margin-left: 30mm\n    margin-right: 30mm\n\n# Rodapé, repositório Git, e direitos autorais\npage-footer:\n    left: |\n      Meu Livro foi escrito por Mim\n    right: |\n      Este livro foi construído com auxílio de &lt;a href=\"https://quarto.org/\"&gt;Quarto&lt;/a&gt;.\n  cover-image: cover.jpg\n  favicon: cover.jpg\n  site-url: https://meusite.br\n  repo-url: https://github.com/euzinho/meuLivro/\n  repo-branch: main\n  repo-actions: [edit, issue]\n\n  # Conteúdo (partes e capítulos)\n  chapters:\n    - index.qmd\n    - a.qmd\n    - part: b.qmd\n    chapters:\n        - c.qmd\n        - d.qmd\n        - e.qmd\n    - part: f.qmd\n    chapters:\n        - g.qmd\n        - h.qmd\n        - i.qmd"
  },
  {
    "objectID": "links.html",
    "href": "links.html",
    "title": "6  Links",
    "section": "",
    "text": "Hyperlinks para acesso à World Wide Web são efetuados e modo simples em Rmarkdown. Seguem alguns.\n\n- Simples: https://www.r-project.org/\n- Clicável: [R CRAN](https://www.r-project.org/)\n- Abertura em nova página: [R CRAN](https://www.r-project.org/){target=\"_blank\"}"
  },
  {
    "objectID": "figuras.html#parâmetros-de-chunk",
    "href": "figuras.html#parâmetros-de-chunk",
    "title": "7  Figuras",
    "section": "7.1 Parâmetros de chunk",
    "text": "7.1 Parâmetros de chunk\n      No quarto pode-se definir algumas características para figura a inserir no documento, como a legenda (caption) e o tamanho, tal como ilustrado no trecho de código abaixo.\n\ndpi = 300 # resolução da figura (\"dots per inch\")\nfig.cap = \"meu gráfico\" # legenda do gráfico\nfig.align = 'default' # alinhamento do gráfico (opções: 'left', 'right', or 'center')\nfig.height = 5 # altura\nfig.width = 7 # largura\nfig.path = \"C:/figuras\" # caminho do diretório\nfig.subcap = \"meu inserto\" # legenda em subfigura"
  },
  {
    "objectID": "graficos.html#os-sistemas-gráficos-do-r",
    "href": "graficos.html#os-sistemas-gráficos-do-r",
    "title": "8  Gráficos",
    "section": "8.1 Os sistemas gráficos do R",
    "text": "8.1 Os sistemas gráficos do R\n      Longe de exaurir os sistemas para plotagem de dados pelo R, existem três sistemas básicos que operam de modo independente a partir de pacotes do programa:\n\nGraphics. Inserido no pacote básico de instalação padrão do R, base, o sistema Graphics é que mais se comunica com os diversos pacotes para análises estatísticas e matemáticas do programa, embora seja mais analítico do que estético.\n\n      Em sua essência, o Graphics gera o resultado gráfico em cada linha de comando; dessa forma, para o output de dados multivariados são necessárias linhas de comando semelhantes para cada conjunto, embora haja a possibilidade de trabalhar-se com gráficos a partir de matrizes como dataframes (função matplot).\n\nLattice. Significando algo como entrelaçado (em tradução livre), o sistema pertence ao pacote homônimo lattice, e foi concebido para a produção de gráficos estatísticos de dados multivariados (trellis). Constitui um sistema com output mais estético que o padrão do R, goza da comunicabilidade entre pacotes desse, é bastante simples para gráficos de mesma natureza, embora seja complexo para representações contendo análises matemáticas. Diferente do anterior, a compilação é feita por algoritmo em uma única linha de comando para dados multivariados. Em sua essência, o lattice permite a construção de um gráfico para dados multivariados em apenas uma linha de comando.\nggplot2. O mais conhecido para produção estética de gráficos para publicação do R e data science, permitindo-se trabalhar-se tanto com dados univariados ou multivariados, como simultaneamente, para a produção de gráficos elegantes, bem como para análise de dados. Via de regra, contudo, não fornece os resultados quantitativos das análises, apenas sua visualização gráfica. | Em sua essência, o ggplot2 trabalha com camadas que se somam (“+”) para a renderização final do gráfico, de modo similar a programas de edição de imagens (ex: Inkscape, Photoshop).\n\n\n8.1.1 Um pouco mais sobres os sistemas gráficos\n      O graphics é o sistema que vem na instalação padrão do R (base), não sendo necessário qualquer pacote de instalação adicional (como o ggplot2). Embora o graphics seja mais limitado e/ou trabalhoso para análise com dados multivariados comum em Ciência de dados, é o sistema mais confortável na comunicação com outros pacotes de análises de dados do ecossistema R. Isso permite a produção de gráficos concomitante a resultados de análises, como ANAVA, ajustes lineares e curvilineares, bem como de análise numérica e programação, por exemplo. Trabalha com a produção gráfica de dados, uni ou multivariados, somente no formato Wide.\n      Por outro lado, como o graphics foi concebido primariamente no R, outros pacotes gráficos surgidos depois complementam sua limitação, quer para divulgação e publicação científica (ggplot2), ou para análise multivariada e Ciências de dados (lattice, ggplot2).\n      Não obstante, o ggplot2 exige uma gramática de gráficos específica em sua sintaxe, costuma “conversar” com um número limitado de outros pacotes (como o conjunto tidyverse), e não é o mais indicado para análises estatísticas e matemáticas concomitantes à produção gráfica. Esse último demérito vem do fato de que o ggplot2, embora possa se comunicar com alguns pacotes estatísticos e de análises, foi concebido originalmente para a visualização de dados, e não para análise propriamente dita. Como ponto positivo adicional, é o sistema empregado por pacotes de animação na web, tais como shiny. Adicionalmente, permite a produção de gráficos a partir de estatísticas oriundas dos próprios dados, sem análise prévia requerida. Como ponto singular, exige que para gráficos multivariados os dados estejam com os subgrupos em formato Long.\n      Do outro lado, o lattice foi concebido para a produção de gráficos e análise concomitantes, o que permite maior abrangência de comunicabilidade com outros pacotes do R. Não obstante, essa comunicação requer um maior aprofundamento do algoritmo envolvido nas linhas de programação, o que torna o lattice não tão intuitivo como o graphics. Adicionalmente, permite trabalhar-se com formato de dados Wide ou Long, e possui pacote que permite simular a estética de gráficos do ggplot2.\nEm síntese:\n\ngraphics não requer instalação, permite gráficos mais simples (embora suficientes para análises convencionais), é menos estético, é mais intuitivo, mas também mais trabalhoso para compor gráficos complexos e dados multivariados, e tem a vantagem de comunicar-se no ecossistema de pacotes de análises do R. Na percepção deste autor, possui um fluxo mais confortável para análise de dados concomitante à gráficos explanatórios, como em representações de modelos matemáticos.\nlattice combina a produção gráfica com análises de dados convencionais do R, embora seja de sintaxe mais elaborada para gráficos que exijam ajustes matemáticos mais complexos, e é mais voltado à conjuntos de dados multivariados e produção de paineis.\nggplot2 é o sistema mais adotado em data science, possui uma estética inigualável aos demais sistemas gráficos do R, é bastante flexível, desde gráficos simples aos de alta complexidade, comunica-se perfeitamente com outros pacotes, embora somente os correlatos (como o ecossistema tidyverse), mas não permite a produção de gráficos concomitante à diversas análises do R. Essas análises, embora estejam implícitas nas imagens (como ajustes lineares, parabólicos ou não lineares), não são oferecidas à visualização ou programação subsequente (como parâmetros de ajustes de modelos), tal como no sistema base e no lattice.\n\n\n\n8.1.2 Conversão de formatos de apresentação de dados: Long & Wide\n      Como explicado acima, pacotes gráficos do R podem trabalhar nos dois formatos, Long (ggplot2) e Wide (graphics). O pacote lattice permite operar com os dois formatos\n      Para exemplificar esses formatos, ilustra-se um dataframe criado em Long, como segue.\n\ngrupo &lt;- c(rep(rep(1:4, 4),4))\nresposta &lt;- c(1,2,3,4,2,4,6,8,10,14,18,22,24,30,36,42)\nniveis &lt;- c(rep(\"A\",4),rep(\"B\", 4), rep(\"C\", 4), rep(\"D\", 4)) # criação de vetores para dataset com subgrupos\n\ndf.l &lt;-data.frame(grupo, resposta, niveis);df.l\n\n   grupo resposta niveis\n1      1        1      A\n2      2        2      A\n3      3        3      A\n4      4        4      A\n5      1        2      B\n6      2        4      B\n7      3        6      B\n8      4        8      B\n9      1       10      C\n10     2       14      C\n11     3       18      C\n12     4       22      C\n13     1       24      D\n14     2       30      D\n15     3       36      D\n16     4       42      D\n17     1        1      A\n18     2        2      A\n19     3        3      A\n20     4        4      A\n21     1        2      B\n22     2        4      B\n23     3        6      B\n24     4        8      B\n25     1       10      C\n26     2       14      C\n27     3       18      C\n28     4       22      C\n29     1       24      D\n30     2       30      D\n31     3       36      D\n32     4       42      D\n33     1        1      A\n34     2        2      A\n35     3        3      A\n36     4        4      A\n37     1        2      B\n38     2        4      B\n39     3        6      B\n40     4        8      B\n41     1       10      C\n42     2       14      C\n43     3       18      C\n44     4       22      C\n45     1       24      D\n46     2       30      D\n47     3       36      D\n48     4       42      D\n49     1        1      A\n50     2        2      A\n51     3        3      A\n52     4        4      A\n53     1        2      B\n54     2        4      B\n55     3        6      B\n56     4        8      B\n57     1       10      C\n58     2       14      C\n59     3       18      C\n60     4       22      C\n61     1       24      D\n62     2       30      D\n63     3       36      D\n64     4       42      D\n\n\n      Alguns pacotes de R permitem converter o formato Long para Wide e vice-versa, como o reshape2 ou tydir. Convertendo o dataframe acima para formato Wide pelo reshape2:\n\nlibrary(reshape2)\ndf.w &lt;- reshape(df.l,\n                idvar = \"grupo\",\n                timevar = \"niveis\",\n                direction = \"wide\"); df.w # conversão de formato Long para Wide\n\nWarning in reshapeWide(data, idvar = idvar, timevar = timevar, varying =\nvarying, : multiple rows match for niveis=A: first taken\n\n\nWarning in reshapeWide(data, idvar = idvar, timevar = timevar, varying =\nvarying, : multiple rows match for niveis=B: first taken\n\n\nWarning in reshapeWide(data, idvar = idvar, timevar = timevar, varying =\nvarying, : multiple rows match for niveis=C: first taken\n\n\nWarning in reshapeWide(data, idvar = idvar, timevar = timevar, varying =\nvarying, : multiple rows match for niveis=D: first taken\n\n\n  grupo resposta.A resposta.B resposta.C resposta.D\n1     1          1          2         10         24\n2     2          2          4         14         30\n3     3          3          6         18         36\n4     4          4          8         22         42\n\n\n      Para a conversão de volta a Long utilizando-se o mesmo pacote reshape2:\n\ndf.l2 &lt;- reshape(df.w,                      \n                 idvar     = \"ID\", \n                 direction = \"long\"); df.l2\n\n    grupo niveis resposta.A\n1.A     1      A          1\n2.A     2      A          2\n3.A     3      A          3\n4.A     4      A          4\n1.B     1      B          2\n2.B     2      B          4\n3.B     3      B          6\n4.B     4      B          8\n1.C     1      C         10\n2.C     2      C         14\n3.C     3      C         18\n4.C     4      C         22\n1.D     1      D         24\n2.D     2      D         30\n3.D     3      D         36\n4.D     4      D         42"
  },
  {
    "objectID": "graficos.html#o-sistema-base-graphics",
    "href": "graficos.html#o-sistema-base-graphics",
    "title": "8  Gráficos",
    "section": "8.2 O sistema base (graphics)",
    "text": "8.2 O sistema base (graphics)\n      A seguir descreve-se a utilização do pacote base para gráficos do R, e com maior riqueza de detalhes que os demais (ggplot2 e lattice). Essa escolha autoral reside em alguns aspectos, tais como:\n\nNaturalidade de sua instalação original do R. Não há necessidade de instalação de qualquer pacote adicional;\nGarantia de operação do sistema. Por ser o primário do R, já não sofre mais com alterações e atualizações que, às vezes, geram erros na compilação (mensagem: “deprecated”);\nAlta flexibilidade para relações mais simples entre variáveis (mais comum em dados de “bancada de experimentos” do que em dados multivariados -lattice ou data science e publicação científica -ggplot2);\nCaráter mais intuitivo, além de uma comunicação mais abrangente com os demais pacotes de análises e manipulação de dados do ecossistema do R (cálculos, análise numérica, simulação, programação, ajuste de modelos);\nPossibilidade de plotagem de equações de modo mais simples que ggplot2;\n. De fato, talvez essa última característica seja mais relevante quando se deseja a obtenção de resultados analíticos em paralelo às representações gráficas.\n\n      O graphics trabalha com o comando plot em seus múltiplos argumentos:\n\nplot(x, y = NULL, type = \"p\",  xlim = NULL, ylim = NULL,\n     log = \"\", main = NULL, sub = NULL, xlab = NULL, ylab = NULL,\n     ann = par(\"ann\"), axes = TRUE, frame.plot = axes,\n     panel.first = NULL, panel.last = NULL, asp = NA,\n     xgap.axis = NA, ygap.axis = NA,\n     ...)\n\n      O comando permite duas formas de digitação, cartesiana, plot(x,y), ou por formula, plot(y~x). Além disso, e diferentemente do ggplot2 e do lattice, o sistema base elabora o gráfico principal numa linha de comando, e incorpora elementos estéticos ou de modelagem em linhas subsequentes.\n      O comando plotpode ser utilizado por diversas formas, o que o distingue dos demais packages citados, que trabalham somente com a identificação de colunas (vetores) por datasets. Assim, pelo graphics é possível plotar com:\n\nVetores criados “na unha”, de vetores de dados isolados;\nVetores de um dataset com identificação por símbolo $;\nVetores de um dataset identificado na função plot;\nVetores de dataset carregados por comando attach;\nVetores isolados e carregados no ambiente do R.\n\n      Exemplificando:\n\n# 1. A partir de vetores criados dentro da função\nplot(x=c(1,2,3,4),y=c(2,5,7,11))  \n\n\n\n# 2. Vetores identificados no *dataset* com o símbolo $\ndf &lt;- data.frame(\n  A = c(1,2,3,4),\n  B = c(3,7,2,9),\n  C = c(4,6,8,10))\nplot(df$A,df$C)  \n\n\n\n# 3. Vetores de dataset identificados na função\n\nplot(B~C, data=df) # Obs: nesse último, é necessário o símbolo \"tilde\" ~; caso contrário (se por \",\" por ex), o R informa um erro.\n\n\n\n# 4. Vetores de dataset carregado com `attach`\ndf1 &lt;- data.frame(\n  G = c(1,2,3,4),\n  H = c(3,7,2,9))\nattach(df1)\nplot(G,H) \n\n\n\n# 5. Vetores pré-definidos no ambiente\nk &lt;- seq(10:90)\nm &lt;- sin(k)\nplot(m~k, type=\"l\") \n\n\n\n\n      Alguns gráficos básicos permitidos pelo graphics envolvem:\n\nplot() - pontos, linhas, pontos e linhas\nbarplot() - plot de barras\nhist() - histograma\nboxplot() - gráfico Box-Whiskers\npersp() - gráfico 3D\npie() - gráfico de torta\ndotplot() - sequência de valores (com *jitter*, espalhameto de pontos\npairs() - painel múltiplo com todas as variáveis plotadas\nmatplot() - plota vetores de matrizes, como *dataframes*\n\n      Exemplificando para um gráfico de barras:\n\nm &lt;- matrix(c(70,60,40,60,40,20),nrow=2, byrow=TRUE,\n            dimnames=list(c(\"teste1\", \"teste2\"), c(\"controle\", \"método1\", \"método2\"))) # criação dos dados\n\nbarplot(m, beside=TRUE, legend.text = TRUE, ylim=c(0,100),xlab=\"Métodos\", ylab=\"Resultados\")\n\n\n\n\n      Exemplificando para um gráfico tridimensional:\n\nx = seq(-10,10, length = 50)\ny = x\nf = function(x,y) {r = sqrt(x^2+y^2); 10*sin(r)/r}\nz = outer(x,y,f)\npersp(x,y,z,theta=30,phi=30)\n\n\n\n\n      Além disso, diversas personalizações são possíveis pelo sistema graphics, quer para todos os pontos, como para um vetor de qualidades relativas aos pontos, dentre as quais:\n\ntype - tipo de plot: pontos \"p\", linhas \"l\", pontos+linhas com cruzamento \"o\", pontos+linhas sem cruzamento \"b\", linhas verticais \"h\", steps \"s\", sem representação \"n\";\n\ncex - tamanho do ponto (ex: 0.5, 20);\n\nlty - \"line type\", tipo da linha; pode se representado por um valor (1,2,...) ou por \"solid\", \"dotted\", \"dashed\", \"dotdash\", \"longdash\", \"twodash\";\n\nlwd - \"line width\", largura da linha (6 níveis)\n\npch - tipo de ponto (1-25)\n\nxlim, ylim - limite dos eixos; ex: ylim=c(-2,10)\n\nxlab, ylab - etiquetas (\"label\") dos gráficos\n\ncol - cor (números ou nomes); ex: \"red\", \"orange\"\n\nmain - título do gráfico\n\nsub - subtítulo do gráfico\n\nlog - eixo logaritmo\n\njitter - espalhamento de pontos (evita sobreposição)\n\n      E diversas personalizações ou inserções são permitidas após a execução do gráfico, tais como:\n\nrug - marcação de pontos no eixo (reforça identidade)\n\ntext - inserção de texto \n\nmtext - inserção de texto nas margens do plot\n\naxis -  adiciona um eixo\n\nabline - acrescenta uma linha reta (h, v, de valores, ou de ajuste)\n\ngrid - rede de marcação dos \"ticks\"\n\nbg - plano fundo (\"background\")\n\n      Exemplificando alguns dos argumentos acima para um gráfico genérico:\n\nA = seq(1:100)\nB = A^2  # criação de vetor resposta pro gráfico\n\nplot(x=A, y=B,\n     cex=2,pch=3,type=\"o\",lty=\"dotted\",col=3,lwd=2,\n     xlim=c(10,80),ylim=c(1e2,1e4),\n     xlab=\"eixo x\", ylab=\"eixo y\",\n     main=\"Meu título\",sub=\"Meu subtítulo\",log='xy')\n\n\n\ndf &lt;-data.frame(A,B)\nmatplot(df, pch=1, type = \"b\") # exemplo de `matplot`\nabline(h=4000, lty=2, col=5) # adiciona uma linha azul pontilhada\n\n\n\n\n      Também é possível atribuir alguns parâmetros (cex, pch, por exemplo) em função dos níveis de uma variável:\n\n  x = c(1,2,3,4,5,6,7,8,9)\n  y = c(6,7,8,9,10,11,12,13,14)\n  z = rep(LETTERS[1:3],3)\n\nplot(x,y, cex=1:length(unique(z)))\n\n\n\n\n      E também é possível definir alguns argumentos em função de outros, como o tamanho (‘cex’) e um texto:\n\nplot(x,y)\ntext(x=2, y=10, \"abc\", cex=2, col=7)\n\n\n\n\n\n8.2.1 Armazenamento\n      No pacote base um gráfico pode ser armazenado abrindo-se inicialmente uma conexão, elaborando-se o gráfico, e fechando-se a conexão, como ilustrado a seguir:\n\npdf(\"grafico.pdf\", width=7, height=4) # abre a conexão\nplot(x,y) # elabora o gráfico\ndev.off() # fecha a conexão\n\n# Obs: outros formatos possíveis: jpeg, bmp, tiff, ps, png\n\n\n\n8.2.2 Linhas adicionais & graphics\n      O pacote base opera produzindo o gráfico pela linha de comando contida em plot(). Não obstante, é possível adicionar outras linhas para o complemento analítico, estético, e mesmo estatístico do gráfico, como legenda, barra de erros, pontos ou linhas adicionais, resumo estatístico, adição de seta, texto, linhas (de ajuste ou suavidade - spline, lowess), dentre outras. Ilustrando todos esses ítens num único gráfico:\n\nA = seq(from=2, to=10)\nB = A/2 + runif(n=9,min=0.2,max=2) # vetor resposta com com erro aleatório\nC = B+1 # vetor resposta adicional pro gráfico\n\najus &lt;- lm(B~A) # ajuste linear dos dados\nplot(A,B,\n     type=\"o\", col=\"brown\") # plot de pontos e linhas\narrows(x0=A,y0=B-0.1*B,\n       x1=A,y1=B+0.1*B,\n       angle=90,code=3,length=0.1,lwd=0.7,col=\"blue\")  # adição de barra de erros (nota: quando o tipo for de barras - barplot, ambos \"x0\" e \"x1\" são o dataframe)\narrows(x0=2,y0=4,x1=5,y1=5,length=0.1,angle=45, col=\"green\") # adição de seta\ntext(x=3,y=4,\"tendência\",cex=0.9, col=\"orange\") # adição de texto\nlines(spline(A,B),col=\"red\") # adição de linha de ajuste genérica\nabline(ajus, lty=2) # adção de reta de ajuste linear\npoints(A,C-1, type=\"b\", col=\"pink\") # pontos adicionais\n\ndf &lt;- cbind(A,B,C) # cria um dataframe\nmed &lt;- apply(df, 1, mean) # calcula a média das linhas do dataframe\npoints(A,med,pch=17) # adiciona pontos de média\nlines(lowess(A,med, f=0.9), pch=17, col = 5) # adiciona linha de suavidade na média plotada\nlegend(x=8,y=3.5, c(\"spline\",\"regressão\",\"lowess\"), pch=c(16,16,16), lty = c(1,2,1), col=c(\"red\",\"black\",5)) # adição de legenda\n\n\n\n\n      Também é possível a adição de barras de erro em diversos tipos de gráficos (pontos, barras), e por diversos pacotes. Exemplificando:\n\nset.seed(2)\nx &lt;- 1:10\ny &lt;- x+rnorm(10)\nplot(x,y)\n\n# pacote base:\n\narrows(x0=x,y0=y,x1=x,y1=y+0.05*y, length = 0.1, angle =90)\narrows(x0=x,y0=y,x1=x,y1=y-0.05*y, length = 0.1, angle =90)\n\n\n\n# pacote Hmisc\nlibrary(Hmisc)\nplot(x,y)\n\n\n\nerrbar( x, y, y +0.05*y, y -0.05*y )\n\n\n\n# pacote plotrix\nlibrary(plotrix)\nplot(x,y)\n\n\n\nerro.y &lt;- runif(10)\nplotCI(x,y,erro.y)\n\n\n\n\n      Alguns elementos adicionais podem ser inseridos no gráfico não apenas por coordenadas, como acima, mas pelo uso da função locator. Essa função aguarda um clique de mouse em coordenada escolhida pelo usuário, extraindo seus valores. Aplicada a uma ação para inserção de informação ao gráfico, executa essa inserção por clique de mouse, como no exemplo abaixo para adição de legenda.\n\nA = seq(from=2, to=10)\nB = A/2 + runif(n=9,min=0.2,max=2) # vetor resposta com com erro aleatório\nlegend(locator(1),\"legenda\") # quando executada, o `R` aguarda um clique de mouse para inserção (por isso o índice 1)\n\n\n\n8.2.3 pairs - plot de todas as variáveis\n      Quando se deseja observar panoramicamente a relação entre todas as variáveis de um gráfico, é útil o uso da função pairs, como ilustrado abaixo.\n\ndf1 &lt;- data.frame(list(\n  a = 1:10,\n  b = sqrt(1:10),\n  c = log(1:10),\n  d = sin(1:10))) # criação de dataset multivariado\n\npairs(df1)\n\n\n\n\n\n\n8.2.4 Paineis\n      O sistema base permite a construção de gráficos na forma de paineis por digitação sucessiva dos plots pretendidos. A função utilizada é par(mfrow) ou par(mfcol), abreviações de linha ou coluna para multiple frame. Utilizando do dataframe acima:\n\na = 1:10\nb = sqrt(1:10)\nc = log(1:10)\nd = sin(1:10) # vetores\n\nplot.new()\npar(mfrow = c(2, 2))\nplot(a,b)\nplot(a,c)\nplot(a,d)\nplot(b,c)\n\n\n\n\n\n\n8.2.5 A função matplot\n      Embora o sistema base não seja o mais indicado para a produção de gráficos de dados multivariados, tais como ggplot2 e lattice, é possível sua construção com a função matplot. O comando produz um gráfico a partir de uma matriz, conceito que também cabe a um dataframe, ou de vetores obtidos por cálculo.\n      No uso de matplot a condição básica é que o tipo de gráfico seja de ponto ou de linha, não sendo permitidos demais tipos (barra, boxplot, etc).\n      Há duas formas para isso: uma similar à plot, adiciona-se plots sucessivos pelas funções matpoints e matlines. E outra a partir de matriz (dataframe) ou de vetores isolados. Ilustrando:\n\ndf.m &lt;- matrix(1:24, ncol=6)\ncolnames(df.m) &lt;- list(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\") # criação de dataframe com 6 colunas (vetores), simulando um dataframe\n\nmatplot(df.m) # gráfico multivariado básico\n\n\n\n\n      Observe que matplot produz um gráfico multivariado com números representando os pontos. As variações abaixo incrementam a estética do gráfico, além de permitir sua produção por subconjuntos dos dados, bem como pelo uso de função matemática.\n\nmatplot(df.m, pch=15, type=\"o\", cex = 2) # símbolos,\n\n\n\n#matplot(df.m, pch=df.m, type=df.m, cex = df.m) # estética em função dos vetores\nmatplot(df.m[2:4,c(3,6)],\ntype = c(\"p\",\"p\",\"p\"),\npch = 16,\ncex = 2)  # plot somente com vetores C e E, e linhas de 2 a 4\n\n\n\nx &lt;- c(2,5,7,10,13,20)/10 # criação de variável independente\n\nmatplot(x, outer(x, 1:4, function(x, k) x^k),\n        pch = letters[1:4], type = c(\"b\",\"p\",\"o\")) # com função matemática (observe o uso de `outer`)\n\n\n\n\n      Embora não seja normalmente considerado nas referências do R, a criação de gráficos com vetores ou dataframes de dados multivariados também pode ser realizad usando-se a função matplot, como abaixo:\n\n## Plot multivariado com vetores\n\nx &lt;- c(2,5,7,10,13,20)\ny &lt;- c(4, 7, 17, 25, 50, 55)\nz &lt;- y/2\nw &lt;- y^1.2\n\ndat&lt;-cbind(x,y,z,w)\nmatplot(x, dat, \n        pch = c(\"x\",\"y\",\"z\",\"w\"), type = c(\"n\",\"o\",\"o\",\"o\")) # Obs: veja que há um truque para a produção gráfica: o símbolo de \"x\" é omitido (type=\"n\")\n\n\n\n\n      Reforçando aqui o comentário do trecho de código acima, veja que há um truque para a produção gráfica: o símbolo de “x” é omitido (type=“n”). Dessa forma, ainda que a sequência de “x” seja plotada, ela não é apresentada.\n      A consequência direta é que torna-se possível pelo sistema graphics básico aquilo que normalmente é alocado para sistemas mais elaborados, como ggplot2e lattice, descritos a seguir.\n\n\n8.2.6 As funções plot, matplot, e curve\n      De certa forma, as funções acima presentes no graphics são intercambiáveis, como exemplificado a seguir, embora curve exija como variável independente x, mas com um produto final mais curvilinear:\n\nx &lt;- -4:5\ny &lt;- x^2\nplot(x,y, type=\"l\", xlim=c(-4,5))  # função quadrática por `plot`\n\n\n\ncurve(x^2, xlim=c(-4,5))  # função quadrática por `curve`\n\n\n\nmatplot((-4:5)^2, pch=15, type=\"l\")"
  },
  {
    "objectID": "graficos.html#graphics-e-formato-long-para-dados-multivariados",
    "href": "graficos.html#graphics-e-formato-long-para-dados-multivariados",
    "title": "8  Gráficos",
    "section": "8.3 ‘Graphics’ e formato Long para dados multivariados",
    "text": "8.3 ‘Graphics’ e formato Long para dados multivariados\n      Embora não seja usual na literatura que trata o sistema base de gráficos do R, é possível trabalhar-se com dados multivariados sem a necessidade de se acrescentar linhas para cada plot construido.\n      Para isso, é necessário a construção dos dados em formato Long, como no exemplo a seguir.\n\nx=1:12\ndf &lt;- data.frame(\n  x,\n  y=x^2+runif(n=12, 40,50), # uma função qualquer\n  grupo=rep(c(\"g1\", \"g2\", \"g3\", \"g4\"), each = 3)) # cria o *dataframe* com um fator com 4 níveis\n\n      Agora é necessário atribuir aos níveis de um fator uma característica numérica, posto que cor, tipo e largura de linha, tamanho de pontos, etc, são também alocados por valores. Nesse caso:\n\nniveis &lt;- as.numeric(factor(levels(as.factor(df$grupo)))) # atribui um vetor de cores aos níveis dos grupos\n\n      Agora pode-se plotar os dados multivariados com a função ‘plot()’.\n\nbarplot(y~x, data=df,\n     type=\"p\",col=niveis)\n\nWarning in plot.window(xlim, ylim, log = log, ...): graphical parameter \"type\"\nis obsolete\n\n\nWarning in axis(if (horiz) 2 else 1, at = at.l, labels = names.arg, lty =\naxis.lty, : graphical parameter \"type\" is obsolete\n\n\nWarning in title(main = main, sub = sub, xlab = xlab, ylab = ylab, ...):\ngraphical parameter \"type\" is obsolete\n\n\nWarning in axis(if (horiz) 1 else 2, cex.axis = cex.axis, ...): graphical\nparameter \"type\" is obsolete\n\n\n\n\nplot(y~x, data=df,\n     type=\"p\",col=niveis)\n\n\n\nplot(y~x, data=df,\n     type=\"p\",col=niveis, cex=niveis)\n\n\n\n\n      O sistema base do graphics permite um conjunto bem mais extenso de características e performances além das que foram tratados aqui, pelo que recomenda-se ao interessado as inúmeras fontes de tutoriais da internete, livros e ebooks correlatos."
  },
  {
    "objectID": "graficos.html#o-sistema-ggplot2",
    "href": "graficos.html#o-sistema-ggplot2",
    "title": "8  Gráficos",
    "section": "8.4 O sistema ggplot2",
    "text": "8.4 O sistema ggplot2\n      O R possui diversos pacotes pra criação de gráficos, dentre os quais destaca-se o ggplot2. Esse pacote permite a elaboração de um grande número de tipos (pontos, linhas, barras, histograma, etc) e com qualidade de publicação.\n      Basicamente o ambiente funciona tal e qual um editor de imagens, como o Corel Draw ou Inkscape, e que permitem a criação dessas por camadas. A única diferença é que em tais editores as camadas são depositadas ao bel prazer de seu criador. Já no ggplot2 as camadas tem propriedades fixas. Mas o bacana é que, tanto para a edição de imagens naqueles programas, como para a edição de gráficos no ggplot2, a alteração feita numa camada específica só altera essa, preservando as demais que “já deram certo”.\n\n8.4.1 A gramática de gráficos & ggplot2\n      A produção de um gráfico pelo pacote ggplot2 envolve em síntese a elaboração de camadas sobrepostas. Essa ideia deriva-se dos conceitos de gramática de gráficos concebida por Wilkinson (2012), e concretizada no ggplot2 por Wickham (2011).\n      Nesse sentido é, de certa forma, parecida com a de alguns programas de criação e edição de imagens, como Corel Draw (MS Office) ou Inkscape (Linux, macOS, Windows). Diferente desses, contudo, o ‘ggplot2’ monta camadas específicas e distintas uma das outras.\n      Podem ser montadas até 7 sobrepostas em distintos arranjos, embora apenas 3 sejam indispensáveis (dados, estética, e geoma):\n\n\n\n\n\n\n\n\n\ncamadas\nideia\n\n\n\n\nDados\nautoexplicativo\n\n\nEstética\nvariáveis visuais - mapeamento de eixos, cor, preenchimento\n\n\nGeomas\ntipos de gráficos: pontos, lin has, barras, boxes, etiquetas de eixos (geom)\n\n\nEstatística\ntransformação de dados para plotagem\n\n\nPaineis\nvisualização de subconjunto de dados em paineis (facet)\n\n\nCoordenadas\nfocalização do canvas (scales) e transformação de eixos (coord)\n\n\n\n\n\n      À despeito dessa “aparente complicação”, tudo se resume em apresentar os dados (data) e realizar seu mapeamento (mapping). O mapeamento obriga apenas a alocação das variáveis independente (x) e dependente (y) do gráfico. Mas para se visualizar os dados no gráfico, é necessário acrescentar ao menos um elemento geométrico (geom) - ponto ou linha, por exemplo.\n  De modo mais completo, o mapeamento é efetuado por 5 componentes da tabela acima: layer (elementos geométricos - geom, e transformações e resumos estatísticos - stat),scales,coord,facet,theme.\n     No ggplot2 camadas podem ser depositadas como numa sequência lógica pra criação de um gráfico:\n\nEstabelece-se os dados que serão utilizados.\nDefine-se quem é o x e quem é o y.\nCria-se um tipo de gráfico.\nEmbeleza-se o gráfico criado (eixos, cores, símbolos, tamanhos).\n\n      Havendo empolgação, pode-se continuar com o ggplot2 aprimorando o gráfico criado. Para isso:\n\nObserva-se alguma relação entre as variáveis.\nAvalia-se um modelo para essa relação (reta, curva).\nInsere-se no gráfico o modelo que se ajustou (equação e parâmetros).\n\n      Para uso de dados multivariados, a condição para uso do ggplot2 é que os mesmos estejam distribuidos em formato Long, ou seja, os níveis ou subconjuntos de uma variável precisam ser alocados num único vetor. Isso é simples quando se tem poucas linhas, mas complexo, quando tratar-se de vários níveis ou elementos em cada nível. No entanto, para se converter dados em Wide (várias colunas pra cada nível, x, y, z, etc) em Long (uma coluna única contendo os níveis x, y, z, etc), utiliza-se algumas funções, tais como do pacote reshape ou tydir (função gather pra converter a longer ou spread pra converter a wider).\n      Segue uma descrição sequencial para a elaboração de um gráfico de dados univariados pelo ggplot2, seguindo-se as camadas descritas acima. Posteriormente será apresentado a confecção gráfica para dados multivariados.\n\n\n8.4.2 Simulando um conjunto pequeno de dados\n      Pra essa primeira etapa vamos construir uma tabela com dados fictícios. Lembrando ainda que poderíamos obter os dados por cópia/colagem, ou por importação de outra planilha.\n\nmeus.dados &lt;- read.table(header = T, text = '\n      dist veloc\n      1 2\n      2 6\n      3 9\n      4 11\n      5 13\n      6 14\n')\n\n\n\n8.4.3 Carregando o ggplot2\n      Agora é fazer o gráfico carregando a biblioteca. Nota óbvia: é preciso instalar antes a biblioteca.\n\n# install.packages(\"ggplot\", dependencies = TRUE) \nlibrary(ggplot2)\n\n\nggplot(data=meus.dados)\n\n\n\n\n      Veja que surgiu um quadro (canvas), embora apenas o quadro, mesmo, sem nenhum x ou y. O que também é óbvio, pois não definimos essas variáveis ainda. Para isso:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc))\n\n\n\n\n      Agora o gráfico apresenta-se com os eixos, embora sem os dados da tabela. No conjunto de obviedades que se assoma, é claro, também não definimos que tipo de gráfico queremos. Ou seja, se ponto, linha, barra, ou algum pra lá de dúzia que compõe o pacote ggplot2.\n      Uma observação importantíssima: veja que as variáveis estão dentro de um parêntes iniciado pela função aes. Do inglês, uma abreviação de aesthetics, ou estética, em tradução livre. Todo gráfico do ggplot2 tem que conter essa função, que além de definir as variáveis envolvidas, também permite generalizar para as camadas outras características estéticas, como cor, tamanho, e forma.\n\n\n8.4.4 Escolhendo o tipo de gráfico\n      De volta ao ofício, o tipo de gráfico no pacote ggplot2 é definido pelo tipo de geom, ou geoma, em tradução livre e um pouco óbvia, também. O ggplot2 tem geoms pra tudo que é gráfico. E para inseri-lo na linha de comando de produção desse, basta acrescentar seu tipo como uma camada adicional, usando o sinal ” + “, mesmo, como segue.\n\nggplot(data=meus.dados, aes(x=dist, y=veloc)) +\n  geom_point()\n\n\n\n\n     “Parfait” ! Agora, sim, quadro, dados, eixos gráficos, e pontos. Uma qualidade muito legal do ggplot2 e, na verdade, de qualquer programa que use linhas de comando para gerar resultados, como o próprio R, é que pra gente produzir um gráfico diferente não precisa criá-lo do zero; basta alterar o ponto específico que se deseja na linha de comando. Na prática, se ao invés de produzirmos um gráfico de pontos quisermos outros tipos, é só mudar o geom:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc)) +\n  geom_line()\n\n\n\nggplot(data=meus.dados, aes(x=dist, y=veloc)) +\n  geom_col()\n\n\n\nggplot(data=meus.dados, aes(x=dist, y=veloc)) +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in max(ids, na.rm = TRUE): no non-missing arguments to max; returning\n-Inf\n\n\n\n\n\n      Como mencionado, o ggplot2 trabalha sobrepondo camadas. Que tal então um gráfico como o de cima, mas com a linha de tendência sobreposta aos pontos ?\n\nggplot(data=meus.dados, aes(x=dist, y=veloc)) +\n  geom_smooth()+\n  geom_point()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in max(ids, na.rm = TRUE): no non-missing arguments to max; returning\n-Inf\n\n\n\n\n\n\n\n8.4.5 Oferecendo elegância ao gráfico\n      Bom, seguindo-se os ítens de construção de um gráfico lá de cima, agora é hora de “botar” elegância no produto ! Pra isso pode-se escolher algumas “estéticas” de cor (color), tamanho (size), translucidez (alpha), forma (shape), preenchimento do símbolo (fill) e sua espessura do tracejado do símbolo (stroke), e inseri-las como argumentos do geoma.\n\nggplot(data=meus.dados, aes(x=dist, y=veloc)) +\n  geom_point(color= \"blue\", \n             size=5,  # tamanho do símbolo\n             alpha = 0.5, # transparência (0 a 1)\n             shape = 21, # tipo do símbolo\n             fill = \"green\", # preenchimento (só vale pra tipos vazios, obviamente)\n             stroke = 2) # espessura do tracejado do símbolo\n\n\n\n\n      Bonito, não ? Ou doido, mesmo !\n\n\n\n\n\n\n      Agora que melhoramos (…ou pioramos) o aspecto visual do gráfico, que tal dar um jeito nas etiquetas dos eixos (labels) ? Veja que estão com as abreviações das colunas x e y dos dados. Quem sabe algo com mais empáfia, então ?\n\nggplot(data=meus.dados, aes(x=dist, y=veloc)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\")\n\n\n\n\n\n\n8.4.6 Colocando títulos e subtítulos\n      Observe que tanto faz colocar as características dos pontos com identação, uma abaixo da outra, ou em linha, mesmo. A única diferença é que colocando uma abaixo da outra visualiza-se melhor o que se pretende fazer. Isso faz parte das “boas práticas de programação”.\n      Essa função labs permite também se colocar título, subtítulo, e uma observação (caption) no gráfico, veja:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\",\n       title = \"Alcance do foguetinho !\",\n       subtitle = \"Testes de campo\",\n       caption = \"Obs: construção caseira\")\n\n\n\n\n\n\n8.4.7 Mudando a aparência de fundo\n      O ggplot2 apresenta como padrão esse canvas acizentado. Mas existem vários outros, bastando-se definir um tema (theme) ao gráfico:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\",\n       title = \"Alcance do foguetinho !\",\n       subtitle = \"Testes de campo\",\n       caption = \"Obs: construção caseira\") +\n  theme_bw()\n\n\n\n\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\",\n       title = \"Alcance do foguetinho !\",\n       subtitle = \"Testes de campo\",\n       caption = \"Obs: construção caseira\") +\n  theme_classic()\n\n\n\n\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\",\n       title = \"Alcance do foguetinho !\",\n       subtitle = \"Testes de campo\",\n       caption = \"Obs: construção caseira\") +\n  theme_linedraw()\n\n\n\n\n\n\n8.4.8 Alterando o tamanho da fonte\n      Nessa versão dá pra notar que o tamanho dos valores nos eixos, bem como o tamanho de suas etiquetas, deixam um pouco a desejar à estética do gráfico. Aumentando esses valores um pouquinho dentro da função theme (o padrão ou default é fonte 11)…\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\",\n       title = \"Alcance do foguetinho !\",\n       subtitle = \"Testes de campo\",\n       caption = \"construção caseira\") +\n  theme_bw(base_size = 14)\n\n\n\n  # theme(axis.text = element_text(size = 14),\n  #       axis.text.x = element_text(size = 14))\n\n      Se desejar omitir alguma informação do gráfico, basta omiti-la da linha de comando. Por exemplo, se desejarmos retirar título, subtítulo e nota de observação:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\") +\n  theme_bw(base_size = 14)\n\n\n\n\n\n\n8.4.9 Mudando os limites dos eixos\n      Dá pra melhorar mais um pouco a visualização ?! Sempre dá, claro. Por exemplo, observe que nosso gráfico não inicia na origem, ou seja, quando x e y tem valor zero. Se quisermos alterar então esses eixos pra iniciarem no zero…bom…lá vai mais uma camada !!\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\") +\n  theme_bw(base_size = 14)+\n  coord_cartesian(xlim = c(0,6.5), ylim=c(0,15))\n\n\n\n\n      Apesar de mais “pomposo” tanto o nome como as possibilidades dessa camada coord_cartesian, também é possível obter o mesmo efeito apenas com os argumentos xlim e ylim, e de modo um pouquinho diferente. Pra não repetir o gráfico acima, segue um exemplo com limites distintos nos eixos:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\") +\n  theme_bw(base_size = 14) +\n  xlim(-1,8) +\n  ylim(-1,28)\n\n\n\n\n\n\n8.4.10 Modelando os dados\n\n8.4.10.1 Ajuste linear\n      Agora que nosso gráfico tá (…ou deveria estar) mais incrementado, que tal colocar uma linha de ajuste dos pontos ? Modelos pra isso não faltam, mas optemos inicialmente pelo mais simples: um ajuste ou regressão linear. Resumidamente, trata-se de observar se a resposta y segue uma tendência linear com os valores de x. E como o ggplot2 trabalha com camadas, adicionemos essa camada, então:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\") +\n  theme_bw(base_size = 14) +\n  geom_smooth(method = 'lm', linewidth = 0.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n      Agora ficou chique !! E também indecifrável…ou quase. Indo por partes: o método escolhido foi lm, ou modelo linear (linear model). O termo poderia ser também substituido por 'y ~x', uma notação do R que indica a dependência de y em relação a x. O argumento linewidth sinaliza pra espessura do tracejado. E a banda acizentada indica o intervalo de confiança do ajuste (erro padrão). Pra retirar essa última, bem como a legenda doida, basta fazer:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\") +\n  theme_bw(base_size = 14) +\n  geom_smooth(method = 'lm', linewidth = 0.5, se = FALSE, show.legend = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n      Existem diversos parâmetros que são obtidos pela função lm. Dada a natureza de programação orientada a objeto do R, esses parâmetros podem ser acessados individualmente em seus objetos. Exemplificando:\n\nattributes(lm)\n\nNULL\n\n\n\n\n8.4.10.2 Ajuste polinomial\n      Apesar de bem incrementado esse gráfico final, observe que a tendência dos pontos não é propriamente linear. Tá parecendo mais uma curva. E dentre as curvas possíveis, quem sabe uma parábola. Nesse caso é preferível ajustar o modelo a uma parábola, mais condizente mesmo com a trajetório de um foguete. Pra isso, basta que alteremos acrescentemos qual a formula a ser empregada:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\") +\n  theme_bw(base_size = 14) +\n  geom_smooth(method = 'lm', formula = y ~ poly(x, 2), linewidth = 0.5, color = \"orange\", se = FALSE, show.legend = FALSE)\n\n\n\n\n      Apesar de um pouco confuso, a expressão formula = y ~ poly(x, 2) indica tratar-se de um ajuste para um polinômio de 2a. ordem em x. E, claro, uma “corzinha” adicional no tracejado não faz mal a ninguém !\n\n\n\n8.4.11 Salvando o gráfico\n      Agora, pra se guardar esse gráfico, um tanto trabalhoso, convenhamos, o R permite o salvamento em diversos formatos, como JPG, BMP, TIFF, PDF, PNG, EPS, por exemplo. Dois jeitos de salvar o gráfico: um se dá pelo menu de Plots do canto inferior esquerdo do RStudio (Plots –&gt; Export). Se quisermos o armazenamento por linha de comando, por outro lado, basta utilizar a função ggsave logo após a criação do gráfico.\n\nggplot(data=meus.dados, aes(x=dist, y=veloc, col = \"red\", size = 5, alpha = 0.5)) +\n  geom_point(color= \"blue\", size=5, alpha = 0.5, shape = 21, fill = \"green\", stroke = 2) +\n  labs(x = \"distância percorrida (km)\",\n       y = \"velocidade do foguete (km/min)\") +\n  theme_bw(base_size = 14) +\n  geom_smooth(method = 'lm', formula = y ~ poly(x, 2), linewidth = 0.5, color = \"orange\", se = FALSE, show.legend = FALSE)\n\n\n\n# Salvando o gráfico...\n\nggsave(filename =  \"plot.meus.dados.png\", dpi = 300, width = 4, height = 5)\n\n       Se você não especificou onde salvar o gráfico, veja no diretório raiz do computador. Explicando brevemente a função, dpi representa a resolução do gráfico, enquanto que width e height especificam o tamanho.\n      Mas também dá pra salvar o gráfico sem qualquer especificação. Exemplificando pra um arquivo PDF:\n\nggsave(filename =  \"plot.meus.dados.pdf\")\n\nSaving 7 x 5 in image\n\n\n\n\n8.4.12 Simplificando a construção de um gráfico\n      Bom, ainda que o gráfico acima tenha um certo ar de sofisticação, não é sempre que se deseja isso. Na maior parte das vezes, o que se quer é plotar os dados e observar alguma tendência. E, pra isso, não é necessário todas essas camadas, funções e argumentos. Para se plotar algo “parecido” com o gráfico acima, mas sem toda essa pompa, basta fazermos:\n\nggplot(data=meus.dados, aes(x=dist, y=veloc)) +\n  geom_point() +\n  geom_line()\n\n\n\n\n\n\n8.4.13 Elaborando um gráfico apenas com vetores\n      O pacote ggplot2 é normalmente empregado para a criação de de gráficos a partir de um dataset. Não obstante, é possível produzir também um gráfico apenas com vetores, tal como segue:\n\nx &lt;- 1:360\ny = sin(x)\nlibrary(ggplot2)\nggplot( data = NULL ,\n        mapping = aes( x = x , y = y ) ) +\n  geom_line() +\n  geom_point(shape = 15, col = \"red\", size = 0.5)+\n  labs(x=\"eixo x\", y=\"eixo y\") +\n  coord_cartesian(xlim=c(45,90)) \n\n\n\n\n\n\n8.4.14 Simulação & função em ggplot2\n      Como o sistema base, o ggplot2 possui também uma função para a produção de tendências por equações introduzidas, geom_function. Exemplificando:\n\nrequire(ggplot2)\nggplot(data.frame(x = 1:100), aes(x)) +\n  geom_function(fun=function(x) 173*x/(6+x), colour = \"red\")\n\n\n\n\n\n\n8.4.15 ggplot2 para dados multivariados\n      Como explicado acima, o ggplot2 trabalha exclusivamente com dados em formato Long, ou seja, uma variável para cada quantidade. Dessa forma, os subconjuntos de uma variável (ou nível) devem situar-se nessa única variável. Ilustrando:\n\ntempo &lt;- c(rep(rep(1:4, 4),4))\nresposta &lt;- c(1,2,3,4,2,4,6,8,10,14,18,22,24,30,36,42)\nniveis &lt;- c(rep(\"A\",4),rep(\"B\", 4), rep(\"C\", 4), rep(\"D\", 4)) # criação de dataframe com níveis\n\ndf &lt;-data.frame(tempo, resposta, niveis); df\n\n   tempo resposta niveis\n1      1        1      A\n2      2        2      A\n3      3        3      A\n4      4        4      A\n5      1        2      B\n6      2        4      B\n7      3        6      B\n8      4        8      B\n9      1       10      C\n10     2       14      C\n11     3       18      C\n12     4       22      C\n13     1       24      D\n14     2       30      D\n15     3       36      D\n16     4       42      D\n17     1        1      A\n18     2        2      A\n19     3        3      A\n20     4        4      A\n21     1        2      B\n22     2        4      B\n23     3        6      B\n24     4        8      B\n25     1       10      C\n26     2       14      C\n27     3       18      C\n28     4       22      C\n29     1       24      D\n30     2       30      D\n31     3       36      D\n32     4       42      D\n33     1        1      A\n34     2        2      A\n35     3        3      A\n36     4        4      A\n37     1        2      B\n38     2        4      B\n39     3        6      B\n40     4        8      B\n41     1       10      C\n42     2       14      C\n43     3       18      C\n44     4       22      C\n45     1       24      D\n46     2       30      D\n47     3       36      D\n48     4       42      D\n49     1        1      A\n50     2        2      A\n51     3        3      A\n52     4        4      A\n53     1        2      B\n54     2        4      B\n55     3        6      B\n56     4        8      B\n57     1       10      C\n58     2       14      C\n59     3       18      C\n60     4       22      C\n61     1       24      D\n62     2       30      D\n63     3       36      D\n64     4       42      D\n\nlibrary(ggplot2)\n\nggplot(data=df, aes(x=tempo, y=resposta)) +\n  geom_point(aes(shape=niveis, color=niveis)) +\n  geom_line(aes(linetype=niveis))\n\n\n\n\n      Note que cada elemento estético pode ser configurado para cada geom. Alternativamente, pode-se conferir os elementos estéticos combinando-os para o gráfico geral, bem como para cada camada:\n\ntempo &lt;- c(rep(rep(1:4, 4),4))\nresposta &lt;- c(1,2,3,4,2,4,6,8,10,14,18,22,24,30,36,42)\nniveis &lt;- c(rep(\"A\",4),rep(\"B\", 4), rep(\"C\", 4), rep(\"D\", 4)) # criação de dataframe com níveis\n\ndf &lt;-data.frame(tempo, resposta, niveis)\n\nlibrary(ggplot2)\nggplot(data=df, aes(x=tempo, y=resposta, shape=niveis, color=niveis)) +\n  geom_point(aes(size=5)) +\n  geom_line(aes(linetype=niveis))\n\n\n\n\n      Para um conjunto com visual sobreposição de pontos, pode-se também empregar a função jitter, como no graphics:\n\nggplot(data=df, aes(x=tempo, y=resposta)) +\n         geom_point() +\n         geom_jitter()\n\n\n\n\n\n\n8.4.16 Paineis (faceting)\n      Como um recurso estético e analítico significativo, o faceting permite ao ggplot2 a visualização multivariada em paineis. Seguem exemplos para o dataset acima.\n\ntempo &lt;- c(rep(rep(1:4, 4),4))\nresposta &lt;- c(1,2,3,4,2,4,6,8,10,14,18,22,24,30,36,42)\nniveis &lt;- c(rep(\"A\",4),rep(\"B\", 4), rep(\"C\", 4), rep(\"D\", 4)) # criação de dataframe com níveis\n\ndf &lt;-data.frame(tempo, resposta, niveis)\nggplot(data=df, aes(x=tempo, y=resposta, shape=niveis, color=niveis)) +\n  geom_point(aes(size=5)) +\n  geom_line(aes(linetype=niveis))+\n  facet_grid(cols=vars(niveis)) # paineis verticais (útil para visualização da ordenada) \n\n\n\nggplot(data=df, aes(x=tempo, y=resposta, shape=niveis, color=niveis)) +\n  geom_point(aes(size=5)) +\n  geom_line(aes(linetype=niveis))+\n  facet_grid(rows=vars(niveis)) # paineis horizontais (útil para visualização na abscissa)\n\n\n\nggplot(data=df, aes(x=tempo, y=resposta, shape=niveis, color=niveis)) +\n  geom_point(aes(size=5)) +\n  geom_line(aes(linetype=niveis))+\n  facet_wrap(vars(niveis)) # paineis divididos (útil na visualização equilibrada de abscissa e ordenada)\n\n\n\n\n\n\n8.4.17 Gráfico de matriz de dados\n      Assim como para o sistema base, o ggplot2 também permite a construção de gráficos de matriz de pontos (pairs), embora com maior riqueza de detalhes. Para isso, é necessária a instalação do pacote GGally, que extende as possibilidades do ggplot2, e o uso da função ggpairs, como segue:\n\nlibrary(GGally)\nggpairs(iris)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n8.4.18 O pacote ggmatplot\n      O ggplot2 foi concebido para visualização gráfica de dados em formato Long. Isso pode ser um tanto trabalhoso quando se tem dados em formato Wide, já que é necessário converter o dataset para Long.\n      Nesse sentido, o pacote ggmatplot foi idealizado de modo parecido ao matplot, tendo em mente a necessidade de se elaborar um gráfico com o pacote ggplot2, mas com dados originalmente em formato Wide. Segue um exemplo.\n\nx &lt;- c(2,5,7,10,13,20)\ny &lt;- c(4, 7, 17, 25, 50, 55)\nz &lt;- y/rnorm(6,0,1)\n\ndat&lt;-cbind(x,y,z)\n\nlibrary(ggmatplot)\nggmatplot(x,y,\n          size=2, shape=\"circle\", color =\"blue\")\n\n\n\nggmatplot(x,z,\n          alpha=0.5, size =5, shape = \"square\", col=\"purple\")\n\n\n\n\n      Assim como para o sistema base de graphics, existem tutoriais e livros completos sobre o uso detalhado do ggplot2, tendo-se arranhado aqui apenas algumas de suas características."
  },
  {
    "objectID": "graficos.html#o-sistema-lattice",
    "href": "graficos.html#o-sistema-lattice",
    "title": "8  Gráficos",
    "section": "8.5 O sistema lattice",
    "text": "8.5 O sistema lattice\n      Baseado na plotagem do sistema trellis, o lattice situa-se, ao menos na visão deste autor, a meio caminho entre o graphics e o ggplot2, combinando boas caraterísticas de ambos, tais como elencadas abaixo.\n\nPode-se trabalhar com formato Wide (graphics), bem como em Long (ggplot2);\nPossui simplicidade algorítmica para gráficos mais simples (graphics), embora possa produzir plots bastante complexos (e com algoritmo ídem), e em uma única linha de comando (ggplot2);\nTem seu ponto forte na elaboração de gráficos de dados multivariados (ggplot2), possibilitando sua apresentação em um único gráfico ou em paineis (faceting, ggplot2);\nComo o graphics, permite inserir resultados de computação estatística ou numérica na construção dos gráficos (embora não tão trivial como o base).\nComo o graphics, utiliza comandos semelhantes (cex, type, lty, etc).\n\n      O lattice emprega uma fórmula na construção de linha única de seu algoritmo (trellis), tal que:\nTrellis formula: y~x | variável_condicional, grupos = variável_grupo\n      Alguns exemplos a seguir empregam variações intuitivas da fórmula acima para a construção de gráficos no lattice:\n\nxyplot(y~x)\nxyplot(y~x1+x2)\nxyplot(y~x+y~z)\nxyplot(y~x | z)  # o símbolo \"|\" indica agrupamento\nxyplot(y~x | g1 + g2) # juntando dois subgrupos\nxyplot(y~x | g, groups = k ) # separa os paineis de níveis \"g\" por subgrupos \"k\"\n\n      O lattice permite a produção gráfica quer por formato Long como por Wide, com as fórmulas ilustradas a seguir:\n\nLong: \n  y~x | grupo \n  y~x, groups=grupo\nWide: y~x1+x2+...\n\n      O trecho de código abaixo exemplifica o uso do lattice para o dataframe multivariado utilizado para o ggplot2, para comparação, e incluindo algumas variações simples tanto do dataset como da linha de algoritmo.\n\ntempo &lt;- c(rep(rep(1:4, 4),4))\nresposta &lt;- c(1,2,3,4,2,4,6,8,10,14,18,22,24,30,36,42)\nresposta2 &lt;- resposta + runif(16,2,5)\nniveis &lt;- c(rep(\"A\",4),rep(\"B\", 4), rep(\"C\", 4), rep(\"D\", 4)) # criação de dataframe com níveis\ngrupos &lt;- rep(c(\"g1\", \"g2\", \"g3\", \"g4\"),4) \n\ndf &lt;-data.frame(tempo, resposta2, niveis, grupos) # criação de dataframe com níveis e grupos\n\ndf &lt;-data.frame(tempo, resposta2, niveis)\n\nlibrary(lattice)\nxyplot(resposta2~tempo, data=df) # plot básico\n\n\n\nxyplot(resposta2~tempo, groups=niveis, data=df,\n       type=c(\"p\",\"spline\")) # separação por grupos e adição de curva suave\n\n\n\nxyplot(resposta2~tempo | niveis, data=df,\n       type=c(\"p\",\"r\"),\n       cex=2, lty=4, pch=16, col=4,\n       alpha=0.5) # divisão em paineis e regressão linear\n\n\n\nxyplot(resposta2~tempo | niveis, groups = grupos, data=df) # divisão por paineis e grupo\n\n\n\n\n      Assim como para os sistemas anteriores, o lattice possui uma infinidade de variações, e cujo montante foge do escopo deste trabalho, sugerindo-se ao leitor o universo da internete, de ebooks e livros a respeito."
  },
  {
    "objectID": "graficos.html#outros-pacotes-gráficos",
    "href": "graficos.html#outros-pacotes-gráficos",
    "title": "8  Gráficos",
    "section": "8.6 Outros pacotes gráficos",
    "text": "8.6 Outros pacotes gráficos\n\n8.6.1 plotmath\n\n\n8.6.2 plotrix\n      Esse pacote permite a construção de diversos tipos de gráficos e personalizações variadas (escala partida, barras de erros), como os exemplificados pelo desenvolvedor.\n\nlibrary(plotrix)\n\ny&lt;-runif(10)\nerr&lt;-runif(10)\nplotCI(1:10,y,err,2*err,lwd=2,col=\"red\",scol=\"blue\",main=\"Dispersão\") # barras de erro em pontos\n\n\n\ndata(warpbreaks)\nattach(warpbreaks)\nwmeans&lt;-by(breaks,tension,mean)\nwsd&lt;-by(breaks,tension,sd)\nplotCI(barplot(wmeans,col=\"gray\",ylim=c(0,max(wmeans+wsd))),wmeans,wsd,add=TRUE) # barras de erro em barplot\n\n\n\nx &lt;-1:10; y=1:10\nplot(x,y)\n\n\n\ngap.plot(x, y, gap = c(2, 7), gap.axis = \"x\") # escala partida\n\nWarning in gap.plot(x, y, gap = c(2, 7), gap.axis = \"x\"): some values of x will\nnot be displayed\n\n\n\n\nzoomInPlot(rnorm(100),rnorm(100),rxlim=c(-1,1),rylim=c(-1,1), zoomtitle=\"Zoom In Plot\",titlepos=-1.5) # cria plot e janela retangular de ampliação de dados\n\n\n\npieval&lt;-c(2,4,6,8)\npielabels&lt;-\n  c(\"detestam\",\"são contrários\",\"não se \\n importam\",\"gostam muito\")\n# grab the radial positions of the labels\nlp&lt;-pie3D(pieval,radius=0.9,labels=pielabels,explode=0.1,main=\"torta 3\")\n\n\n\n\n\nggplot2 síntese\n\n\nlabs(x=, y=, title=, subtitle=, caption=)\n\ngeom_errobar(size=, colour=, alpha=, alpha.width=, aes(ymin = ymax = )\n\ntheme(legend.title=, legend.position=, legend.background=, legend.text=,\naxis.text.x=\n\nguides(colour=, size=, shape=, fill=, alpha=\n\nannotate(\"text\", x=, y=, label=)\n\ncoord_cartesian(xlim=, ylim=)\n\ngeom_hline(yintercept=, linetype=, size=, colour=, alpha=); geom_vline\n\ngeom_abline(intercept=, slope=, linetype, colour, alpha)\n\ngeom_points(shape=, colour=, size=, fill=, stsroke=, alpha=)\n\nstat_summary(fun.data= fun=, geom=, colour=, fill=, size=)\n\ngeom_line(size=, alpha=, linetype=, color=)\n\ngeom_smooth(data=subset(dataset,subconjunto)\ngemom_smooth(method=, formula=, method.args=list(start=), se=, span=, size=, colour=, alpha=, linetype=, n=)\nfaceting\n\n\nEm resumo:\ngeom_point()\ngeom_line()\ngeom_smooth()\ngeom_boxplot()\ngeom_bar()\n\nsize, colour, shape, alpha, linetype, fill, stroke\n\ncoord_cartesian(xlim, ylim)\n\ngeom_abline(yintercept, slope)\n\ngeom_smooth(method=, formula=)\n\n\n\n\n\nWickham, Hadley. 2011. “Ggplot2.” Wiley Interdisciplinary Reviews: Computational Statistics 3 (2): 180–85.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "tidyverse.html#guia-de-estilos",
    "href": "tidyverse.html#guia-de-estilos",
    "title": "9  Tidyverse",
    "section": "9.1 Guia de Estilos:",
    "text": "9.1 Guia de Estilos:\n\nlong names e explicativos\nespaços entre operações;\nsem espaços quando função “(…)” ;\nintroduzir espaços pra melhorar alinhamento (identação); pipe com espaço após dataset;\n2 espaços na linha de baixo se argumentos sucessivos (identação);\nseparação em seções comentadas: uso de # seção A"
  },
  {
    "objectID": "tidyverse.html#racional-de-análise",
    "href": "tidyverse.html#racional-de-análise",
    "title": "9  Tidyverse",
    "section": "9.2 Racional de Análise",
    "text": "9.2 Racional de Análise\n\n“main tools of data science: importing, tidying, transforming, and visualizing data”*\n\n\nImport: cria ou importa dos dados (import) - read.csv, read.table, tibble, tribble\nTidy: arruma os dados; se importado, rearranja pra plots/stats (reshape) - pivot_longer, pivot_wider\nTransform: modifica variáveis - dplyr (filter, arrange, mutate, transmute, rename, relocate, groups_by, summarize, slice)\nVisualize: plota os dados - ggplot2, base, lattice\nModel: analisa e modela os dados (anova, lm, nls, stats, pacotes)\nCommunicate: apresenta e compartilha a análise - rmarkdown, bookdown, blogdown, quarto"
  },
  {
    "objectID": "tidyverse.html#o-ecossistema-tidyverse",
    "href": "tidyverse.html#o-ecossistema-tidyverse",
    "title": "9  Tidyverse",
    "section": "9.3 O ecossistema Tidyverse",
    "text": "9.3 O ecossistema Tidyverse\n      No tidyverse os comandos são concatenados pelo operador pipe, %&gt;% (atualmente, |&gt;). O pipe permite que a ação sucedente seja realizada com o resultado da anterior, evitando-se definir variáveis para cada uma.\n\n9.3.1 Pacotes úteis do tidyverse\n\nlibrary(readr) # importação de database\nlibrary(magrittr) # uso do operador pipe\nlibrary(tibble) # conversão de data.frame pra manipulação\nlibrary(dplyr) # transformação de dataset (mutate/transmute, select, filter, slice, arrange, summarize, group_by)\nlibrary(ggplot2) # gráficos elegantes\n\n\n\n9.3.2 O pacote tibble\n\ndata2 &lt;-as_tibble(data) # converte em tibble\n\n\n\n9.3.3 O pacote dplyr e uso prático\n      Em Ciência de Dados trabalha-se com conjuntos multifatoriais de dados colhidos em grande quantidade. Para esse tipo de situação, a extração de dados e de subconjuntos pode ser mais trabalhosa pela sintaxe convencional do R, e mesmo pelas funções de vetorização (família apply). Aí entram em cena alguns verbos utilizados no Tidyverse para simplificar as operações de extração de subconjuntos. O exemplo a seguir aplica alguns desses verbos a um dataset criado com poucos cliques.\n\nlibrary(tidyverse)\ndata &lt;- read.table(header=TRUE, text='\n\nn    t    x   y\n2    10    0.46    1.74\n3    25    0.47    2.44\n4    50    0.49    3.19\n5    100    0.52    4.31\n6    150    0.54    5.14\n7    200    0.563    5.88\n8    300    0.58    7.13\n9    400    0.59    8.15\n10    500    0.61    9.10')\n\nlibrary(magrittr)\ndata2 &lt;- data %&gt;% # renomeia o dataset original\n  select(t,y) %&gt;% # seleciona as colunas t e y\n  mutate(ycalc=y*1e-6) %&gt;% # cálculo na coluna y\n  filter(ycalc &gt; 5e-6) %&gt;% # filtra a coluna y\n  arrange(desc(ycalc)) %&gt;% # arranja em ordem decrescente\n  rename(ycName=ycalc) # renomeia a coluna y\n\nprint(data2) # apresenta o resultado\n\n    t    y   ycName\n1 500 9.10 9.10e-06\n2 400 8.15 8.15e-06\n3 300 7.13 7.13e-06\n4 200 5.88 5.88e-06\n5 150 5.14 5.14e-06\n\n\n      O efeito prático do uso dos verbos do Tidyverse torna-se mais relevante em dados multivariados mais complexos que o exemplo acima.\ngroup_by slice (subset rows)"
  },
  {
    "objectID": "tabelas.html#formatando-uma-tabela-pipe",
    "href": "tabelas.html#formatando-uma-tabela-pipe",
    "title": "10  Tabelas",
    "section": "10.1 Formatando uma tabela pipe",
    "text": "10.1 Formatando uma tabela pipe\n      É possível alterar algumas características de uma tabela do quarto, tais como sua renderização estética e a largura. Atualmente os modelos para isso são listados abaixo.\n\n\"primary\", \"secondary\", \"success\", \"danger\", \"warning\", \"info\", \"light\", \"dark\", \"striped\", \"hover\", \"active\", \"bordered\", \"borderless\", \"sm\", \"responsive\", \"responsive-sm\", \"responsive-md\", \"responsive-lg\", \"responsive-xl\", \"responsive-xxl\"\n\n      Exemplificando para a tabela acima (modelos e largura):\n\nRendimento do processo.\n\n\nMétodo\nResultado\nObs\n\n\n\n\naquecimento\n12\nbanho fervente\n\n\nresfriamento\n52\ngeladeira\n\n\ncongelamento\n170\nfreezer\n\n\n\n      Também é possível explicitar a largura de tabelas por todo o documento, para uniformização:\n\n---\ntitle: \"Meu Doc\"\nformat: html\ntbl-colwidths: [75,25]\n---\n\n      O título da tabela pode ser inserido em locais distintos, bastando-se identificá-lo no cabeçalho de documento:\n\n---\ntbl-cap-location: top # também botton, margin\n---"
  },
  {
    "objectID": "tabelas.html#subtabelas",
    "href": "tabelas.html#subtabelas",
    "title": "10  Tabelas",
    "section": "10.2 Subtabelas",
    "text": "10.2 Subtabelas\n      Ilustrando:\n\n::: {#tbl-panel layout-ncol=2}\n| Procedimento | Amostra 1  | Amostra 2\n|--------------|------------|-----------|\n| resfriamento |     17     |     28    |\n| aquecimento  |     25     |     32    |\n\n\n: Primeiro conjunto de ensaios {#tbl-first}\n\n| Procedimento | Amostra 3  | Amostra 4\n|--------------|------------|-----------|\n| resfriamento |     15     |     31    |\n| aquecimento  |     16     |     12    |\n\n: Segundo conjunto de ensaios {#tbl-second}\n\nTratamento de amostras por variação térmica.\n:::\n\nA @tbl-panel engloba dois ensaios, embora a @tbl-second foi obtida com dados mais recentes.\n\n      Resultado:\n\n\nTabela 10.1: Tratamento de amostras por variação térmica.\n\n\n\n\n(a) Primeiro conjunto de ensaios\n\n\nProcedimento\nAmostra 1\nAmostra 2\n\n\n\n\nresfriamento\n17\n28\n\n\naquecimento\n25\n32\n\n\n\n\n\n\n(b) Segundo conjunto de ensaios\n\n\nProcedimento\nAmostra 3\nAmostra 4\n\n\n\n\nresfriamento\n15\n31\n\n\naquecimento\n16\n12\n\n\n\n\n\n\nA Tabela 10.1 engloba dois ensaios, embora a Tabela 10.1 (b) foi obtida com dados mais recentes."
  },
  {
    "objectID": "tabelas.html#tabelas-em-grade",
    "href": "tabelas.html#tabelas-em-grade",
    "title": "10  Tabelas",
    "section": "10.3 Tabelas em grade",
    "text": "10.3 Tabelas em grade\n      A tabela grid table é um pouco mais complexa na elaboração, mas permite a inserção de textos, parágrafos e bullets, como segue:\n\n+--------------------+-------------+--------------------+\n| Ítem               | Preço       | Empresas           |\n+===========+===========+===============================+\n| osciloscópio       | R$ 2.100,00 | - loja A           |\n|                    |             | - loja B           |\n+-----------+-----------+-------------------------------+\n| gerador de funções | R$ 3.200,00 | - loja C           |\n|                    |             | - loja D           |\n+--------------------+----------------------------------+\n\n: Orçamento de equipamentos.\n\n\n\n      Resultado:\n\nOrçamento de equipamentos.\n\n\n\n\n\n\n\nÍtem\nPreço\nEmpresas\n\n\n\n\nosciloscópio\nR$ 2.100,00\n\nloja A\nloja B\n\n\n\ngerador de funções\n\n\nloja C\nloja D"
  },
  {
    "objectID": "tabelas.html#o-pacote-kable",
    "href": "tabelas.html#o-pacote-kable",
    "title": "10  Tabelas",
    "section": "10.4 O pacote kable",
    "text": "10.4 O pacote kable\n      Dentre as diversas funções para a produção de tabelas estáticas pelo R destaca-se a função kable presente no pacote knitr. Assim como na tabela pipe padrão, ela renderiza a partir da inserção de dados, embora não por digitação de texto simples, mas por comandos do R, como os utilizados para a construção de dataframes (planilhas de dados). Ilustrando o uso da função kable:\n\nTratamento &lt;- c(\"aquecimento\", \"resfriamento\", \"congelamento\")\n\nRendimento &lt;- c(42, 35, 14)\n\ndados &lt;- data.frame(Tratamento, Rendimento)\n\nlibrary(knitr)\n\nkable(dados, caption = \"Processamento das amostras.\")\n\n\nProcessamento das amostras.\n\n\nTratamento\nRendimento\n\n\n\n\naquecimento\n42\n\n\nresfriamento\n35\n\n\ncongelamento\n14\n\n\n\n\n\n      Também pode-se contruir a tabela por kable por comando que insere a própria biblioteca knitr:\n\nknitr::kable(head(dados), \"pipe\")\n\n\n\n\nTratamento\nRendimento\n\n\n\n\naquecimento\n42\n\n\nresfriamento\n35\n\n\ncongelamento\n14\n\n\n\n\n\n      Ainda que simples na execução, há diversos argumento para kable, incluindo tipos, alinhamento, digitos visíveis, dentre muitas, como segue.\n\nkable(x, format, digits = getOption(\"digits\"), row.names = NA,\n  col.names = NA, align, caption = NULL, label = NULL,\n  format.args = list(), escape = TRUE, ...)\n\n      Adicionalmente, é possível aprimorar esteticamente o resultado de kable com o pacote kableExtra, como segue.\n\nlibrary(kableExtra)\n\nkbl(dados)\n\nknitr::kable(dados)%&gt;%\n    kable_classic()"
  },
  {
    "objectID": "equacoes.html#alguns-comandos-latex-para-equações",
    "href": "equacoes.html#alguns-comandos-latex-para-equações",
    "title": "11  Equações",
    "section": "11.1 Alguns comandos LaTex para equações",
    "text": "11.1 Alguns comandos LaTex para equações\n      Como o Pandoc renderiza a partir da linguagem LaTex, seguem alguns exemplos de sintaxe para a inserção de equaçõe em Rmarkdown.\n\n- frações: $${a}{b}$$\n- subscrito: $$a_b$$\n- superescrito: $$a^b$$\n- raiz quadrada: $$sqrt(a)$$\n- média: $$\\bar{x}$$\n- somatória: $$\\sum_{i = 1}^{j}{a_i*b_j}$$\n- grego: $$\\alpha$$ $$\\beta$$ $$\\theta$$ $$\\sigma$$ $$\\Delta$$\n\n\nfrações: \\[{a}{b}\\]\nsubscrito: \\[a_b\\]\nsuperescrito: \\[a^b\\]\nraiz quadrada: \\[sqrt(a)\\]\nmédia: \\[\\bar{x}\\]\nsomatória: \\[\\sum_{i = 1}^{j}{a_i*b_j}\\]\ngrego: \\[\\alpha\\] \\[\\beta\\] \\[\\theta\\] \\[\\sigma\\] \\[\\Delta\\]\n\n      Como mencionado acima, o Rmarkdown é compilado para LaTex pelo Pandoc. Dessa forma, é possível também inserir no documento linhas de comando do LaTex, e mesmo pacotes desse. Ilustrando-se, o código abaixo compila no documento Rmarkdown uma equação gerada pelo ambiente de equações do Latex.\n\n\\begin{equation}\n\\bar{X} = \\frac{\\sum_{i=1}^j \\bar(x_i}{j} (\\#eq:mean)\n\\end{equation}\n\n\\[\\begin{equation}\n\\bar{X} = \\frac{\\sum_{i=1}^j} {\\bar{(x_i)}}\n\\end{equation}\\]"
  },
  {
    "objectID": "diagramas.html",
    "href": "diagramas.html",
    "title": "12  Diagramas",
    "section": "",
    "text": "Existem alguns pacotes em R para a elaboração de fluxogramas, diagramas e redes, e gráficos de Gantt como DiagrammeR. Não obstante, o Quarto possui dois sistemas embarcados, Mermaid, construido em JavaScript, e Graphviz.\n      A produção de documentos em PDF ou DOC contendo diagramas por Mermaid ou Graphviz requer uma instalação do Chrome para renderização de imagens com qualidade de impressão. Caso não o navegador não esteja instalado, basta fazê-lo por:\n\nquarto tools install chromium\n\n\n12.0.1 Mermaid\n      Usando-se o mermaid para inserir um diagrama num documento Rmarkdown, basta indicar no cabeçalho do chunk, como ilustrado abaixo.\n\nflowchart LR \n  A[glicose] --&gt; B(Fru-6P)\n  B --&gt; C{Fru-1,6-bifosfato}\n  C --&gt; D[gliceraldeído-3P]\n  C --&gt; E[Diidroxicetona-P]\n\n\n\n\n\nflowchart LR\n  A[glicose] --&gt; B(Fru-6P)\n  B --&gt; C{Fru-1,6-bifosfato}\n  C --&gt; D[gliceraldeído-3P]\n  C --&gt; E[Diidroxicetona-P]\n\n\n\n\n\n\n\n12.0.2 DiagrammeR\n      Já para o pacote DiagrammeR, ilustra-se sua simplicidade pelo trecho de código que segue:\n\nlibrary(DiagrammeR)\nDiagrammeR(\"\n   graph TB \n   A--&gt;B\n   A--&gt;C\n   C--&gt;E\n   B--&gt;D\n   C--&gt;D\n   D--&gt;F\n   E--&gt;F\n\")"
  },
  {
    "objectID": "refsCruzadas.html#sec-nomeSubtitulos",
    "href": "refsCruzadas.html#sec-nomeSubtitulos",
    "title": "13  Referenciação",
    "section": "13.1 Subtítulos",
    "text": "13.1 Subtítulos\n\nPara nomear subtítulos:\n\n\n## Subtítulos {#sec-nomeSubtitulos}\n\n\nPara referenciar\n\n\n ...conforme @sec-nomeSubtitulos.\n\n\nResultado:\n\n…conforme Seção 13.1."
  },
  {
    "objectID": "refsCruzadas.html#figuras",
    "href": "refsCruzadas.html#figuras",
    "title": "13  Referenciação",
    "section": "13.2 Figuras",
    "text": "13.2 Figuras\n\nPara nomear a figura:\n\n\n![Logo do R.](logoR.png){#fig-logoR}\n\n\nResultado:\n\n\n\n\nFigura 13.1: Exemplo de logotipo do R.\n\n\n\n3. Para referenciar: ...conforme @fig-logoR.\n\n\nResultado: …conforme Figura 13.1."
  },
  {
    "objectID": "refsCruzadas.html#tabelas",
    "href": "refsCruzadas.html#tabelas",
    "title": "13  Referenciação",
    "section": "13.3 Tabelas",
    "text": "13.3 Tabelas\n\nPara nomear uma tabela:\n\n\n| A | B | C |\n|---|---|---|\n| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n\n: Título da tabela {#tbl-nomeTabela}\n\n\nResultado:\n\n\n\nTabela 13.1: Título da tabela\n\n\nA\nB\nC\n\n\n\n\n1\n2\n3\n\n\n4\n5\n6\n\n\n\n\n\n3. Para referenciar: ...conforme @tbl-nomeTabela.\n\n\nResultado: …conforme Tabela 13.1."
  },
  {
    "objectID": "refsCruzadas.html#equações",
    "href": "refsCruzadas.html#equações",
    "title": "13  Referenciação",
    "section": "13.4 Equações",
    "text": "13.4 Equações\n      São referenciadas no próprio chunk, ou no ambiente de equações do LaTex. Assim.\n\nPara nomear a equação:\n\n\n$$\ny = a*x+b\n$$ {#eq-nomeEquacao}\n\n\nResultado:\n\n\\[\ny = a*x+b\n\\tag{13.1}\\]\n\n3. Para referenciar: ...conforme @eq-nomeEquacao.\n\n\nResultado: …conforme Equação 13.1."
  },
  {
    "objectID": "bibliografia.html",
    "href": "bibliografia.html",
    "title": "14  Bibliografia",
    "section": "",
    "text": "Para citações bibliográficas:\n\n1. Com autor e data: colocar entre parênteses; [ @bib ]\n2. Múltiplas entradas: [@bib1; @bib2]\n3. Suprimindo o autor (só data): [-@bib]\n\n      A bibliografia é inserida automaticamente ao final de um documento; dessa forma, basta terminá-lo com algo como “Referências”, por exemplo. Isso é bastante útil quando se deseja alocar referência bibliográficas em cada capítulo de um livro, por exemplo.\n      Por outro lado, se desejar-se alocá-la antes do final, como precedente ao um Apêndice ou Anexo, basta digitar o trecho de código abaixo:\n\n# References\n\n&lt;div id=\"refs\"&gt;&lt;/div&gt;\n\n      Alternativamente, pode-se também alocar diretamente o trecho que segue em um arquivo qmd listado ao final do documento de metadados *_quarto.yml* (algo como referencias.qmd), tal como abaixo:\n\n# Referências {.unnumbered}\n\n::: {#refs}\n:::\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.\n\n\nVuorre, Matti, and James P Curley. 2018. “Curating Research\nAssets: A Tutorial on the Git Version Control System.”\nAdvances in Methods and Practices in Psychological Science 1\n(2): 219–36.\n\n\nWickham, Hadley. 2011. “Ggplot2.” Wiley\nInterdisciplinary Reviews: Computational Statistics 3 (2): 180–85.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "acoes.html#alguns-comandos-gerais-para-dados",
    "href": "acoes.html#alguns-comandos-gerais-para-dados",
    "title": "15  Ações",
    "section": "15.1 Alguns comandos gerais para dados",
    "text": "15.1 Alguns comandos gerais para dados\n\n&lt;- # operador de atribuição (Alt -); o mesmo que \"=\", embora possa distinguir-se desse didaticamente, apenas (\"=\" é mais usador para declaração de variáveis)\n  \nCtrL + Shift + C # adição de comentário\nCtrl + L # limpa o Console\nCtrl + Shift + S # executa o script no RStudio\n\nNA, null # \"Not Available\", \"Non existent\"\n\nexample(\"function\")\ndemo(lm.glm, package = \"stats\", ask = FALSE) # exemplos e demonstrações de funções\n\noptions(digits = 3) # fixa no no. de dígitos \n\nlocale(decimal_mark = \",\") # útil só pra importação (calc, gnumeric). Evitar para cálculos, já que o `R` opera originalmente com separador \".\"\n\na = 2 # atribuição de variável \na &lt;- 2 # atribuição de variável (ou...Alt -)\n# Obs: embora seja uma forma computacional padrão do `R` para diferenciar valores de outros objetos (vetor, por ex), não é recomendável por alguns autores, posto que 1) requer 1 clique a mais pra atribuição, e 2) pode resultar em erro se digitado errado (ex: x&lt; -y, \"x menor que menos y\")\n\n rm(list=ls()) # remove todos os objetos do ambiente (útil pra evitar problemas com variáveis homônimas)\n \n system.time(\"expressão, função, script\") # fornece o tempo decorrido da ação\n \n x &lt;- 1:5\ny &lt;- x^2\nlmxy &lt;- lm(y~x)\nattributes(lmxy) # elenca os objetos disponíveis de uma função após sua execução"
  },
  {
    "objectID": "acoes.html#saída-output-de-informação",
    "href": "acoes.html#saída-output-de-informação",
    "title": "15  Ações",
    "section": "15.2 Saída (output) de informação",
    "text": "15.2 Saída (output) de informação\n\npaste() # cria um vetor concatenado após convertê-lo a caracter; se mais de um dado, repete a frase a cada\n\nprint() # imprime na tela o conteúdo\n\ncat() # concatena vetor após conversão em caracter, mas juntando a saída numa frase apenas\n\n\n15.2.1 Layout da saída\n\n# Saída de dados (*output*):\n\"\\n\" # linha de baixo\n\"\\n\\n\" # 2 linhas abaixo\n\\t # tabulação \n\\t\\t # 2 tabulações\n\"%\\n\" # linha de baixo, valor percentual"
  },
  {
    "objectID": "acoes.html#entrada-de-informação",
    "href": "acoes.html#entrada-de-informação",
    "title": "15  Ações",
    "section": "15.3 Entrada de informação",
    "text": "15.3 Entrada de informação\n\nreadline() # readline(prompt=\"Press [enter] to proceed\"))\n\nscan() # input de valores numéricos para criação de vetor"
  },
  {
    "objectID": "acoes.html#modo-batch",
    "href": "acoes.html#modo-batch",
    "title": "15  Ações",
    "section": "15.4 Modo Batch",
    "text": "15.4 Modo Batch\n      Por vezes é interessante executar um script do R para determinado cálculo ou gráfico, sem a necessidade manual de se entrar no programa, buscar o script e rodá-lo no ambiente.\n      Nesse caso o código pode ser carregado diretamente no shell do sistema operacional, pela janela de comando de prompt (Terminal, se Linux; cmd, se Windows). Para ilustrar, experimente o trecho de código abaixo:\n\n# 1. Elaborar o script\n\npdf(\"testeBatch.pdf\")\nx &lt;- 1:5\ny &lt;- sqrt(x)\nplot(x,y)\ndev.off\n\n# 2. Salvar como \"tBatch.R\"\n\n# 3. Comando para o cmd ou Terminal:\n# R CMD BATCH tBatch.R\n\n      Após rodá-lo, o gráfico contido no arquivo “testeBatch.pdf” deverá aparecer no path do R (Home, por exemplo).\n      A limitação para um script rodado em modo batch é que sua construção deve visar um resultado final, sem entradas intermediárias do usuário."
  },
  {
    "objectID": "acoes.html#manipulação-de-elementos-de-vetor",
    "href": "acoes.html#manipulação-de-elementos-de-vetor",
    "title": "15  Ações",
    "section": "15.5 Manipulação de elementos de vetor",
    "text": "15.5 Manipulação de elementos de vetor\n\nsort() # ordem numérica ou alfabética; opção: decreasing = TRUE; alocar NA ao final: na.last=TRUE\n\norder() # define a ordem\n\nrev() # reverte a ordem\n\nunique() # remove duplicatas (útil pra estabelecer vetor de fatores em um dataset)"
  },
  {
    "objectID": "acoes.html#geração-de-sequência-de-dados",
    "href": "acoes.html#geração-de-sequência-de-dados",
    "title": "15  Ações",
    "section": "15.6 Geração de sequência de dados",
    "text": "15.6 Geração de sequência de dados\n\n15.6.1 Sequências pré-definidas\n      A geração de sequências no R exprime na verdade a criação de vetores. Essa pode ocorrer manualmente ou pelo comando seq. Seguem alguns exemplos:\n\nx &lt;- c(1,2,3,4,5) # criação manual de vetor; \"c\" significa \"concatenated\".\nx=1:10 # espaçamento unitário \nx=seq(from=0, to=2, by=0.1 ) # espaçamento definido\nx = 0:2/0.1 # operação matemática na criação do vetor\nx=seq(1,8,length=0.4) # no. fixo de valores intermediários\n\n\n\n15.6.2 Sequências aleatórias\n      Sequências também podem originar-se aleatoriamente, como abaixo:\n\nset.seed = 2 # semente aleatória para reprodutibilidade da simulação\nrunif(n=10) # \"random uniform\" (apenas no. de valores)\n\n [1] 0.74257043 0.77263291 0.82845162 0.48873818 0.64855100 0.05646319\n [7] 0.40489865 0.04155646 0.49129931 0.69602411\n\nrunif(50,2,10) # runif(n,min,max); obs: quando sem atributos, considera-se min=0  e max=1\n\n [1] 3.472742 4.102464 4.060830 3.926758 3.690325 9.381834 4.121709 8.035480\n [9] 4.929705 9.814193 5.501633 5.113694 7.643346 7.182313 7.792147 2.207860\n[17] 6.129758 9.039584 4.187971 3.937556 6.314506 8.256878 8.295247 4.639962\n[25] 2.031799 2.255353 3.478595 2.965041 9.335832 9.790133 2.508336 8.485602\n[33] 3.501524 3.025533 8.618485 4.578911 2.283347 4.015370 4.565211 7.932445\n[41] 2.573121 6.620035 4.106883 9.054555 5.183950 5.659865 9.723794 8.298909\n[49] 6.459717 9.115827\n\nrnorm(50,10,2) # números de distribuição normal; rnorm(n,média,variância); obs: quando sem atributos, considera-se média=0 e var=1\n\n [1] 10.689904 10.280827 10.211135 12.763804  8.038114 12.138921 11.914858\n [8] 13.902723  9.294400 11.163277  8.777674  8.966937 10.022803 10.201417\n[15]  5.203107  8.649936 12.837258 10.328762  8.986259  9.062001 11.157146\n[22]  9.276889  5.186229  9.725580  8.316294 10.669201  8.233254  7.744139\n[29]  9.923752  7.979181 11.482817  8.751646  9.463810  6.747651 10.799573\n[36]  8.170025 11.150149  8.036286  8.365816  7.027476 10.325727  8.672471\n[43]  8.166128 11.639383 12.198440 10.795656 10.022864 10.887387 10.779879\n[50] 11.653001\n\nrn&lt;-rnorm(50,10,2); ceiling(rn*10) # geração de números inteiros aleatórios\n\n [1] 108 113  97 105  72 112  90 120  77 125  99  80  84  87 107 123  96 116  91\n[20]  43  97  92 122 119 107 140 112 119  84 105  72 115 113  73  78  84  91  93\n[39] 111  86  67 102 123 120 122 162 132  90  89 122"
  },
  {
    "objectID": "acoes.html#criação-de-sequência-por-amostragem",
    "href": "acoes.html#criação-de-sequência-por-amostragem",
    "title": "15  Ações",
    "section": "15.7 Criação de sequência por amostragem",
    "text": "15.7 Criação de sequência por amostragem\n      A amostragem de um conjunto de dados pode ser considerada interessante quando se tem um subconjunto de dados que deseja-se repetir aleatoriamente:\n\nsample(c(\"Ala\", \"Glu\", \"Tyr\", \"Val\"), size = 10, replace = TRUE, prob = c(0.3, 0.2, 0.4, 0.1))\n\n [1] \"Tyr\" \"Glu\" \"Tyr\" \"Tyr\" \"Val\" \"Ala\" \"Tyr\" \"Tyr\" \"Tyr\" \"Ala\""
  },
  {
    "objectID": "acoes.html#criação-e-manipulação-de-vetores",
    "href": "acoes.html#criação-e-manipulação-de-vetores",
    "title": "15  Ações",
    "section": "15.8 Criação e manipulação de vetores",
    "text": "15.8 Criação e manipulação de vetores\n      Da mesma forma como as sequências criadas acima, também são os vetores, uma classe específica de objeto do R. Vetores podem ser pensados como colunas de uma planilha, ou linhas da mesma. Para se criar e editar um vetor existem diveras formas, algumas exemplificadas abaixo.\n\nx &lt;- c(1,2,3,4,5,5,6,6,7,7,NA,NA,14:19); # cria um vetor com valores, \"missing values\", e sequência\nxinv &lt;- rev(x); xinv # ordem reversa do vetor\n\n [1] 19 18 17 16 15 14 NA NA  7  7  6  6  5  5  4  3  2  1\n\nc(x,8) # adiciona 8 ao vetor\n\n [1]  1  2  3  4  5  5  6  6  7  7 NA NA 14 15 16 17 18 19  8\n\nx[-7] # remove o 7o. valor\n\n [1]  1  2  3  4  5  5  6  7  7 NA NA 14 15 16 17 18 19\n\nx[2:5] # apresenta os valores da posição 2 a 5\n\n[1] 2 3 4 5\n\nx[x*x &gt; 50] # operação em vetor; fornece os elementos cujo quadrado é superior a 50\n\n[1] NA NA 14 15 16 17 18 19\n\nx[c(-1,-2)] # não apresenta os valores nas posições 1 e 2\n\n [1]  3  4  5  5  6  6  7  7 NA NA 14 15 16 17 18 19\n\nx[c(7,9)] # extrai os valores nas posições 1 e 3 do vetor\n\n[1] 6 7\n\nunique (x) # remove as duplicatas\n\n [1]  1  2  3  4  5  6  7 NA 14 15 16 17 18 19\n\nsum(x, na.rm=TRUE) # remove NA (\"Not Available\") ao aplicar uma função\n\n[1] 145\n\nsum(which=5:7) # aplica função em um intervalo\n\n[1] 18\n\nsubset(x,x&gt;5) # filtra os dados em vetor ou  *dataset*\n\n [1]  6  6  7  7 14 15 16 17 18 19\n\nsample(x,3) # amostra de 3 elementos\n\n[1] 15 19  3\n\nrep(x,3) # repete os dados 3 vezes\n\n [1]  1  2  3  4  5  5  6  6  7  7 NA NA 14 15 16 17 18 19  1  2  3  4  5  5  6\n[26]  6  7  7 NA NA 14 15 16 17 18 19  1  2  3  4  5  5  6  6  7  7 NA NA 14 15\n[51] 16 17 18 19\n\n\n\n15.8.1 Vetores a partir de colagem de uma planilha\n      Por vezes é mais fácil obter os dados de uma planilha como MS-Excel. Para incorporá-los ao R sem ter que digitá-los, um modo simples envolve copiar a coluna ou linha da planilha, e aplicar a função scan, como segue.\n\n1. Copia os dados da planilha;\n2. x &lt;- scan () # deverá aparecer um campo no Console para colagem; após essa, dar dar dois cliques para fechar a conexão da função\n\n      Como já apresentado em capítulo anterior, pode-se alternativamente colar os dados de modo mais visível, apresentando-os num script, pelo uso da função read.table.\n\nmeus.dados &lt;- read.table(header=T, text=' # abre a conexão\n# colar os dados\n') # fecha a conexão\n\n\n\n15.8.2 Repetição\n      Também faz-se interessante um procedimento automático para a geração de valores repetidos. Isso pode ser de utilidade quando se deseja obter replicatas de resultados a partir de um mesmo valor de premissa. Abaixo seguem alguns exemplos para o comando rep.\n\nrep(5,3) # repete o valor 5 para 3 vezes\n\n[1] 5 5 5\n\nrep(c(1,2,3),4) # repete o vetor 4 vezes\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3\n\nrep(c(1,2,3),each=4) # repete cada valor do vetor 4\n\n [1] 1 1 1 1 2 2 2 2 3 3 3 3\n\nrep( 1:7, 3 ) # repete 1 a 4, 3 vezes\n\n [1] 1 2 3 4 5 6 7 1 2 3 4 5 6 7 1 2 3 4 5 6 7"
  },
  {
    "objectID": "acoes.html#crescimento-de-vetores",
    "href": "acoes.html#crescimento-de-vetores",
    "title": "15  Ações",
    "section": "15.9 Crescimento de vetores",
    "text": "15.9 Crescimento de vetores\n\nx &lt;- 2\ny &lt;- vector(length = 5)\n\ny [ 1 ] &lt;- x^2\ny [ 2 ] &lt;- x^3+5\ny [ 3 ] &lt;- x/4\ny [ 4 ] &lt;- sqrt(x)\ny [ 5 ] &lt;- log10(x)\ny\n\n[1]  4.000000 13.000000  0.500000  1.414214  0.301030\n\n\n\n#Define função e plot de titulação\nfa = function(pH,pKa) {\n  x=0\n  for(i in 1:length(pKa)) {\n    x = x+1/(1 + 10^(pH - pKa[i]))}\n  return(x)\n}\npKa=c(2.2,7.2,12.7)\ncurve(fa(x,pKa),1,14, xlab=\"pH\", ylab=\"fa\",\n      col=2)"
  },
  {
    "objectID": "acoes.html#criação-de-dataframes-e-matrizes",
    "href": "acoes.html#criação-de-dataframes-e-matrizes",
    "title": "15  Ações",
    "section": "15.10 Criação de dataframes e matrizes",
    "text": "15.10 Criação de dataframes e matrizes\n      Dataframes são como matrizes, com a diferença de facultar mais de um tipo de objeto (valor, caractere). Como um tipo de matriz, dataframes (quadro de dados, em tradução livre) são mais apropriados à análise de relações quantitativas entre variáveis, gerando gráficos, modelos matemáticos, ajustes decorrentes, e predições. A criação de dataframes pode ser ilustrada abaixo:\n\n# Manualmente:\ndata.frame(list(\n  x = c(1,2,3,4,5),\n  y = c(6,7,8,9,10)))\n\n  x  y\n1 1  6\n2 2  7\n3 3  8\n4 4  9\n5 5 10\n\n# Combinando vetores:\n## 1. Por nomes\nv1 = c(11,12,13,14); v2 = c(27,28,29,30)\ndata.frame(v1,v2)\n\n  v1 v2\n1 11 27\n2 12 28\n3 13 29\n4 14 30\n\n## 2. Como uma matriz\ncbind(v2,v1)\n\n     v2 v1\n[1,] 27 11\n[2,] 28 12\n[3,] 29 13\n[4,] 30 14\n\nrbind(v1,v2)\n\n   [,1] [,2] [,3] [,4]\nv1   11   12   13   14\nv2   27   28   29   30\n\n\n\n# 3. Copiando de uma planilha\nlibrary(clipr) # requer instalação prévia\ndf &lt;- read_clip_tbl() # após copiar os dados\n\n\n15.10.1 Manipulação de dataframes\n      Após a obtenção dos dados, pode-se editá-los para inserção, eliminação, subconjuntos, e para cálculos, como segue.\n\n$$\nmeus.dados[ri:rf, c(ci,cf)]\n$$\n\n      Onde:\n\nr = linha (row)\nc = coluna (column)\ni e f = inicial, final\n\n        Ilustrando,\n\ndf &lt;- data.frame(\n  x = c(1,2,3,4,5,6,7,8,9),\n  y = c(6,7,8,9,10,11,12,13,14)) # criação do dataframe\n\nncol(df);nrow(df) # no. de colunas e de linhas\n\n[1] 2\n\n\n[1] 9\n\ndfh &lt;- head(df); print(dfh) # primeiros elementos\n\n  x  y\n1 1  6\n2 2  7\n3 3  8\n4 4  9\n5 5 10\n6 6 11\n\ndft &lt;- tail(df); print(dft) # elementos excetuando-se o primeiro\n\n  x  y\n4 4  9\n5 5 10\n6 6 11\n7 7 12\n8 8 13\n9 9 14\n\ncolnames(df)=c(\"A\",\"B\"); print(df) # altera nome das colunas (similar: rownames)\n\n  A  B\n1 1  6\n2 2  7\n3 3  8\n4 4  9\n5 5 10\n6 6 11\n7 7 12\n8 8 13\n9 9 14\n\nt(df) # transposição dos dados\n\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\nA    1    2    3    4    5    6    7    8    9\nB    6    7    8    9   10   11   12   13   14\n\ndf[\"Z\"] = 101:109; print(df) # insere vetor coluna\n\n  A  B   Z\n1 1  6 101\n2 2  7 102\n3 3  8 103\n4 4  9 104\n5 5 10 105\n6 6 11 106\n7 7 12 107\n8 8 13 108\n9 9 14 109\n\ndf[\"x.inv\"] &lt;- 1/df$x; print(df) # insere um vetor calculado \n\n  A  B   Z x.inv\n1 1  6 101    NA\n2 2  7 102    NA\n3 3  8 103    NA\n4 4  9 104    NA\n5 5 10 105    NA\n6 6 11 106    NA\n7 7 12 107    NA\n8 8 13 108    NA\n9 9 14 109    NA\n\ndf$W = 19:27; print(df) # outra forma de inserção\n\n  A  B   Z x.inv  W\n1 1  6 101    NA 19\n2 2  7 102    NA 20\n3 3  8 103    NA 21\n4 4  9 104    NA 22\n5 5 10 105    NA 23\n6 6 11 106    NA 24\n7 7 12 107    NA 25\n8 8 13 108    NA 26\n9 9 14 109    NA 27\n\ndf$W = NULL; print(df) # remove coluna (NULL, valor nulo; existe mas não é contabilizado)\n\n  A  B   Z x.inv\n1 1  6 101    NA\n2 2  7 102    NA\n3 3  8 103    NA\n4 4  9 104    NA\n5 5 10 105    NA\n6 6 11 106    NA\n7 7 12 107    NA\n8 8 13 108    NA\n9 9 14 109    NA\n\ndf$tot &lt;- df$A + df$B + df$Z; print(df) # criação de coluna com equação\n\n  A  B   Z x.inv tot\n1 1  6 101    NA 108\n2 2  7 102    NA 111\n3 3  8 103    NA 114\n4 4  9 104    NA 117\n5 5 10 105    NA 120\n6 6 11 106    NA 123\n7 7 12 107    NA 126\n8 8 13 108    NA 129\n9 9 14 109    NA 132\n\ndf.c2 &lt;- df[,-2]; df.c2 # retira a 2a. coluna do dataset\n\n  A   Z x.inv tot\n1 1 101    NA 108\n2 2 102    NA 111\n3 3 103    NA 114\n4 4 104    NA 117\n5 5 105    NA 120\n6 6 106    NA 123\n7 7 107    NA 126\n8 8 108    NA 129\n9 9 109    NA 132\n\ndf.r3 &lt;- df[-3,]; df.r3 # retira a 3a. linha do dataset\n\n  A  B   Z x.inv tot\n1 1  6 101    NA 108\n2 2  7 102    NA 111\n4 4  9 104    NA 117\n5 5 10 105    NA 120\n6 6 11 106    NA 123\n7 7 12 107    NA 126\n8 8 13 108    NA 129\n9 9 14 109    NA 132\n\ndf2 &lt;- 5*df; print(df2) # cálculo em todo o dataset\n\n   A  B   Z x.inv tot\n1  5 30 505    NA 540\n2 10 35 510    NA 555\n3 15 40 515    NA 570\n4 20 45 520    NA 585\n5 25 50 525    NA 600\n6 30 55 530    NA 615\n7 35 60 535    NA 630\n8 40 65 540    NA 645\n9 45 70 545    NA 660\n\ndfall &lt;- merge(df,df2); print(dfall) # fusão de datasets\n\n[1] A     B     Z     x.inv tot  \n&lt;0 rows&gt; (or 0-length row.names)\n\n\n      Também é possível criar um dataframe como uma matriz, incluindo a nomeação de linhas, com comando de matrizes, dimnames.\n\nm &lt;- matrix(c(70,60,40,60,40,20),nrow=2, byrow=TRUE,\n            dimnames=list(c(\"teste1\", \"teste2\"), c(\"controle\", \"método1\", \"método2\")))"
  },
  {
    "objectID": "acoes.html#subconjunto",
    "href": "acoes.html#subconjunto",
    "title": "15  Ações",
    "section": "15.11 Subconjunto",
    "text": "15.11 Subconjunto\n      Subconjunto de dados são de extrema valia quando se deseja focar num determinado intervalo dos dados, quer para visualização (gráficos) como para análises (ajuste de modelos). O comando subset que implica em subconjuntos é ilustrado abaixo.\n\ndf &lt;- data.frame(list(\n  x = c(1,2,3,4,5,6,7,8,9),\n  y = c(6,7,8,9,10,11,12,13,14),\n  z= rep(LETTERS[ 1:3 ],3)));print(df) # criação do dataframe\n\nsubset(df, x&gt;2)\nsubset(df, x&lt;7&y&gt;8)\ndf[1:7,c(1,2)] # subconjunto (extrai as linhas de 1 a 7, e as colunas 1 e 2)\n\ndf[df$z ==\"B\", ] # apresenta os dados (linhas) de um nível específico\ndf[df$z != \"B\",] # exclui um nível específico\n\n\n15.11.1 Dados estatísticos e funções aplicadas a dataframes\n      Também é possível extrair valores estatísticos de colunas, linhas, ou de todo o quadro de dados, como segue.\n\ndf &lt;- data.frame(list(\n  x = c(1,2,3,4,5,6,7,8,9),\n  y = c(6,7,8,9,10,11,12,13,14),\n  z= c(16,17,18,19,20,21,22,23,24)));print(df) # criação do dataframe\n\nmean(df$x) # média da coluna \"x\" (também var, sd, min, max, range, sum)\nsum(df[1,]) # soma a linha 1 de todas as colunas\nrange(df[3,2:3]) # limite de valores das colunas 2 a 3, e somente na 3a. linha\napply(df,1,mean) # calcula a média em cada linha\napply(df,2,sd) # calcula o desvio-padrão em cada coluna colunas\n\n      Nas situações em que um dataframe possui dados multivariados (subgrupos ou nível), é possível extrair parâmetros estatísticos para cada nível, ou subgrupos de dados, como abaixo.\n\ndf &lt;- data.frame(list(\n  x = c(1,2,3,4,5,6,7,8,9),\n  y = c(6,7,8,9,10,11,12,13,14),\n  z= rep(LETTERS[1:3],3)));print(df) # criação do dataframe com níveis A, B, e C\n\n  x  y z\n1 1  6 A\n2 2  7 B\n3 3  8 C\n4 4  9 A\n5 5 10 B\n6 6 11 C\n7 7 12 A\n8 8 13 B\n9 9 14 C\n\nmean(df$y [ df$z == \"B\" ] ) # em um subnível\n\n[1] 10\n\ntapply(df$y, df$z, mean) # em cada nível de uma variável\n\n A  B  C \n 9 10 11 \n\nsapply(df [3:7,] , FUN= mean) # em cada variável do dataset \n\nWarning in mean.default(X[[i]], ...): argument is not numeric or logical:\nreturning NA\n\n\n x  y  z \n 5 10 NA \n\n# Também sd, var, length, min, max, etc."
  },
  {
    "objectID": "acoes.html#a-família-apply",
    "href": "acoes.html#a-família-apply",
    "title": "15  Ações",
    "section": "15.12 A família apply",
    "text": "15.12 A família apply\n      A iteração por loops (laços) no R é bastante frequente em programação. Contudo, o uso de comandos iterativos, como o laço for, pode consumir tempo computacional significativo quando aplicado a grande conjunto de dados, como vetores, matrizes, e dataframes.\n      Dessa forma o uso de vetorização surge como alternativa nesses casos, e mesmo para programação paralela. A vetorização só não é indicada nos casos em que a alteração de um elemento do vetor depende de outros elementos, situação em que a função for é mais prolífica.\n      No R existe um família de funções para aplicação em vetores e construções correlatas, a família de comandos apply, e dentre os principais:\n\nComando apply;\nComando `tapply;\nComando sapply;\nComando mapply.\n\n    Também presentes, embora menos utilizados:\n\nComando vapply;\nComando rapply;\nComando bapply;\nComando eapply.\n\n      Em síntese, esses comandos são aplicados em programação vetorial para uso de funções pré-estabelecidas (como média, variância) ou criadas pelo usuário, e direcionadas a vetores, matrizes, listas, e dataframes. Diferem, além do alvo pretendido, também pelo registro de saída (output), se vetor ou lista, por exemplo. Seguem suas descrições.\n\n15.12.0.1 O comando apply\n        É o mais genérico de todos, podendo ser aplicado a um vetor (array) ou matriz.\n\nm &lt;-matrix(1:12,nrow=3);m\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\napply(m,1,sum) # em matriz; índice 1 -&gt; linhas\n\n[1] 22 26 30\n\napply(m,2,sum) # em matriz; índice 2 -&gt; colunas\n\n[1]  6 15 24 33\n\nn &lt;- matrix(1:12, nrow=1)\napply(n,1,sum) # em vetor, embora identificado como matriz de uma linha, já que `apply` não é para uso em vetor\n\n[1] 78\n\n\n      Caso haja elementos desconhecidos nos dados (NA), é necessário sua remoção para efetivar o cálculo (nessa família, como nos demais comandos para o mesmo fim, no R). Exemplificando:\n\nm &lt;-matrix(1:12,nrow=3)\nm[3,4]&lt;- NA; m # insere NA na linha 3 da coluna 4\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   NA\n\napply(m,1,sum) # em matriz; índice 1 -&gt; linhas\n\n[1] 22 26 NA\n\n\n      Veja que a função não foi computada para a célula contendo NA. Para removê-la do cálculo:\n\napply(m,1,sum,na.rm=TRUE)\n\n[1] 22 26 18\n\n\n      Em adição, apply pode aplicar-se também a colunas.\n\napply(m,1,sum,na.rm=TRUE) # em linha\n\n[1] 22 26 18\n\napply(m,2,sum,na.rm=TRUE) # em coluna\n\n[1]  6 15 24 21\n\n\n\n15.12.0.1.1 Aplicando apply a uma função arbitrária\n\nf = function(x) mean(x^2)\napply(m,1,f)\n\n[1] 41.5 53.5   NA\n\n\n\n\n\n15.12.0.2 O comando lapply\n      Similar ao anterior, mas aplicado a uma lista (l para lista), como no exemplo a seguir.\n\nl &lt;-list(operacao=matrix(1:12,nrow=4),entrada=1:7,saida=7, custo=c(1,2,3));l\n\n$operacao\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n$entrada\n[1] 1 2 3 4 5 6 7\n\n$saida\n[1] 7\n\n$custo\n[1] 1 2 3\n\n\n\nll &lt;- lapply(l,sum); ll\n\n$operacao\n[1] 78\n\n$entrada\n[1] 28\n\n$saida\n[1] 7\n\n$custo\n[1] 6\n\n\n      Para converter esse resultado num vetor:\n\null &lt;- unlist(lapply(ll,sum)); ull\n\noperacao  entrada    saida    custo \n      78       28        7        6 \n\n\n      E para converter o vetor numa tabela:\n\ndf.ll &lt;- as.matrix(ull)\nknitr::kable(df.ll, caption = \"Orçamento geral\", \"pipe\")\n\n\nOrçamento geral\n\n\noperacao\n78\n\n\nentrada\n28\n\n\nsaida\n7\n\n\ncusto\n6\n\n\n\n\n\n      Observe que o uso da função kable exige a entrada seja de uma lista ou matriz, razão da conversão intermediária nessa última.\n\n\n15.12.0.3 O comando sapply\n      Semelhante ao `lapply, embora com saída mais confortável, diretamente para um vetor (s para “simplify”).\n\nsapply(l,sum)\n\noperacao  entrada    saida    custo \n      78       28        7        6 \n\n\n\n\n15.12.0.4 O comando mapply\n      Com o nome indicando uma aplicação para variação múltipla (“multi-variant apply”), mapply permite uma flexibilidade para uso de funções arbitrárias, como no exemplo abaixo.\n\nx&lt;-c(a=25,b=12,c=42)\n y&lt;-c(d=43,e=55,f=12) # criação de 2 vetores\n \n soma.vec &lt;-function(u,v){\n  (u+v)*2 # criação de função de soma de vetores\n}\nmapply(soma.vec,x,y) # aplicação de `mapply` à função criada\n\n  a   b   c \n136 134 108 \n\n\n\n\n15.12.0.5 O comando tapply\n      Indicado para a aplicação de função a elementos de um vetor (array). E, em especial, a sumários estatísticos (mean, sd, var, max, min, range) para diferentes fatores.\n\ndf &lt;- data.frame(list(\n  x = c(1,2,3,4,5,6,7,8,9),\n  y = c(6,7,8,9,10,11,12,13,14),\n  grup = c(rep(\"A\",3),rep(\"B\",3),rep(\"C\",3))))\n\ntapply(df$y, df$grup, mean)  \n\n A  B  C \n 7 10 13 \n\n\n      Resumindo a aplicação da família apply:\n\nComando apply: vetor;\nComandolapply: lista;\nComandosapply: simplifica lapply pra saída como vetor;\nComandomapply: versão multivariada de lapply;\nComandotapply: vetor de matriz ou dataframe."
  },
  {
    "objectID": "carrega.html#carregamento-dos-dados",
    "href": "carrega.html#carregamento-dos-dados",
    "title": "16  Carregamento de dados",
    "section": "16.1 Carregamento dos dados",
    "text": "16.1 Carregamento dos dados\n      Há diversas formas de carregamento dos dados no R. Mas na prática, ou você 1) copia de uma planilha os dados obtidos na bancada de laboratório, por exemplo, e cola no R, ou você 2) monta uma tabela na unha, mesmo, ou 3) importa o arquivo dessa planilha."
  },
  {
    "objectID": "carrega.html#colando-os-dados-de-uma-planilha-ou-montando-a-tabela-na-unha",
    "href": "carrega.html#colando-os-dados-de-uma-planilha-ou-montando-a-tabela-na-unha",
    "title": "16  Carregamento de dados",
    "section": "16.2 Colando os dados de uma planilha ou montando a tabela “na unha” !",
    "text": "16.2 Colando os dados de uma planilha ou montando a tabela “na unha” !\n     Para colar os dados copiados de um Excel (Microsoft) ou Calc (Libreoffice), basta copiar o trecho desejado e colar no espaço mencionado na função abaixo, entre os (’ … ’):\n\n# Colando os dados de uma planilha\nmeus.dados &lt;- read.table(header=T, text='\ndados # colar aqui os dados\n')\n\n      Traduzindo….\n\nO símbolo “&lt;-” indica que você vai atribuir aos dados copiados da planilha o nome “meus.dados”. Isso é feito pra se trabalhar depois com esse objeto do R, pra plotagem e análises. Pode-se utilizar o sinal de igualdade =, embora haja discussões a respeito. Se por um lado o sinal de igualdade refere-se mais a atribuição de valores do que de objetos, por outro possui digitação mais sucinta e menos ambígua em caso de erro tipográfico.\nA função read.table é quem manda o R fazer essa atribuição\nO que está dentro dos parênteses é o que se chama argumentos da função. No caso, os argumentos são para a) manter os nomes das colunas (header = T; T = TRUE), e 2) colocar o material copiado no espaço (text = ´…´).\n\n  Pasme, mas….pra montar uma tabela na unha o comando é o mesmo. Basta separar os elementos com um espaço:\n\n# Criando a tabela de dados\nmeus.dados &lt;- read.table(header = T, text  = '\n  A B C\n  1 2 3\n  4 5 6\n  ')"
  },
  {
    "objectID": "carrega.html#importando-os-dados-de-uma-planilha",
    "href": "carrega.html#importando-os-dados-de-uma-planilha",
    "title": "16  Carregamento de dados",
    "section": "16.3 Importando os dados de uma planilha",
    "text": "16.3 Importando os dados de uma planilha\n      Nada complicado, só a função é que muda. Você pode importar do MS Excel, do Libreoffice Calc, ou de outra qualquer. Para os dois primeiros:\n\n16.3.1 Importando do Excel\n      Basta você carregar uma biblioteca (ou pacote) antes, chamada readxl. É facinho, veja:\n\nlibrary(readxl)\n\n      Agora você pode importar um arquivo do Excel, só observando que, a menos que você queira complicar mais um pouquinho a linha de comando, deve deixar apenas uma aba presente.\n\nmeus.dados &lt;- read_excel(\"dados.xlsx\")\n\n\n\n16.3.2 Importando de outras planilhas (Libreoffice)\n      Também é possível importar os dados de planilhas como o Calc do Libreoffice. Pra isso basta salvar o arquivo na planilha como .CSV (“comma separated value”). E não precisa instalar nenhuma biblioteca adicional.\n\nmeus.dados &lt;- read.csv(\"dados.csv\")\n\n      Alternativamente, pode-se selecionar o arquivo CSV a partir de uma janela separada, como em:\n\nread.csv( file.choose( ) ) \n\n      A importação de arquivos pode esbarrar num erro comum de separação de valor decimal. Nesse caso deve-se atentar para o tipo de símbolo decimal empregado pela planilha (editor de texto, Excel, Calc, etc). Exemplificando:\n\ndados &lt;- read.csv(\"dados.csv\", dec = \",\")\n\n      Também é possível a importação de dados no formato TXT pelo uso da função scan. Nesse caso a importação dá-se exclusivamente por dados numéricos e como uma matriz.\n\n\n16.3.3 Exemplos de datasets\n      A observação, análise e produção de gráficos de conjuntos de dados pode ser realizada com datasets empregados normalmente para exemplificação de comandos e funções do R. Dois grandes conjuntos são normalmente utilizados, um conjunto interno que já vem na instalação do R, e outro, pertencente ao pacote datasets. Para identificar os conjuntos de dados presentes:\n\ndata()"
  },
  {
    "objectID": "carrega.html#observando-os-dados",
    "href": "carrega.html#observando-os-dados",
    "title": "16  Carregamento de dados",
    "section": "16.4 Observando os dados",
    "text": "16.4 Observando os dados\n      Entre as funções que permitem uma rápida análise nos dados incorporados ao R, ilustram-se as que seguem:\n\ndados &lt;- seq(1:20) # cria um conjunto de dados\nsummary(dados) # algumas estatísticas\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    5.75   10.50   10.50   15.25   20.00 \n\nnames(dados) # nomes dos vetores coluna\n\nNULL\n\nhead(dados) # as 1as. cinco linhas\n\n[1] 1 2 3 4 5 6\n\nstr(dados) # a descrição dos dados\n\n int [1:20] 1 2 3 4 5 6 7 8 9 10 ...\n\nlibrary(tibble)\ntibble(dados) # mais descritivo ainda, da biblioteca homônima\n\n# A tibble: 20 × 1\n   dados\n   &lt;int&gt;\n 1     1\n 2     2\n 3     3\n 4     4\n 5     5\n 6     6\n 7     7\n 8     8\n 9     9\n10    10\n11    11\n12    12\n13    13\n14    14\n15    15\n16    16\n17    17\n18    18\n19    19\n20    20\n\n\n      Para se verificar mais apropriadamente a extensão de informação dos comandos acima, exemplifica-se seu uso ao dataset interno iris, um conjunto de dados de 50 plantas do gênero Iris, classificadas por espécie, tamanho e largura de pétalas e sépalas.\n\nsummary(iris) \n\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n       Species  \n setosa    :50  \n versicolor:50  \n virginica :50  \n                \n                \n                \n\nnames(iris) \n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\nhead(iris) \n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\nstr(iris)\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nlibrary(tibble)\ntibble(iris)\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\n\n16.4.1 Observação com o pacote explore\n      O pacote explore permite uma descrição mais detalhada ainda de um dataset. É melhor empregado para conjuntos mais complexos, onde se deseja extrair informações exploratórias (Exploratory Data Analysis - EDA), com tabelas, sumários e gráficos. Ilustrando seu uso para o dataset ‘iris’ :\n\nlibrary(explore)\nexplore(iris)\n\n# Obs: para visualizar o resultado deve-se carregar o trecho no `R`, já que a saída é de significativa complexidade gráfica."
  },
  {
    "objectID": "carrega.html#convertendo-os-dados-importados-para-um-objeto-do-r",
    "href": "carrega.html#convertendo-os-dados-importados-para-um-objeto-do-r",
    "title": "16  Carregamento de dados",
    "section": "16.5 Convertendo os dados importados para um objeto do R",
    "text": "16.5 Convertendo os dados importados para um objeto do R\nUma função bastante útil após a importação de um *dataset* é sua conversão para um objeto que possa ser trabalho no `R` para recriação, como ocorre no compartilhamento de um *script*, por exemplo. Ilustrando:\n\nmeus.dados &lt;- read.csv(\"dados.csv\")\ndados &lt;-dput(meus.dados)\n\n      Também é possível utilizar o comando dput para a conversão de dados criados no R, como em:\n\n# Criando a tabela de dados\nmeus.dados &lt;- read.table(header = T, text  = '\n  A B C\n  1 2 3\n  4 5 6\n  ')\n\ndados &lt;- dput(meus.dados); dados\n\nstructure(list(A = c(1L, 4L), B = c(2L, 5L), C = c(3L, 6L)), class = \"data.frame\", row.names = c(NA, \n-2L))\n\n\n  A B C\n1 1 2 3\n2 4 5 6\n\n\n      Ao se atribuir uma variável ao segmento “structur(list…)”, o objeto pode ser compartilhado para uso em outro computador, por exemplo, sem riscos de ocorrer erros por distintas tipografias.\n      Também é possível exportar essa estrutura de dados como um arquivo TXT para compartilhamento:\n\nwrite.csv(dados, \"meus.dados.csv\")"
  },
  {
    "objectID": "funcoes.html",
    "href": "funcoes.html",
    "title": "18  Funções",
    "section": "",
    "text": "#### Funções\n# 1. \nx2 &lt;- function(x) x^2 # simples\n\n# 2. \ng&lt;-function(x) return(x+1) # com return\n\n# 3. \ng &lt;-function(x){ # entre chaves\n  return(x+1)\n}\n\n# 4. \nx &lt;- c(1,2,3) # para vetor\ny &lt;- function(x) {\n  return(x+1)\n}\n\n      Pode ser bem elucidativo a elaboração de um gráfico de equação com variação em um parâmetro, o que se obtém com um laço iterativo (loop) ‘for’, e a indexação de cada elemento de um vetor (i). Segue um exemplo.\n\nplot.new()\nn &lt;- c(rev(1:5)/10)\nfor (i in 1:length(n)) {\n  curve(n[i]^x, add=TRUE)\n}  # função aplicada a vetor com output gráfico\n\n\n\n\n      Interessante também a alocação de um período de tempo entre a elaboração de cada gráfico do trecho, pela função Sys.sleep. Contudo, a percepção dessa pausa entre os perfis é percebida somente ao rodar o trecho de código.\n\nplot.new()\nfor (i in 1:length(n)) {\n  curve(n[i]^x, add=TRUE)\n  Sys.sleep(0.5)\n}  # mesma acima, mas com delay\n\n\n\n# Obs: A percepção dessa pausa entre os perfis é percebida somente ao rodar o trecho\n\n      Uma variação desse recurso envolve o uso da função plot(). A diferença reside na produção de gráficos sequenciais individualizados, o que permite a visualização do output com pausa mesmo na página de internete:\n\nn &lt;- rev(c(1,2,3,4,5))\nfor (i in 1:length(n)) {\n  plot(x,x^n[i])\n  Sys.sleep(2)\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      Juntando as duas possibilidades acima, laço iterativo e indexação em vetor, bem como a visualização do parâmetro que sofreu a variação, eleva-se a possibilidade de compreensão de relações entre variáveis de uma equação “plotável”, como apresentado abaixo.\n\n#  7. Iteração para uma equação com variação em \"n\"\nplot.new()\nn &lt;- c(rev(1:5)/10)\nfor (i in 1:length(n)) {\n  add &lt;- if(i==1) FALSE else TRUE\n  curve(n[i]*x^3-2*x+1,\n        type = \"l\",\n        col= i, lwd=0.8, from = 0.6 , to= 1, n =100,\n        xlab=\"x\", ylab=\"f(x)\", add=add)\n  xi &lt;- n[i]\n  cat(\"valor de expoente: \", xi,\"\\n\")\n  add&lt;-if(i == 1) FALSE else TRUE # controle de fluxo que permite adição de curva a partir da segunda iteração (ou seja, quando i &gt; 1)\n  Sys.sleep(0.5) # pausa entre as interações\n} \n\n\n\n\nvalor de expoente:  0.5 \nvalor de expoente:  0.4 \nvalor de expoente:  0.3 \nvalor de expoente:  0.2 \nvalor de expoente:  0.1"
  },
  {
    "objectID": "ajustes.html#ajustes-de-dados",
    "href": "ajustes.html#ajustes-de-dados",
    "title": "19  Ajustes de Dados",
    "section": "19.1 Ajustes de dados",
    "text": "19.1 Ajustes de dados\nmostrar vantagens e desvantagens de linear e não linear\n\n19.1.1 Ajuste linear\n\n\n19.1.2 Ajuste multilinear\n\n\n19.1.3 Ajuste curvilinear\n\n19.1.3.1 Ajuste não linear"
  },
  {
    "objectID": "receitas.html#ajuste-linear-de-dados-e-plotagem",
    "href": "receitas.html#ajuste-linear-de-dados-e-plotagem",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.1 Ajuste linear de dados e plotagem",
    "text": "20.1 Ajuste linear de dados e plotagem\n\nx &lt;- 1:5\ny &lt;- c(2, 6, 7, 11, 15)\nplot(x,y)\nlinxy &lt;- lm(y~x)\nabline(linxy, col=2, lty=2)"
  },
  {
    "objectID": "receitas.html#linearização-de-curva-hiperbólica-e-adição-de-linha",
    "href": "receitas.html#linearização-de-curva-hiperbólica-e-adição-de-linha",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.2 Linearização de curva hiperbólica e adição de linha",
    "text": "20.2 Linearização de curva hiperbólica e adição de linha\n\na=5 \nb=1 # parâmetros da curva hiperbólica\n\nset.seed(1) # fixa a semente de geração aleatória\nx &lt;- c(1,3,10,20,50,100,200)\ny &lt;- a*x/(b+x)+rnorm(n=7,mean=0,sd=0.1)\npar(mfrow=(c(1,2))) # prepara para apresentar 2 gráficos na tela\nplot(x,y) # plota o gráfico hiperbólico\nplot(1/x,1/y) # plota o gráfico linearizado\nabline(1/a,b/a, lty=2, col=2) # adiciona a linha\n\n\n\nlayout(1) # retorna ao layout original"
  },
  {
    "objectID": "receitas.html#gráfico-com-anotações-atípicas-símbolos-grego",
    "href": "receitas.html#gráfico-com-anotações-atípicas-símbolos-grego",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.3 Gráfico com anotações atípicas (símbolos, grego)",
    "text": "20.3 Gráfico com anotações atípicas (símbolos, grego)\n\nplot(x,y, \n     ylab = expression(Delta^13*C-CO[2]~\"(\\u2030)\"),  \n     xlab = expression(italic(A[380])~\"(\"*mu*\"mol\"~CO[2]~m^-2~s^-1*\")\"))\n\n\n\n\n      Além do pacote base da instalação do R, o pacote plotmath também permite uma série de anotações atípicas."
  },
  {
    "objectID": "receitas.html#gráfico-de-colunas-com-barras-de-erro",
    "href": "receitas.html#gráfico-de-colunas-com-barras-de-erro",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.4 Gráfico de colunas com barras de erro",
    "text": "20.4 Gráfico de colunas com barras de erro\n\nset.seed(10)\ny &lt;- runif(5)\nbarras &lt;- barplot(y, names=c(\"A\", \"B\", \"C\", \"D\", \"E\"))\nerro &lt;- y/3\narrows(x0=barras,y0=y,x1=barras,y1=y+erro, length = 0.1, angle =90)"
  },
  {
    "objectID": "receitas.html#adição-de-curva-de-spline-em-gráfico",
    "href": "receitas.html#adição-de-curva-de-spline-em-gráfico",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.5 Adição de curva de spline em gráfico",
    "text": "20.5 Adição de curva de spline em gráfico\n\nx = 1:15\ny = rnorm(15)\nplot(x,y)\nlines(spline(x,y))"
  },
  {
    "objectID": "receitas.html#criação-de-sequência-aleatória-por-amostragem",
    "href": "receitas.html#criação-de-sequência-aleatória-por-amostragem",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.6 Criação de sequência aleatória por amostragem",
    "text": "20.6 Criação de sequência aleatória por amostragem\n\nsample(c(\"Ala\", \"Glu\", \"Tyr\", \"Val\", \"Trp\", \"Cys\", \"Gly\", \"Ser\", \"Ile\", \"Leu\", \"Met\", \"Phe\", \"Gln\", \"Asn\", \"Asp\"), size = 45, replace = TRUE, prob = c(0.2, 0.3, 0.2, 0.2, 0.1, 0.2, 0.3, 0.2, 0.2, 0.1, 0.2, 0.3, 0.2, 0.2, 0.1))\n\n [1] \"Met\" \"Val\" \"Leu\" \"Ser\" \"Ala\" \"Glu\" \"Glu\" \"Gly\" \"Met\" \"Glu\" \"Phe\" \"Gly\"\n[13] \"Tyr\" \"Phe\" \"Val\" \"Asn\" \"Leu\" \"Glu\" \"Tyr\" \"Phe\" \"Ile\" \"Tyr\" \"Tyr\" \"Cys\"\n[25] \"Ala\" \"Gly\" \"Phe\" \"Tyr\" \"Cys\" \"Gln\" \"Met\" \"Ile\" \"Tyr\" \"Gly\" \"Glu\" \"Gly\"\n[37] \"Ala\" \"Ser\" \"Ala\" \"Gly\" \"Ala\" \"Cys\" \"Leu\" \"Glu\" \"Glu\""
  },
  {
    "objectID": "receitas.html#simulação-de-sinais-por-sobreposição-de-curvas-gaussianas",
    "href": "receitas.html#simulação-de-sinais-por-sobreposição-de-curvas-gaussianas",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.7 Simulação de sinais por sobreposição de curvas gaussianas",
    "text": "20.7 Simulação de sinais por sobreposição de curvas gaussianas\n      A curva abaixo simula a resposta de absorção molecular de uma proteína.\n\ngauss = function(x0,x,sig) 5*{1/(sqrt(2*pi)*sig)* exp(-(x-x0)^2/(2*sig^2))} # define a função gaussiana (fator 5 para absorção realista)\n\ncurve(gauss(380,x,20)+.5*gauss(310,x,20)+ .2*gauss(290,x,10)+1.5*gauss(215,x,10),col=\"blue\",xlim=c(190,420),ylab=\"y\")"
  },
  {
    "objectID": "receitas.html#cálculo-de-área-sob-curva-função",
    "href": "receitas.html#cálculo-de-área-sob-curva-função",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.8 Cálculo de área sob curva (função)",
    "text": "20.8 Cálculo de área sob curva (função)\n\nset.seed(70)\nx &lt;- seq(from=300, to=450, length=20)\ny &lt;- gauss(380,x,20)+abs(runif(20,min=0,max=1/500))\nplot(x,y, cex=0.7)\nf = splinefun(x,y)\nintegrate(f,0,pi)\n\n-84.59541 with absolute error &lt; 9.4e-13\n\nlines(spline(x,y), col=2, lwd=2)\npolygon(x, y, col = \"lightgrey\")"
  },
  {
    "objectID": "receitas.html#cálculo-de-área-sob-curva-dados",
    "href": "receitas.html#cálculo-de-área-sob-curva-dados",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.9 Cálculo de área sob curva (dados)",
    "text": "20.9 Cálculo de área sob curva (dados)\n\n# Área sob curva (AUC) de dados\n\n# 1. Pracma\n\ndat &lt;- read.table(header=TRUE, text='\n                  N         x     y\n1    20         0.2\n2    30         0.3\n3    40         0.4')\n\nplot(y~x, data=dat)\n\nrequire(pracma)\n\nLoading required package: pracma\n\nAUC &lt;- trapz(dat$x,dat$y); AUC\n\n[1] 6\n\n# 2. DescTools\n\nrequire(DescTools)\n\nLoading required package: DescTools\n\n\n\nAttaching package: 'DescTools'\n\n\nThe following objects are masked from 'package:pracma':\n\n    Mode, Rank\n\n\n\n\nAUC2 &lt;- AUC(dat$x,dat$y, method=\"trapezoid\"); AUC2\n\n[1] 6"
  },
  {
    "objectID": "receitas.html#aplicação-de-tarefas-a-níveis-de-um-dataset-e-saída-distintas-plot-arquivo",
    "href": "receitas.html#aplicação-de-tarefas-a-níveis-de-um-dataset-e-saída-distintas-plot-arquivo",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.10 Aplicação de tarefas a níveis de um dataset, e saída distintas (plot, arquivo)",
    "text": "20.10 Aplicação de tarefas a níveis de um dataset, e saída distintas (plot, arquivo)\n      Para ilustrar a vantagem de automatização de ações por loop (quando a vetorização não é possível), segue uma receita para uma análise estatística, plotagem com títulos e etiquetas, bem como salvamento de gráficos em jpeg com nomes específicos, toda a saída separada pelos níveis distintos de um dataset. Para tanto será utilizado o conjunto de dados iris.\n\nall.iris &lt;- unique(iris$Species) # extrai os níveis do dataset\nfor (i in 1:3){ # inicia o loop\n  Species.i &lt;- all.iris[i] # define o título de cada plot e arquivo separado\n  iris.i &lt;- iris[iris$Species == Species.i, ] # define o subconjunto para cada gráfico, separado por nível\n  plot.arq &lt;- paste(Species.i, \".jpg\", sep = \"\") # monta o arquivo separado dos plots\n  jpeg(file = plot.arq)\n  plot(x = iris.i$Petal.Length, y = iris.i$Petal.Width,\n       xlab = \"Comprimentao de pétalas\",\n       ylab = \"Largura de pétalas\", main = Species.i) # elabora o gráfico\n\n  # Média e desvio-padrão de comprimento de pétalas, por subgrupo\n  print(paste(\"Média de comprimento de pétalas do subgrupo\", Species.i, \" (x+/-sd):\", mean(iris.i$Petal.Length),\"+/-\", sd(iris.i$Petal.Length)))\n} # fecha o loop\n\n[1] \"Média de comprimento de pétalas do subgrupo setosa  (x+/-sd): 1.462 +/- 0.173663996480184\"\n\n\n[1] \"Média de comprimento de pétalas do subgrupo versicolor  (x+/-sd): 4.26 +/- 0.469910977239958\"\n\n\n[1] \"Média de comprimento de pétalas do subgrupo virginica  (x+/-sd): 5.552 +/- 0.551894695663983\""
  },
  {
    "objectID": "receitas.html#criação-de-linha-de-base-em-conjunto-de-dados",
    "href": "receitas.html#criação-de-linha-de-base-em-conjunto-de-dados",
    "title": "20  Algumas receitas matemáticas",
    "section": "20.11 Criação de linha de base em conjunto de dados",
    "text": "20.11 Criação de linha de base em conjunto de dados\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"
  },
  {
    "objectID": "exemplos.html",
    "href": "exemplos.html",
    "title": "21  Exemplos",
    "section": "",
    "text": "plot de função"
  },
  {
    "objectID": "pacotes.html",
    "href": "pacotes.html",
    "title": "22  Pacotes",
    "section": "",
    "text": "Dentre os quase 20 mil pacotes ou bibliotecas (packages) presentes no website do R CRAN, vale mencionar alguns relacionados à produtividade de documentos, dinâmicos ou não.\n\ntidyverse - coleção de pacotes do R para Ciência de Dados;\nblastula - envia arquivo Rmarkdown por email;\nequatiomatric - insere parâmetros de ajustes em modelo de equação;\ngifsky - converte imagens GIF em sequência de animações;\ngganimate - animação de gráficos produzidos com pacote ggplot2;\nDiagrammeR - construção de diagramas, fluxogramas, e redes;\nplan - construção de diagramas de Gantt."
  },
  {
    "objectID": "animacoes2.html#variação-de-parâmetro-em-função-plotável-e-output-de-resultado",
    "href": "animacoes2.html#variação-de-parâmetro-em-função-plotável-e-output-de-resultado",
    "title": "23  Animações",
    "section": "23.1 Variação de parâmetro em função plotável e output de resultado",
    "text": "23.1 Variação de parâmetro em função plotável e output de resultado\n      Uma animação com uso de laço iterativo (loop) sem qualquer pacote adicional pode agregar valor à compreensão das relações entre variáveis, tal como segue.\n\n## Relação de pH com potencial de equilíbrio (Nernst)\n\n## Parâmetros da equação\nEo = 0.7 # potencial padrão, V\nR = 8.314 # const. geral dos gases, J/mol/K\nT = 298 # temperatura absoluta\nF = 96485 # const. de Faraday, C/mol\n## Vetor de no. de elétrons\nn = seq(from=1,to=5,by=1)\n\n## Iteração para a equação de Nernst com variação em \"n\"\nfor (i in 1:length(n)) {\n  add &lt;- if(i==1) FALSE else TRUE\n  curve(Eo-2.303*(R*T/(n[i]*F))*x+runif(length(n),0,0.02),\n        type = \"b\",col= i, lwd=0.8, \n        from =1 , to=14, n =10, cex =0.5,\n        xlab=\"pH\", ylab=\"E, V\", add=add)\n  nernst.slope &lt;- 2.303*(R*T/(n[i]*F))\n  cat(\"inclinação de Nernst (mV/pH): \", round(nernst.slope*1e3,digits = 1),\"\\n\")\n  add&lt;-if(i == 1) FALSE else TRUE # controle de fluxo que permite adição de curva a partir da segunda iteração (ou seja, quando i &gt; 1)\n  Sys.sleep(0.5) # pausa entre as interações\n} \n\ninclinação de Nernst (mV/pH):  59.1 \ninclinação de Nernst (mV/pH):  29.6 \ninclinação de Nernst (mV/pH):  19.7 \ninclinação de Nernst (mV/pH):  14.8 \ninclinação de Nernst (mV/pH):  11.8 \n\n### Anotações no plot (n, no. de elétrons)\n#arrows(2,0,13.5,0.6,length=0.1,angle=45, col=\"blue\") # seta para Km # seta de inclinações progressivas\ntext(11,0,\"n=1\",cex=0.7)\ntext(11.5,0.4,\"n=2\",cex=0.7)\ntext(11.7,0.5,\"n=3\",cex=0.7)\ntext(12,0.55,\"n=4\",cex=0.7)\ntext(12.4,0.6,\"n=5\",cex=0.7)"
  },
  {
    "objectID": "animacoes2.html#o-pacote-plotly",
    "href": "animacoes2.html#o-pacote-plotly",
    "title": "23  Animações",
    "section": "23.2 O pacote plotly",
    "text": "23.2 O pacote plotly\n      O exemplo abaixo apresenta um gráfico no qual características dos dados podem ser visualizadas por arraste de mouse sobre os mesmos (mouse over).\n\ntempo &lt;- c(rep(rep(1:4, 4),4))\nresposta &lt;- c(1,2,3,4,2,4,6,8,10,14,18,22,24,30,36,42)\nniveis &lt;- c(rep(\"A\",4),rep(\"B\", 4), rep(\"C\", 4), rep(\"D\", 4)) # cria vetores com níveis\n\ndf &lt;-data.frame(tempo, resposta, niveis) # cria um *dataset* multivariado\n\nlibrary(ggplot2)\nlibrary(plotly) # carrega as bibliotecas necessárias\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\np &lt;- ggplot(data=df, aes(x=tempo, y=resposta, shape=niveis, color=niveis)) +\n  geom_point(aes(size=5)) +\n  geom_line(aes(linetype=niveis))+\n  facet_grid(cols=vars(niveis)) # cria um gráfico e atribui uma variável a esse\n\nggplotly(p) # executa uma animação, no caso, um *mouse over* que fornece os dados de cada ponto do gráfico"
  },
  {
    "objectID": "animacoes2.html#o-pacote-manipulate",
    "href": "animacoes2.html#o-pacote-manipulate",
    "title": "23  Animações",
    "section": "23.3 O pacote manipulate",
    "text": "23.3 O pacote manipulate\n\n\n      Entre outras características, é possível a criação de um controle deslizante (slider) para que se observe o resultado gráfico sobre a variação de um ou mais parâmetros de uma equação.\n      Exemplificando, uma curva hiperbólica com variação no parâmetro de meia resposta (k), como segue. Para obter o resultado visual, é necessário rodar o trecho de código no RStudio.\n\nlibrary (manipulate)\nk=1 # valor inicial do parâmetro a variar\nx &lt;- 1:100 # criação de vetor\nmanipulate(plot(x,2*x/(k+x),\n                ylab=\"f(x)\", ylim=c(0,2)),\n                k = slider(0.1, 20)) # aplicação da função\n\n# Obs: o resultado só pode ser visualizado dentro do *RStudio*\n\n      O mesmo exemplo acima pode ser também obtido por uma função matemática, e não apenas por plotagem de pontos, como segue.\n\nlibrary(manipulate)\nmanipulate(curve(2*x/(k+x),\n                 ylab=\"f(x)\", from=0, to=50,\n                 ylim=c(0,2)), k = slider(0.1, 50))\n\n# Obs: o resultado só pode ser visualizado dentro do *RStudio*"
  },
  {
    "objectID": "animacoes2.html#o-pacote-gganimate",
    "href": "animacoes2.html#o-pacote-gganimate",
    "title": "23  Animações",
    "section": "23.4 O pacote gganimate",
    "text": "23.4 O pacote gganimate\n\nlibrary(ggplot2)\nlibrary(gganimate)\nanim &lt;- ggplot(mtcars, aes(mpg, disp)) +\ngeom_point(aes(color = gear)) +\ntransition_states(gear, transition_length = 2, state_length = 1) +\nenter_fade() +\nexit_fade()"
  },
  {
    "objectID": "animacoes2.html#o-pacote-iplots",
    "href": "animacoes2.html#o-pacote-iplots",
    "title": "23  Animações",
    "section": "23.5 O pacote iplots",
    "text": "23.5 O pacote iplots\n      Apesar de antigo, o pacote iplots permite a criação de gráficos interativos (pontos, barras, histogramas e mosaico) que destacam os valores de um dado em mais de um gráfico. Isso é particularmente útil quando se deseja identificar um determinado ponto de um gráfico cujas variáveis são transformadas para a produção de outro. Exemplificando do pacote:\n\ndata(iris)\nattach(iris)\niplot(Sepal.Width,Petal.Width)\niplot(Sepal.Width/Sepal.Length, Species)\n\n      O pacote também permite ampliação (zoom) e alguns efeitos adicionais (brushing)."
  },
  {
    "objectID": "animacoes2.html#o-pacote-shiny",
    "href": "animacoes2.html#o-pacote-shiny",
    "title": "23  Animações",
    "section": "23.6 O pacote shiny",
    "text": "23.6 O pacote shiny"
  },
  {
    "objectID": "animacoes2.html#o-pacote-gifski",
    "href": "animacoes2.html#o-pacote-gifski",
    "title": "23  Animações",
    "section": "23.7 O pacote gifski",
    "text": "23.7 O pacote gifski\nnão tá rodando no lab"
  },
  {
    "objectID": "programacao.html#if",
    "href": "programacao.html#if",
    "title": "24  Testes condicionais e laços",
    "section": "24.1 IF",
    "text": "24.1 IF\n\nif ( expressão ) { execute } # se verdadeiro\n\n\nx = 7\nif ( x &gt; 3 )\n{\n  print( \"Valor acima do teto.\",quote=FALSE )\n}\n\n[1] Valor acima do teto.\n\n\n\n24.1.1 And\n\nif ( condição 1 && condição 2 ) { execute } # se ambas forem verdadeiras\n\n\nx &lt;- 7\n\nif(  x &gt; 5  &&  x &lt; 9 )\n{\n  print( \"O valor está entre 6 e 9\" )\n}\n\n[1] \"O valor está entre 6 e 9\"\n\n\n\n\n24.1.2 Or\n\nif ( condição 1 || condição 2 ) { execute} # se uma ou outra for verdadeira\n\n\nx &lt;- 11\n\nif( x &lt; 13 || x &gt; 17 )\n{\n  print( \"O valor pode ser menor que 13 ou maior que 17\" )\n}\n\n[1] \"O valor pode ser menor que 13 ou maior que 17\"\n\n\n\n\n24.1.3 Ramificação\n\nif ( condição )\n{\nexecute 1 # se verdadeiro\n} else\n{\nexecute 2 # se falso\n\n\n\n24.1.4 Concatenação\n\nif ( condição 1 )\n{\nexecute 1 se verdadeiro\n} else if ( condição 2 )\n{\nexecute 2 se verdadeiro\n} else if ( condição 3 )\n{\nexecute 3 se verdadeiro\n} else\n{\nexecute 4 se falso\n}\n\n\nnota &lt;- 6.5\n\nif( nota &gt; 6 )\n{\n  print( paste( \"Passou de ano, com nota \", nota) )\n} else\n  { print( paste( \"Ficou de recuperação, com nota \", nota ) )\n}\n\n[1] \"Passou de ano, com nota  6.5\"\n\n\n\nnota &lt;- 3.5\n\nif( nota &gt; 6 )\n{\n  print( paste( \"Passou direto, com nota \", nota) )\n} else\n  {\n    if( nota &gt; 4 ) print( paste( \"Ficou de recuperação, com nota \", nota ) )\n    else\n    {\n      print( paste( \"Tomou bomba direto, com nota \", nota ) )\n    }\n  }\n\n[1] \"Tomou bomba direto, com nota  3.5\""
  },
  {
    "objectID": "programacao.html#switch",
    "href": "programacao.html#switch",
    "title": "24  Testes condicionais e laços",
    "section": "24.2 Switch",
    "text": "24.2 Switch\n        Trata-se de uma função alternativa para sequência de IF concatenados, sendo mais rápido e legível.\n\nswitch ( condição , lista ) # onde \"lista\" é caso 1, caso 2,...\n\n      A função é flexível, podendo apresentar como saída um valor/caractere indexado numa lista:\n\nswitch( 3, \"arroz\", \"feijão\", \"agrião\", \"couve\", \"macarrão\" )\n\n[1] \"agrião\"\n\n\n\nnumer &lt;- round(sqrt(rnorm(1, mean = 2, sd = 1)^2)) # cria número aleatório próximo de 1, 2, e em módulo\nswitch( numer, { print( \"Acima da média.\" ) }, {\nprint( \"Abaixo da média.\" ) } ) \n\n[1] \"Abaixo da média.\"\n\n\n      Alternativamente, pode-se aplicar um trecho de código selecionado a partir da indexação na lista:\n\nqualidade &lt;- \"regular\"\nswitch(qualidade,\n       \"péssimo\" = {qualidade &lt;- 4},\n       \"ruim\" = {qualidade &lt;- 6},\n       \"mediano\" = {qualidade &lt;- 7},\n       \"regular\" = {qualidade &lt;- 8},\n       \"bom\" = {qualidade &lt;- 9},\n       \"ótimo\" = {qualidade &lt;- 9.5},\n       \"excelente\" = {qualidade &lt;- \"um semideus!\"})\nprint(paste(\"O produto apresentou qualidade abaixo de\", qualidade ))\n\n[1] \"O produto apresentou qualidade abaixo de 8\"\n\n\n      Embora o comando switch opere com caracteres (strings), pode-se contornar uma solução de ranqueamento numérico acima, como segue:\n\nqualidade &lt;- \"7\"\nswitch(qualidade,\n       \"2\" = {qualidade &lt;- \"péssima\"},\n       \"4\" =  {qualidade &lt;- \"ruim\"},\n       \"6\" =  {qualidade &lt;- \"mediana\"},\n       \"7\" = {qualidade &lt;- \"regular\"},\n       \"8\" = {qualidade &lt;- \"boa\"},\n       \"9\" = {qualidade &lt;- \"ótima\"},\n       \"10\" = {qualidade &lt;- \"excelente\"})\nprint(paste(\"O produto apresentou \", qualidade, \"qualidade.\"))\n\n[1] \"O produto apresentou  regular qualidade.\"\n\n\n      O comando também permite a seleção de uma função, trecho de código, ou cálculo matemático, esse abaixo exemplificado:\n\nparam1 = 5\nparam2 = 12\nescolha = \"b\"\nsaida = switch(escolha,\n  \"a\"= cat(\"(p1+p2)^2 =\", (param1 + param2)^2),\n  \"b\"= cat(\"(p1+p2)^3 =\", (param1 + param2)^3),\n  \"c\"= cat(\"(p1+p2)^4 =\", (param1 + param2)^4))\n\n(p1+p2)^3 = 4913\n\ncat(\" . Essa foi a equação encontrada e seu valor.\", saida)\n\n . Essa foi a equação encontrada e seu valor."
  },
  {
    "objectID": "programacao.html#laços",
    "href": "programacao.html#laços",
    "title": "24  Testes condicionais e laços",
    "section": "24.3 Laços",
    "text": "24.3 Laços\n\n24.3.1 While\n\nwhile ( condição )\n{\nexecute seguindo a iteração do contador\n}\n\n\ncontador &lt;- 1\nwhile ( contador &lt; 5 )\n{\nprint( paste( \"O quadrado até o limite de \", contador, \"`loop` é: \", contador^2 ), quote = FALSE )\ncontador &lt;- ( contador + 1 )\n}\n\n[1] O quadrado até o limite de  1 `loop` é:  1\n[1] O quadrado até o limite de  2 `loop` é:  4\n[1] O quadrado até o limite de  3 `loop` é:  9\n[1] O quadrado até o limite de  4 `loop` é:  16\n\n\n\ncontadores tradicionais: i, j, k\n\n\n\n24.3.2 FOR\n      O laço for talvez seja o mais empregado em iterações para cálculos e gráficos, posto que é aplicado nos principais objetos a esses correlatos, como vetores, matrizes de dataframes.\n\nfor ( variável in sequência ) \n{\nexecute\n}\n\n      A sequência pode ser prefixada, como “1:4”, ou definida em função do comprimento do objeto, como num vetor, “1:length(vetor). Ilustrando para uma operação no próprio índice:\n\nfor( j in 1:4 )\n{\nprint( paste( \"Quadrado do índice \", j, \"é de\", j^2 ) )\n}\n\n[1] \"Quadrado do índice  1 é de 1\"\n[1] \"Quadrado do índice  2 é de 4\"\n[1] \"Quadrado do índice  3 é de 9\"\n[1] \"Quadrado do índice  4 é de 16\"\n\n\n      E para uma operação em vetor:\n\nvetor &lt;- c( 2, 4, 8, 12 )\nfor( j in 1:length(vetor) )\n{\nprint( paste( \"Quadrado do índice \",vetor[j], \"é de\", vetor[j]^2 ) )\n}\n\n[1] \"Quadrado do índice  2 é de 4\"\n[1] \"Quadrado do índice  4 é de 16\"\n[1] \"Quadrado do índice  8 é de 64\"\n[1] \"Quadrado do índice  12 é de 144\"\n\n\n\nx &lt;- 1:5\ny &lt;- x^2 + runif(5) # simula uma correlação \nlmxy &lt;- lm(y~x) # perfaz a regressão linear\nsaida &lt;- list( A=coef(lmxy)[1], B=coef(lmxy)[2], C=cor(x,y)) # saída como valores de intercepto, inclinação, e coeficiente de correlação linear\n\nfor( i in saida ) # loop\n{\n  print(paste(i))\n}\n\n[1] \"-6.48627170193939\"\n[1] \"5.96198708796874\"\n[1] \"0.982105748419805\"\n\n\n\n24.3.2.1 Nested loops (laços concatenados)\n\nfor( i in 1:3 )\n{\n  for( j in 1:3 )\n  {\n    cat( \"Iteração do primeiro laço i=\", i, \"Iteração do segundo laço j=\", j, \"\\n\" )\n  }\n}\n\nIteração do primeiro laço i= 1 Iteração do segundo laço j= 1 \nIteração do primeiro laço i= 1 Iteração do segundo laço j= 2 \nIteração do primeiro laço i= 1 Iteração do segundo laço j= 3 \nIteração do primeiro laço i= 2 Iteração do segundo laço j= 1 \nIteração do primeiro laço i= 2 Iteração do segundo laço j= 2 \nIteração do primeiro laço i= 2 Iteração do segundo laço j= 3 \nIteração do primeiro laço i= 3 Iteração do segundo laço j= 1 \nIteração do primeiro laço i= 3 Iteração do segundo laço j= 2 \nIteração do primeiro laço i= 3 Iteração do segundo laço j= 3"
  },
  {
    "objectID": "programacao.html#interrupção-break-e-sequência-next",
    "href": "programacao.html#interrupção-break-e-sequência-next",
    "title": "24  Testes condicionais e laços",
    "section": "24.4 Interrupção (break) e sequência (next)",
    "text": "24.4 Interrupção (break) e sequência (next)\n      O comando break é utilizado para encerrar prematuramente um trecho de código quando determinada condição é satisfeita, sucedendo-se as próximas instruções do código.\nbreak next"
  },
  {
    "objectID": "programacao.html#pausa",
    "href": "programacao.html#pausa",
    "title": "24  Testes condicionais e laços",
    "section": "24.5 Pausa",
    "text": "24.5 Pausa\nSys.sleep(tempo.seg)\n\n24.5.1 Pacote shinyjs\ndelay (tempo.ms,expressão)"
  },
  {
    "objectID": "programacao.html#continuidade-sob-pressionamento",
    "href": "programacao.html#continuidade-sob-pressionamento",
    "title": "24  Testes condicionais e laços",
    "section": "24.6 Continuidade sob pressionamento",
    "text": "24.6 Continuidade sob pressionamento\nreadline(prompt = ““)\nreadline(prompt=“Press [enter] to proceed”)"
  },
  {
    "objectID": "programacao.html#tempo-de-execução-de-tarefa",
    "href": "programacao.html#tempo-de-execução-de-tarefa",
    "title": "24  Testes condicionais e laços",
    "section": "24.7 Tempo de execução de tarefa",
    "text": "24.7 Tempo de execução de tarefa\nSys.time()\n\n24.7.1"
  },
  {
    "objectID": "programacao.html#section-1",
    "href": "programacao.html#section-1",
    "title": "24  Testes condicionais e laços",
    "section": "24.8 ",
    "text": "24.8"
  },
  {
    "objectID": "docs_exemplo.html",
    "href": "docs_exemplo.html",
    "title": "25  Documentos exemplificados",
    "section": "",
    "text": "artigo, trabalho acadêmico, tese, relatório, livro, website (templates com ispum lorum)"
  }
]